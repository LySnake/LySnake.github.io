---
title: C++ Primer Plus学习笔记(3)
comments: true
categories:
  - archives
  - technology
tags:
  - C++
  - C++ Primer Plus
description: 个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
date: 2017-06-11 17:15:03
updated: {{ updated }}
---
## 13. 类继承 ##

### 13.1派生一个类 ###

从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。

- 派生类对象存储了基类的数据成员（派生类继承了基类的实现）。
- 派生类对象可以使用基类的方法（派生类继承了基类的接口）。
- 派生类需要自己的构造函数，构造函数必须给新成员和继承的成员提供数据。
- 派生类可以根据需要添加额外的数据成员和成员函数。

### 13.1.2 构造函数：访问权限的考虑 ###

派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。例如，派生类的构造函数不能直接设置继承的成员数据，而必须使用基类的公有方法或保护方法来访问私有的基类成员。具体地说，派生类构造函数必须使用基类的构造函数。

创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员初始化列表句法来完成这种工作。

```C++
ClassName::ClassName(int a, int b):BaseClass(a, b)
{
    //todo
}
```
其中BaseClass是成员初始化列表。它是可执行的代码，它调用BaseClass构造函数。

基类必须首先被创建，如果不调用基类构造函数，程序将使用默认的基类构造函数，除非要使用默认构造函数，否则应显式调用正确的基类构造函数。

有关派生类构造函数的要点：

- 基类对象首先被创建。
- 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数。
- 派生类构造函数应初始化派生类新增的数据成员。释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。（TIP:创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。基类构造函数负责初始化继承数据成员派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表句法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。）

### 13.2 派生类和基类之间的特殊关系 ###

基类指针和引用可以在不进行显式类型转换的情况下指向或引用派生类对象.

C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是例外。不过这种例外是只单向的，不可以将基类对象和地址赋给派生类引用和指针。如果允许基类引用隐式地引用派生类对象，则可以使用基类引用为派生类对象调用基类的方法。因为派生类继承了基类的方法，所以这样做不会出现问题。如果可以将基类对象赋给派生类对象，派生类引用能够为基对象调用派生类方法，这样做将出现问题。

### 13.3 继承--is-a关系 ###

C++有3种继承方式：公有继承、保护继承和私有继承。公有继承是最常用的方式，它建立一种is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。

- 公有继承不建立has-a关系。has-a关系最容易的建模方式是，将一个对象作为另一个类的数据成员。
- 公有继承不建立is-like-a关系，也就是说，它不采用明喻。继承可以在基类的基础上添加属性，但不能删除基类的属性。
- 公有继承不建立is-implemented-as-a关系。
- 公有继承不建立uses-a关系。如PC对象派生出Printer对象是没有意义的，不过可以使用友元函数或友元类处理Printer与PC类之间的关系。

### 13.4 多态公有继承 ###
同一个方法在派生类和基类中的行为是不同的，换句话说，方法的行为应取决于调用该方法的对象，这种较复杂的行为称为多态--具有多种形态，就是指同一个方法的行为将随上下文而异。有二种重要的机制可用于实现多态公有继承：
- 在派生类中重新定义基类的方法。
- 使用虚方法(推荐作法)。

对于虚方法，如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针指向的对象类型来选择方法。

经常在基类中将派生类会重新定义的方法声明为虚方法。方法在基类中被声明为虚拟的后，它在派生类中将自动成为虚方法。不过，在派生类声明中使用关键字virtual来指出哪些函数是虚函数也不失为一个好办法。（如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚拟的。这样，程序将根据对象类型而不是引用或指针类型来选择方法版本。关键字virtual只用于类声明的方法原型中，而没有用于实现中。）

派生类并不能直接访问基类的私有数据，而必须使用基类的公有方法才能访问这些数据。

非构造函数不能使用成员初始化列表句法，但派生类方法可以调用公有的基类方法。在派生类方法中，标准的技术是使用作用域解析操作符来调用基类方法，如BaseClass::func()。(同样包含隐式参数this)

使用delete释放由new分配的对象说明了为何基类应包含一个虚拟析构函数，虽然有时好像并不需要析构函数。如果析构函数不是虚拟的，则将只调用对应指针类型的析构函数。如果析构函数是虚拟的，将调用相应的对象类型的析构函数。因此，如果指针指向的是派生类对象，将调用派生类的析构函数，然后自动调用基类的析构函数。因此，使用虚拟析构函数可以确保正确的析构函数序列被调用。

### 13.4.2 静态联编和动态联编 ###
将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编。在C语言中，这非常简单，因为每一个函数名都对应一个不同的函数。在C++中，由于函数重载的缘故，这项任务更复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。然而，C/C++编译器可以在编译过程完成这种联编。在编译过程中进行联编被称为静态联编，又称为早期联编。不过，虚函数使这项工作变得更困难，使用哪一个函数是不能在编译时确定的，因为编译器不知道用户将选择哪种类型的对象。所以编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编，又称为晚期联编，编译器对非虚方法使用静态联编，对虚方法使用动态联编。

### 13.4.3指针和引用类型兼容性 ###
在C++中，动态联编与指针和引用调用的方法相关，从某种程度上说，这是由继承控制的，公有继承建立is-a关系的一种方法是如何处理指向对象的指针和引用。通常，C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型，不过指向基类的引用或指针可以引用派生类对象，而不必进行显式类型转换。将派生类引用或指针转换为基类引用或指针被称为向上强制转换，这使公有继承不需要进行显式类型转换。该规则是is-a关系的一部分。将基类指针或引用转换为派生类指针或引用--称为向下强制转换。如果不使用显式类型转换，则向下强制转换是不允许的。原因是is-a关系通常是不可逆的。派生类可以新增数据成员，因此使用这些数据成员的类函数不能应用于基类。


#### 动态联编和静态联编对比 ####

**效率**：为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销。

**概念模型**：在设计类时，可能包含一些不在派生类重新定义的成员函数。对于这些函数不设置为虚函数有二方面的好处：首先效率更高，基次指出不要重新定义该函数。这表明，仅将那些预期将被重新定义的方法声明为虚拟的。

**虚函数的工作原理**：C++规定了虚函数的行为，但将实现方法留给了编译器作者。通常，编译器处理虚函数的方法是，给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table,vtbl)。虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含了一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中，注意，无论类中包含的虚函数是1个还是10个，都只需要在对象中添加1个地址成员，只是表的大小不同而已。（虚函数表记录的函数并不记录参数特征标（非重载而是重写））

使用虚函数时，在内存和执行速度方面有一定的成本，包括：

- 每个对象都将增大，增大量为存储地址的空间。
- 每个类，编译器都创建一个虚函数地址表。
- 每个函数调用都需要执行一步额外的操作，即到表中查找地址。

### 13.4.5 有关虚函数注意事项 ###

虚函数要点：

- 在基类的声明中使用关键字virtual可使该方法在基类以及所有的派生类中是虚拟的。
- 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样的基类指针或引用可以指向派生类
- 如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚拟的。

对于虚方法，还需要了解其它的一些知识：

- 构造函数
>构造函数不能是虚函数，派生类不继承基类的构造函数，所以将类构造函数声明为虚拟的没有什么意义。


- 析构函数
>析构函数应当是虚函数，除非类不用做基类。如果析构函数是虚拟的，则当基类指针或引用使用的派生类被析构时，将先调用派生类构造函数，再自动调用基类的析构函数，如果不是虚拟的，将是直接调用基类的析构函数。顺便说一句，给类定义一个虚拟析构函数并非错误，即使这个类不用做基类；这只是一个效率方面的问题。通常应给基类一个虚拟析构函数，即使它并不需要析构函数。

- 友元
>友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。如果由于这个原因引起了设计问题，可以通过让友元函数使用虚拟成员函数来解决。

- 没有重新定义
>如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。

>虚拟函数重新定义不会生成函数的二个重载版本，而是隐藏了基类的所有同名虚函数版本。简而言之，重新定义继承的方法并不是重载。如果在派生类中重新定义函数，将不是使用相同的函数特征标基类声明，而隐藏同名的基类方法，不管参数特征标如何。因此引出了二条经验规则：
>
>1. 如果重新定义继承的虚方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。
> 
>2.如果基类声明被重载了，则应在派生类中重新定义所有基类版本。
>
```C++
class BaseClass
{
 public:
     //三个被重载的虚函数声明
     virtual void func(int);
     virtual void func(float);
     virtual void func(double);
}
class ClassName:public BaseClass
{
   public:
     //三个基类同名的虚函数都要重新定义，避免覆盖基类其它同名的虚函数 
     virtual void func(int);
     virtual void func(float);
     virtual void func(double);
}
```
### 13.5 访问控制：protected ###

关键字protected与private相似，在类外只能用公有类成员函数来访问protected部分中的类成员。private和protected之间的区别只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。而对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。（最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据）

**单设计模式**：希望有且只有一个类的实例返回给调用程序时，就可以使用单设计模式。
```C++
class TheOnlyInstance
{
    public:
        static TheOnlyInstance *GetTheOnlyInstance();
    protected:
        //无公有构造函数，可以防止实例被创建。只能通过公有静态方法来访问。
        TheOnlyInstance(){};
    private:
        //other data
}
TheOnlyInstance &TheOnlyInstance::GetTheOnlyInstance()
{
    //静态局部变量只在第一次执行时初始化，生命期为整个函数，作用域为定义到该函数结尾
    static TheOnlyInstance objTheOnlyInstance;
    return objTheOnlyInstance;
}
```

### 13.6 抽象基类　###
C++通过使用纯虚函数提供未实现的函数。纯虚函数声明的结尾处为=0。
```C++
class BaseClass
{
    private:
        double x,y;
    public:
        virtual ~BaseClass();
        //纯虚函数
        virtual void Move()const=0;   
}
```
当类声明中包含纯虚函数时，则不能创建该类的对象。这里的理念是，包含纯虚函数的类只能作基类。要成为真正的抽象基类(abstract base class,ABC),必须至少包含一个纯虚函数。原型中的=0使虚函数成为纯虚函数。总之，在原型中使用=0指出类是一个抽象基类，在类中可以不定义该函数。ABC描述的是至少使用一个纯虚函数的接口，从ABC派生出的类将根据派生类的具体特征，使用常规虚函数来实现这种接口。

设计ABC之前，首先应开发一个模型--指出编程问题所需的类以及它们之间相互关系。一种学院派思想认为，如果要设计类继承层次，则只能将那些不会被用作基类的类设计为具体的类。

**ABC要求具体派生类覆盖其纯虚函数--迫使派生类遵循ABC所设置的接口规则。这种模型在基于组件的编程模式中很常见，在这种情况下，使用ABC使组件设计人员能够制定“接口约定”，这样确保了从ABC派生的所有组件都至少支持ABC指定的功能。**


### 13.7 继承和动态内存分配 ###

当声明中的构造函数使用new操作符时，需要使用特殊方法：析构函数、复制构造函数和重载赋值操作符。

当派生类构造函数不使用new操作符或静态成员变量时：

- 如果没有定义析构函数，编译器将定义一个不执行任何操作的默认析构函数。实际上，派生类的默认构造函数总是要进行一些操作：执行自身的代码后调用基类析构函数。
- 成员复制将根据数据类型采用相应的复制方式，但复制类成员或继承的类组件时，则是使用该类的复制构造函数完成的。所以派生类的默认复制构造函数使用显示的基类复制构造函数来复制派生类对象的基类数据部分。
- 类的默认赋值操作符将自动使用基类的赋值操作符来对基类组件进行赋值。

当派生类构造函数使用new操作符或静态成员变量时，必须为派生类定义显式析构函数、复制构造函数和赋值操作符：

- 派生类析构函数自动调用基类的析构函数，因此其自身的职责是对派生类构造函数执行工作的进行清理。
- 派生类的复制构造函数只能访问派生类新增的成员，因此它必须调用基类的复制构造函数来处理共享的基类数据部分。

```C++
ClassName::ClassName(const ClassName &rs):BaseClass(rs)
{
     //todo
}
```
>成员初始化列表将一个派生类引用传递给基类构造函数。没有参数类型为派生类的引用的基类构造函数，也不需要这样的构造函数。因为复制构造函数派生类有一个以派生类为引用的参数，而基类引用可以指向派生类型。因此基类复制构造函数将使用参数为派生类的基类数据部分来构造新对象的基类部分。

- 由于派生类使用了动态内存分配，所以它也需要一个显式赋值操作符。作为派生类的方法，它只能直接访问派生类的数据。然而派生类的显式赋值操作符必须负责所有继承的派生类对象的赋值，可以通过显式调用基类赋值操作符来完成。
```C++
ClassName& ClassName::operator=(const ClassName &rs):BaseClass(rs)
{
     if(this == rs)
         return rs;
     //显式调用基类的赋值操作符 
     BaseClass::operator=(rs);
     //todo
}
```

总之，当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数以及赋值操作符都必须使用相应的基类方法来处理基类的元素。这种要求是通过三种不同的方式来满足的。对于析构函数，这是自动完成的；对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做将自动调用基类的默认构造函数。对于赋值操作符，这是通过使用作用域解析操作符显式地调用基类的赋值操作符来完成。

因为友元不是成员函数，所以不能使用作用域解析操作符来指出要使用哪个函数。这个问题解决方法是使用强制类型转换，以便匹配原型时能够选择正确的函数。
```C++
std::ostream & operator<<(std::ostream &os, const ClassName & hs)
{
    os<<(const BaseName &)hs;
	os<< hs.m_value;
    //todo;
    return hs;
}
```

### 13.8 类设计回顾 ###

- 默认构造函数 

默认构造函数要么没有参数，要么所有参数都有默认值，如果没有定义任何构造函数，编译器将定义默认构造函数，让您能够创建对象。自动生成的默认构造函数的另一个功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数。另外，如果派生类构造函数的成员初始化列表中没有显式地调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。如果定义了某种构造函数，编译器将不会定义默认构造函数。在这种情况下，如果需要默认构造函数，则必须自己提供。提供构造函数的动机之一是确保对象总能被正确地初始化。另外，如果类包含指针成员，则必须初始化这些成员。因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值。

- 复制构造函数

复制构造函数接受其所属类的对象作为参数。在以下情况，将使用复制构造函数：

1. 将新的对象初始化为一个同类对象。
2. 按值将对象传递给函数。
3. 函数按值返回对象。
4. 编译器生成临时对象。  //obj1 = obj2 + obj3 + obj4; 

如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。也就是说，新对象的每个成员都被初始化为原始对象相应的成员的值。

在某些情况下，成员初始化是不合适的。如：使用new初始化的成员指针通常要求执行深复制，或者类可能包含需要修改的静态变量。

- 赋值操作符

默认的赋值操作符用于处理同类对象之间的赋值。不要将赋值与初始化混淆了。如果语句创建新的对象，则使用复制构造函数；如果语句修改已有对象的值，则是赋值。编译器不会生成将一种赋值给另一种类型的赋值操作符。如果希望能够将一种对象赋值给另一个对象，则方法之一是显式定义相应的赋值操作符。

- 构造函数

构造函数不同于其他类方法，因为它创建新的对象，而其它类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。继承意味着派生类对象可以使用基类的方法，然而，构造函数在完成其工作之前，对象并不存在。

- 析构函数 

一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。

- 隐式转换和转换

**隐式转换**：使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。带一个参数的构造函数原型中使用explicit将禁止进行隐式转换，但仍允许显式转换。

**转换**：转换函数可以是没有参数的类成员，也可以是返回类型被声明为目标类型的为成员函数。即使没有声明返回类型，函数也应返回所需的转换值。

- 按值传递对象与传递引用

按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数。按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。

- 返回对象和返回引用

应返回引用而不是返回对象的原因在于，返回对象涉及到生成返回对象的临时拷贝，这是调用函数的程序可以使用的拷贝。因此返回对象的时间成本包括调用复制构造函数来生成拷贝所需的时间和调用析构函数删除拷贝所需的时间。返回引用可节省时间和内存。直接返回对象与按值传递对象相似：它们都生成临时拷贝。同样，返回引用与按引用传递对象相似：调用和被调用的函数对同一个对象进行操作。

- 使用const 

可用const来确保方法不修改参数（修饰参数），确保方法不修改调用它的对象（修饰方法代码块）。确保引用或指针返回的值不能用于修改对象的数据，使之成为左值。

如果函数将参数声明为指向const的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改。

#### 13.8.3 公有继承的考虑因素 ####

**is-a关系**：在某些情况下，最好的方法可能是创建包含纯虚函数的抽象数据类，并从它派生出其它类。

**为什么不能被继承**：构造函数是不能被继承的，也就是说，创建派生类对象时，必须调用派生类的构造函数。不过，派生类构造函数通常使用成员初始化列表句法来调用基类构造函数，以创建派生对象的基类部分。如果派生类构造函数没有使用成员初始化列表句法显式调用基类构造函数，将使用基类的默认构造函数。在继承链中，每个类都要可以使用初始化列表将信息传递回相近的基类。析构函数也是不能继承的。不过，在释放对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数。如果基类有默认析构函数，编译器将为派生类调用默认析构函数。通常，对于基类，其析构函数应设置为虚拟的。

**赋值操作符**：派生类继承的方法的特征标与基类完全相同，但赋值操作符的特征标随类而异，这是因为它包含一个类型为其所属类的的参数。如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值操作符。这个操作符的默认或隐式版本将采用成员赋值，即将原对象的相应成员赋给目标对象的每个成员。不过，如果对象属于基类，编译器将使用基类赋值操作符来处理派生对象中基类部分的赋值。如果显式地为基类提供赋值操作符，将使用该操作符。与此相似，如果成员是另一个类的对象，则对于该成员，将使用其所属类的赋值操作符。如果类构造函数使用new来初始化指针，则需要提供一个显式赋值操作符。

如果派生类包含了这样的构造函数，即对将基类对象转换为派生类对象进行了定义，则可以将基类对象赋给派生对象。如果派生类定义了用于将基类对象赋给派生对象的赋值操作符，则也可以这样做。如果上述二个条件都不满足，则不能这样做，除非使用显式强制类型转换。

**私有成员与保护成员**：对派生类而言，保护成员类似于公有成员；但对于外部而言，保护成员与私有成员类似。派生类可以直接访问基类的保护成员，但只能通过基类的成员函数来访问私有成员。因此，将基类成员设置为私有的可以提高安全性，而将它们设置为保护成员则可简化代码的编写工作，并提高访问速度。

**虚方法**：如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚拟的，这样可以启用晚期联编；如果不希望重新定义方法，则不必将其声明为虚拟的，这样虽然无法禁止他人重新定义方法，但表达了这样的意思。

**析构函数**：基类的析构函数应当是虚拟的，这样，当通过指向对象的基类指针或引用来删除派生对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数， 而不仅仅是调用基类的析构函数。

**友元函数**：通过强制类型转换将派生类型引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数。

**有关使用基类方法的说明**：

- 派生类默认使用继承而来的基类方法，如果派生类没有重新定义该方法。
- 派生类的析构函数自动调用基类的析构函数。
- 派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数。
- 派生类构造函数显式地调用成员初以化列表中指定的基类构造函数。
- 派生类方法可以使用作用域解析操作符来调用公有的和受保护的基类方法。
- 派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。

**new和delete是对象的静态成员函数**



派生类继承基类的数据成员和大部分方法，但不继承类的构造函数、析构函数和赋值操作符。派生类可以直接访问基类的公有成员和保护成员，并能够通过基类的公有方法和保护方法访问基类的私有成员。可以在派生类中新增数据成员和方法，还可以将派生类用作基类，来做进一步的开发。每个派生类都必须有自己的构造函数。程序创建派生类对象时，将首先调用基类的构造函数，然后调用派生类的构造函数；程序删除对象时，将首先调用派生类的析构函数，再调用基类的析构函数。

ABC：只定义接口，而不涉及实现，ABC必须至少包含一个纯虚方法，可以在声明中的分号前面加上=0来声明纯虚方法。不一定非得定义纯虚方法。对于包含纯虚成员的类，不能使用它来创建对象。纯虚方法用于定义派生类的通用接口。





