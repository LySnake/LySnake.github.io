---
title: C++ Primer Plus学习笔记(6)
comments: true
categories:
  - archives
  - technology
tags:
  - C++
  - cocos2d-x
description: 个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
date: 2017-07-05 21:59:27
update: {{ update }}
---
## 16 string类和标准模板库 ##

### 16.1 string类 ###
string实际上是模板规范basic_string<char>的一个tyepdef,同时省略了与内存管理相关的参数。

第一个限制因素是string对象的最大允许长度，由常量string::npos指定。这通常是最大的unsigned int值或最大的unsigned long值，因此对于普通的交互式输入，这不会带来实际的限制；但如果您试图将整个文件的内容读取到单个string对象中，这可能成为限制因素。第二个限制因素是程序可以使用的内存量。

string版本的getline()函数从输入中读取字符，并将其存储到目标string中，直到发生下列3种情况之一：
- 到达文件尾，在这种情况下，输入流的eofbit将会被设置，这意味着方法fail()和eof()都将返回true;.
- 遇到分界字符(默认为\n)，在这种情况下，将把分界字符从输入流中删除，但不存储它。
- 读取的字符数达到最大允许值(string::npos和可供分配的内存字节数中较小的一个)，在这种情况下，将设置输入流failbit，这意味着方法fail()将返回true.

输入流对象有一个统计系统，用于跟踪流的错误状态，在这个系统中，检测到文件尾后将设置eofbit寄存器，检测到输入错误时将设置failbit寄存器，一切顺利时将设置goodbit寄存器。

string版本的operator>>()函数的行为与此类似，只是它不断读取，直到遇到空白字符并将其解放思想在输入队列中，而不是不断读取，直到遇到分界字符并将其丢弃。空白字符指的是空格、换行符和制表符，更普遍地说，是任何将其作为参数来调用isspace()时，该函数返回ture的字符。

string库还提供了：删除字符串的部分或分部内容、用一个字符串的部分或全部内容替换另一个字符串的部分或全部内容、 将数据插入到字符串中或删除字符串中的数据、将一个字符串的部分或全部内容与另一个字符串的部分或全部内容进行比较、从字符串中提取子字符串、将一个字符串中的内容复制到另一个字符串中、交换二个字符串的内容。

很多C++实现分配一个比实际字符串大的内存块，为字符串提供了增大空间。然而，如果字符串不断增大，超过了内存块的大小，程序将分配一个大小为原来二倍的新内存块，以提供足够的增大空间，避免不断地分配新的内存块。


### 16.2 auto_ptr类 ###

auto_ptr是一个模板类，用于管理动态内存分配的用法。

对于基本类型，并没有提供这种额外服务；但对于类，则可以通过析构函数机制来提供。因此，普通指针的问题在于：它只是一个常规指针，不是类对象。如果它是类是对象，则可以在对象过期时，让它的析构函数删除被指向的内存。这正是auto_ptr背后的思想。

auto_ptr模板定义了类似指针的对象，可以将new获得(直接或间接)的地址赋给这种对象。当auto_ptr对象过期时，其析构函数将使用delete来释放内存。 因此，如果将new返回的地址赋给auto_ptr对象时，无须记住稍后释放这些内存。在auto_ptr对象过期时，这些内在将自动被释放。

auto_ptr是一种智能指针(smart pointer)---类似于指针，但特性比指针更多。auto_ptr类被定义为在很多方面与常规指针类似。例如，如果ps是一个auto_ptr，则可以对它执行解除引用操作(*ps)和递增操作(++ps)，用它来访问结构成员(ps->puffIndex)，将它赋给指向相同类型的常规指针。

对于new和new[]，必须相应地使用delete和delete[]。auto_ptr模板使用的是delete，而不是delete[]，因此它只能与new一起使用，而不能与new[]一起使用。没有适用于动态数组的auto_ptr等同物。可以复制头文件memory中的auto_ptr模板，将它重命名为auto_arr_ptr，然后对基进行修改，使之使用delete[]，而不是delete。

只以有对new分配的内存使用auto_ptr对象，而不要对由new[]分配的或通过声明变量分配的内存使用它。

智能指针是这样一种类，即其对象的特征类似于指针。例如，智能指针可以存储new分配的内在地址，也可以被解除引用。因为智能指针是一个类对象，因此它可以修改和扩充简单指针的行为。例如，智能指针可以建立引用计数，这样多个对象可共由智能指针跟踪的同一个值。当使用该值的对象数为0时，智能指针将删除这个值。智能指针可以提高内在的使用效率，帮助防止内存泄漏，但并不要求用户熟悉新的编程技术。

### 16.3 STL ###
STL提供了一组表示容器、迭代器、函数对象和算法的模板。容器是一个与数组类似的单元，可以存储若干个值。STL容器是同质的，即存储的值的类型相同；算法是完成特定任务(如对数组进行排序或在链表中查找特定值)的处方；迭代器能够用来遍历容易的对象，与能够遍历数组的指针类似，是广义的指针；函数对象是类似于函数的对象，可以是类对象或函数指针(包括函数名，因为函数名被用作指针)。STL使得能够构造各种容器(包括数组、队列、链表)和执行各种操作(包括搜索、排序和随机排列)。

STL不是面向对象的编程，而是一种不同的编程模式---通用编程技术。

**矢量(vector)**：对应数组，而不是数学矢量，计算矢量存储了一组可随机访问的值，即可以使用索引来直接访问适量的第10个元素，而不必首先访问前面第9个元素。将一个vector对象赋给另一个对象，使用[]操作符来访问vector元素。要使类成为通过的，应将它设计为模板类。这正是STL所做的工作---在头文件vector中定义了一个模板。

**分配器**：各种 STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存。如果活该模板参数的值，则容器模板将默认使用allocator<T>类。这个类以标准方式使用new和delete。

所有的STL容器都提供了一些基本方法，其中包括size()---返回容器中元素数目、swap()---交换二个窗口的内容、begin()---返回一个指向容器中第一个元素的迭代器，end()---返回一个表示超过容器尾的迭代器。

**迭代器**：是一个广义的指针，事实上，它可以是指针，也可以是一个可对其执行类似指针的操作---如解引用、和递增操作的对象。稍后将知道，对指向迭代器的指针进行广义化使得STL能够为各种不同的窗口类(包括那些简单指针无法处理的类)提供统一的接口。每个窗口类都定义了一个合适的迭代器，该迭代器的类开是一个名为iterator的typedef，其作用域为整个类(模板中嵌套类定义iterator)。

**超过结尾(past-the-end)**：它是一种迭代器，指向容器最后一个元素后面的那个元素。这与C-风格字符串最后一个字符后面的空字符类似，只是空字符是一个值，而“超过结尾”是一个指向元素的指针（迭代器）。end()成员函数标识超过结尾的位置。如果将迭代器设置为窗口的第一个元素，并不断地递增，则最终它将到达窗口结尾，从而遍历整个容器的内容。

push_back()是一个方便的方法，它将元素添加到矢量的末尾。erase()方法删除适量中给定区间的元素。insert()方法的功能与erase()相反。它接受3个迭代器参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，该区间通常是另一个窗口对象的一部分。

STL从更广泛的角度定义了非成员函数来执行这些操作，即不是为每个容器类定义find()函数，而是定义一个适用于所有容器类的非成员函数find()。这种设计理念省去了大量重复工作。for_each()函数可用于许多窗口类，它接受3个参数。前二个是定义窗口中敬意的迭代器，最后一个是指向函数的指针（更普遍地说，最后一个参数是一个函数对象）。for_each()函数将被指向的函数应用于容器敬意中的各个元素。被指向的函数不能修改窗口元素的值。


### 16.4 通用编程技术 ###

STL是一种通用编程技术，面向对象编程关注的是编程的数据方面，而通用编程技术关注的是算法。它们之间的共同点是抽象和创建可重用代码，但它们的理念绝然不同。在C++中，完成通用程序的工具是模板。当然，模板使得能够按通用类型定义函数或类，而STL通过通用算法更进一步。

模板使得算法独立于存储的数据类型，而迭代器使得算法独立于使用的容器类型。因此，它们都是STL通用方法的重要组成部分。

