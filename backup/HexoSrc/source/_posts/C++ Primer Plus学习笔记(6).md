---
title: C++ Primer Plus学习笔记(6)
comments: true
categories:
  - archives
  - technology
tags:
  - C++
  - cocos2d-x
description: 个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
date: 2017-07-05 21:59:27
update: {{ update }}
---
## 16 string类和标准模板库 ##

### 16.1 string类 ###
string实际上是模板规范basic_string<char>的一个tyepdef,同时省略了与内存管理相关的参数。

第一个限制因素是string对象的最大允许长度，由常量string::npos指定。这通常是最大的unsigned int值或最大的unsigned long值，因此对于普通的交互式输入，这不会带来实际的限制；但如果您试图将整个文件的内容读取到单个string对象中，这可能成为限制因素。第二个限制因素是程序可以使用的内存量。

string版本的getline()函数从输入中读取字符，并将其存储到目标string中，直到发生下列3种情况之一：
- 到达文件尾，在这种情况下，输入流的eofbit将会被设置，这意味着方法fail()和eof()都将返回true;.
- 遇到分界字符(默认为\n)，在这种情况下，将把分界字符从输入流中删除，但不存储它。
- 读取的字符数达到最大允许值(string::npos和可供分配的内存字节数中较小的一个)，在这种情况下，将设置输入流failbit，这意味着方法fail()将返回true.

输入流对象有一个统计系统，用于跟踪流的错误状态，在这个系统中，检测到文件尾后将设置eofbit寄存器，检测到输入错误时将设置failbit寄存器，一切顺利时将设置goodbit寄存器。

string版本的operator>>()函数的行为与此类似，只是它不断读取，直到遇到空白字符并将其留在输入队列中，而不是不断读取，直到遇到分界字符并将其丢弃。空白字符指的是空格、换行符和制表符，更普遍地说，是任何将其作为参数来调用isspace()时，该函数返回ture的字符。

string库还提供了：删除字符串的部分或分部内容、用一个字符串的部分或全部内容替换另一个字符串的部分或全部内容、 将数据插入到字符串中或删除字符串中的数据、将一个字符串的部分或全部内容与另一个字符串的部分或全部内容进行比较、从字符串中提取子字符串、将一个字符串中的内容复制到另一个字符串中、交换二个字符串的内容。

很多C++ std::string类的实现分配一个比实际字符串大的内存块，为字符串提供了增大空间。然而，如果字符串不断增大，超过了内存块的大小，程序将分配一个大小为原来二倍的新内存块，以提供足够的增大空间，避免不断地分配新的内存块。


### 16.2 auto_ptr类 ###

auto_ptr是一个模板类，用于管理动态内存分配的用法。

对于基本类型，并没有提供这种额外服务；但对于类，则可以通过析构函数机制来提供。因此，普通指针的问题在于：它只是一个常规指针，不是类对象。如果它是类是对象，则可以在对象过期时，让它的析构函数删除被指向的内存。这正是auto_ptr背后的思想。

auto_ptr模板定义了类似指针的对象，可以将new获得(直接或间接)的地址赋给这种对象。当auto_ptr对象过期时，其析构函数将使用delete来释放内存。 因此，如果将new返回的地址赋给auto_ptr对象时，无须记住稍后释放这些内存。在auto_ptr对象过期时，这些内在将自动被释放。

auto_ptr是一种智能指针(smart pointer)---类似于指针，但特性比指针更多。auto_ptr类被定义为在很多方面与常规指针类似。例如，如果ps是一个auto_ptr，则可以对它执行解除引用操作(*ps)和递增操作(++ps)，用它来访问结构成员(ps->puffIndex)，将它赋给指向相同类型的常规指针。

对于new和new[]，必须相应地使用delete和delete[]。auto_ptr模板使用的是delete，而不是delete[]，因此它只能与new一起使用，而不能与new[]一起使用。没有适用于动态数组的auto_ptr等同物。可以复制头文件memory中的auto_ptr模板，将它重命名为auto_arr_ptr，然后对基进行修改，使之使用delete[]，而不是delete。

只以有对new分配的内存使用auto_ptr对象，而不要对由new[]分配的或通过声明变量分配的内存使用它。

智能指针是这样一种类，即其对象的特征类似于指针。例如，智能指针可以存储new分配的内存地址，也可以被解除引用。因为智能指针是一个类对象，因此它可以修改和扩充简单指针的行为。例如，智能指针可以建立引用计数，这样多个对象可共由智能指针跟踪的同一个值。当使用该值的对象数为0时，智能指针将删除这个值。智能指针可以提高内存的使用效率，帮助防止内存泄漏，但并不要求用户熟悉新的编程技术。

### 16.3 STL ###
STL提供了一组表示容器、迭代器、函数对象和算法的模板。容器是一个与数组类似的单元，可以存储若干个值。STL容器是同质的，即存储的值的类型相同；算法是完成特定任务(如对数组进行排序或在链表中查找特定值)的处方；迭代器能够用来遍历容器中的对象，与能够遍历数组的指针类似，是广义的指针；函数对象是类似于函数的对象，可以是类对象或函数指针(包括函数名，因为函数名被用作指针)。STL使得能够构造各种容器(包括数组、队列、链表)和执行各种操作(包括搜索、排序和随机排列)。

STL不是面向对象的编程，而是一种不同的编程模式---通用编程技术。

**矢量(vector)**：对应数组，但不是数学矢量，计算矢量存储了一组可随机访问的值，即可以使用索引来直接访问矢量的第10个元素，而不必首先访问前面第9个元素。将一个vector对象赋给另一个对象，使用[]操作符来访问vector元素。要使类成为通用的，应将它设计为模板类。这正是STL所做的工作---在头文件vector中定义了一个模板。

**分配器**：各种 STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存。如果未使用该模板参数的值，则容器模板将默认使用allocator<T>类。这个类以标准方式使用new和delete。

所有的STL容器都提供了一些基本方法，其中包括size()---返回容器中元素数目、swap()---交换二个容器的内容、begin()---返回一个指向容器中第一个元素的迭代器，end()---返回一个表示超过容器尾的迭代器。

**迭代器**：是一个广义的指针，事实上，它可以是指针，也可以是一个可对其执行类似指针的操作---如解引用、和递增操作的对象。稍后将知道，对指向迭代器的指针进行广义化使得STL能够为各种不同的容器类(包括那些简单指针无法处理的类)提供统一的接口。每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为iterator的typedef，其作用域为整个类(模板中嵌套类定义iterator)。

**超过结尾(past-the-end)**：它是一种迭代器，指向容器最后一个元素后面的那个元素。这与C-风格字符串最后一个字符后面的空字符类似，只是空字符是一个值，而“超过结尾”是一个指向元素的指针（迭代器）。end()成员函数标识超过结尾的位置。如果将迭代器设置为容器的第一个元素，并不断地递增，则最终它将到达容器结尾，从而遍历整个容器的内容。

push_back()是一个方便的方法，它将元素添加到矢量的末尾。erase()方法删除矢量中给定区间的元素。insert()方法的功能与erase()相反。它接受3个迭代器参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，该区间通常是另一个容器对象的一部分。

**算法**：STL从更广泛的角度定义了非成员函数来执行这些操作，即不是为每个容器类定义find()函数，而是定义一个适用于所有容器类的非成员函数find()。这种设计理念省去了大量重复工作。如for_each()函数可用于许多容器类，它接受3个参数。前二个是定义容器中区间的迭代器，最后一个是指向函数的指针（更普遍地说，最后一个参数是一个函数对象）。for_each()函数将被指向的函数应用于容器区间中的各个元素。被指向的函数不能修改容器元素的值。


### 16.4 通用编程技术 ###

STL是一种通用编程技术，面向对象编程关注的是编程的数据方面，而通用编程技术关注的是算法。它们之间的共同点是抽象和创建可重用代码，但它们的理念绝然不同。在C++中，完成通用程序的工具是模板。当然，模板使得能够按通用类型定义函数或类，而STL通过通用算法更进一步。

模板使得算法独立于存储的数据类型，而迭代器使得算法独立于使用的容器类型。因此，它们都是STL通用方法的重要组成部分。

即函数不仅独立于容器中存储的数据类型，而且独立于容器本身的数据结构。模板提供了存储在容器中数据类型的通用表示，因此还需要遍历容器中的值的通用表示，迭代器正是这样的通用表示。

**为区分++操作符的前缀版本和后缀版本，C++将operator++()作为前缀版本，将operator++(int)作为后缀版本；其中的参数永远也不会被使用到，所以不必指定其名称。**

首先，每个容器类(vector、list、deque等)定义了相应的迭代器类型。对于其中的某个类，迭代器可能是指针；而对于另一个类，则可能是对象。不管实现方式如何，迭代器都将提供扬需的操作，如*和++。其次，每个容器类都有一个超尾标记，它们分别返回一个指向超越容器的最后一个值后，这个值将被赋给迭代器，每个容器类都有一个超尾标记，它们分别返回一个指向容器的第一个元素和超尾位置的迭代器。每个容器类都使用++操作，让迭代器从指向第一个元素逐步指向超尾位置，从而遍历容器中每一个元素。

STL通过为每个类定义适当的迭代器，并以统一的风格设计类，能够对内部表示绝然不同的容器，编写相同的代码。

STL定义了5种迭代器，并根据所需的迭代器类型对算法进行了描述。这5种迭代器分别是输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机迭代器。

**输入迭代器**：术语“输入”是从程序的角度说的，即来自容器的信息被视为输入，就像来自键盘的信息对程序来说是输入一样。因此，输入迭代器可被程序用来读取容器中的信息。

**输入迭代器**：STL使用术语“输出”来指向于将信息从程序传输给容器的迭代器，因此程序的输出就是容器的输入。输出迭代器与输入迭代器相似，只是解除引用让程序能修改容器值，而不能读取。简而言之，对于单通告、 只读算法，可以使用输入迭代器；而对于单通行、只写算法，则可以使用输出迭代器。

**正向迭代器**：与输入迭代器和输出迭代器相似，正向迭代器只使用++操作符来遍历容器，所以它每次沿容器向前移动一个元素；不过，与输入和输出迭代器不同的是，它总是按相同的顺序遍历一系列值。另外，将正向迭代器递增后，仍然可以对前面的迭代器值解除引用，并可以得到相同的值。

**双向迭代器**：假设算法需要能够双向遍历容器，情况将如何呢？例如，reveerse函数可以交换第一个元素和最后一个元素，将指向第一个元素的指针加1、将指向第二个元素的指针减1，并重复这种处理过程。双向迭代器具有正向迭代器的所有特性，同时支持两种(前缀和后缀)递增操作符。

**随机访问迭代器**：随机访问迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针增加运算）和用于对元素进行排序的关系操作符。

为何需要这么多迭代器呢？目的是为了在编写算法时尽可能使用要求最低的迭代器，并让它适用于容器的最大区间。这样，通过使用级别最低的输入迭代器，find()函数便可用于任何包含可读取值的容器。而sort()函数由于需要随机访问迭代器，所以只能用于支持这种迭代器的容器。

迭代器是广义的，而满足所有迭代器要求。迭代器是STL算法的接口，而指针是迭代器，因此STL算法可以使用指针来对基于指针的非STL容器进行操作。

### 16.4.5 容器各类 ###
STL具有容器概念和容器类型。概念是具有名称（如容器、序列容器、联合容器等）的通用类别 ；容器类型是可用于创建具体容器对象的模板。11个容器类型分别是deque、list、queue、priority_queue、stack、vector、map、multimap、set、multiset、和bitst。

####　容器概念 ####
没有与基本容器概念对应的类型，但概念描述了所有容器类通用的元素。它是一个概念化的抽象基类---说它概念化，是因为容器类并不真正使用继承机制。换句话说，容器概念指定了所有STL容器类都必须满足的一系列要求。

容器是存储其它对象。被存储的对象必须是同一种类型的，它们可以是OOP意义上的对象，也可以是内置类型值。被存储在容器中的数据为容器所有，这意味着当容器过期时，存储在容器中的数据也将过期（不过，如果数据是指针的话，则它指向的数据并不一定过期）。

不有将任何类型的对象存储在容器中，具体地说，类型必须是可复制构造的和可赋值的。基本类型满足这些要求；只要类定义没有将复制构造函数和同仁操作符声明为私有或保护的，则类也满足这种要求。

#### 序列 ####
可以通过添加要求来改进基本的容器的概念。序列是一种重要的改进，因为6种STL容器类型（deque、list、queue、priority_queue、stack和vector）都是序列（队列能够在队尾添加元素，在队首删除元素。Deque表示的双端队列允许在两端添加和删除元素）。序列概念增加了迭代器至少是正向迭代器这样的要求。这保证了元素将按特定的顺序排列，不会在二次迭代之间发生变化。

序列还要求其元素按严格的线性顺序排列，即存在第一个元素、最后一个元素，除第一个元素和最后一个元素外，每个元素前后都分别有一个元素。

- vector
- 
简单地说，vector是数组的一种表示，它提供了自动内在管理功能，可以动态地改变vector对象的长度，并随着元素的添加和删除而增大和缩小。它提供了对元素的随机访问。在尾部添加和删除元素的时间是固定的，但在头部或中间插入和删除元素的复杂度为线性时间。

vector还是可反转容器概念的模型。这增加了二个类方法：rbegin()和rend()，前者返回一个指向反转序列的第一个元素的迭代器，后者返回反转序列的超尾迭代器。vector模板类是最简单的序列类型，除非其他类型的特殊优点能够更好地满足程序的要求，否则应默认使用这种类型。

- deque

deque模板类表示双端队列，通常被简称为deque。在STL中，其实现类似于vector容器，支持随机访问。主要区别在于，从deque对象的开始位置插入和删除的时间是固定的，而不像vector中那样的纯属时间的。所以，如果多数操作发生在序列的超始和结尾处， 则应考虑使用deque数据结构。

- list

list模板类表示双向链表。除了第一个和最后一个元素外，每个元素都与前后的元素相链接，这意味着可以双向遍历链表。list和vector之间的关键区别在于，list在娶个中任一位置进行插入和删除的时间都是固定的(vector模板提供了除结尾处外的线性时间的插入和删除，在结尾处，它提供了固定时间的插入和删除）。因此，vector强调的是通过随机访问进行快速访问，而list强调的是元素的快速插入和删除。

- queue 

queue模板类是一个甜酸器类。由前所述，ostream_iterator模板类就是一个适配器，让输出流能够使用迭代器接口。同样，queue模板让底层类展示典型的队列接口。

#### 16.4.6 联合容器 ####

联合容器是对容器概念的另一个改进。联合容器将值与关键字关联在一起，使用关键字来查找值。

联合容器的长处在于，它提供了对元素的快速访问。与序列相似，联合容器也允许插入新元素，不过不能指定元素的插入位置。原因是联合容器通常包含于确定数据旋转位置的算法，以便能够很快检索信息。

STL提供4种联合容器：set、multiset、map和multimap。前两种是在set头文件中定义的，后两种是在map头文件中定义的。

最简单的簇是set，其值的类型与关键字相同，关键字是惟一的---集合中不会有多个相同的关键字。确实，对于set来说，值就是关键字。multiset类型类似于set,只是前者可能有多个值的关键字相同。

对于map类型来说，值的类型与关键字不同，关键字是惟一的，每个关键字只对应一个值。multimap类型与map相似，只是一个关键字可以与多个值关联。


- set范例

STL set是多个櫂的模型，它是一个联合集合，可反转，可排序，关键字是惟一的，所以它只能存储同一种类型的值。与vector和list相似，set也使用模板参数来提供要存储的值的类型。数学为集合定义了一些标准操作，例如，并集包含二个集合合并后的内容。如果二个集合中包含相同的值，则这个值将在并集中只出现一次，这是因为关键字是惟一的。次包含二个集合公有的元素。二个集合的差是第一个集合减去二个集合公有元素。

- multmap范例

与set相似，multimap也是可反转的，经过排序的联合容器，但在multimap中，关键字的类型与值类型不同，在multimap对象中，特定的关键字可能与多个值相关联。基本的multimap声明使用模板参数指定了关键字的类型和扬存储的值的类型。如：
```C+++
multmap<int,string> codes;
```
### 16.5 函数对象 ###
很多STL算法都使用函数对象---也叫函数符。函数符是可以以函数方式与()结合使用的任意对象。这包括函数名、指向函数的指针和重载了()操作符的类对象(即定义了函数operator()()的类)。

对于STL中的算法```for_each(templateObj.begin(), templateObj.end(), ShowReview);```，通常算3个参数可以是常规函数，也可以是函数符。实际上，这提出了一个问题：如何声明第3个参数呢？不能把它声明为函数指针，因为函数指针指定了参数类型。由于容器可以包含任意类型，所以预先是无法知道应使用哪种参数类型的。STL通过使用模板解决了这个问题。for_each的原型看上去就像这样：

```C++
template<class InputIterator, class Function>
Function for_each(InputIterator first, InputItertor last, Function f);

void ShowReview(const Review&);
```
这样，标识符ShowReview的类型为void(*)(const Review &),这也是赋给模板参数Function的类型，对于不同的函数调用，Function参数可以表示具有重载的()操作符的类类型。

#### 16.5.1 函数符的概念 ####

** 函数符的概念 **：

- 生成器是不用参数就可以调用的函数符。
- 一元函数是用一个参数可以调用的函数符。
- 二元函数是用二个参数可以调用的函数符。

改进版：

- 返回bool值的一元函数是断言。
- 返回bool值的二元函数是二元断言。

#### 16.5.2 预定义的函数符 ####
STL定义了多个基本函数符，它们执行诸多如将两个值相加、比较两个值是否相等操作。提供这些函数对象是为了支持将函数作为参数的STL函数。对于所有内置的自述操作符、关系操作符和逻辑操作符，STL都提供了等价的函数符。

#### 16.5.3 自适应函数和函数适配器 ####
自适应生成器、自适应一元函数、自适应二元函数、自适应断言和自适应二元断言，如下表列出的预定义函数都是自适应的。

|:----|:----:|:----|:----:|
|+|plus|>|greater|
|-|minus|<|less|
|*|multiplies|>=|greater_equal|
|/|divides|<=|less_equal|
|%|modulus|&&|logical_and|
|-|negate|"||"|logical_or|
|==|equal_to|!|logical_not|
|!=|not_equal_to|

使用函数符成为自适应的原因是，它携带了标识参数类型和返回值类型的typedef成员。这些成员分别是result_type、first_argument_type和second_argument_type，它们的作用是不言自明的。函数符自适应性的意义在于：函数适配器对象可以使用函数对象，并认为存在这些typedef成员。


#### 16.6 算法 ####
STL包含了很多处理容器的非成员函数，前面已经介绍过其中的一些：sort()、copy()、find()、random_shuffle()、set_union()、set_intersection()、set_difference()和transform()。可能已经注意到，它们的总体设计是相同的，都使用迭代器来标识要处理的数据敬意和结果的放置位置。有些函数还接受一个函数对象参数，并使用它来处理数据。

对于算法函数设计，有二个主要的通用部分。首先，它们都使用模板来提供通用类型；其次，它们都使用迭代器来提供访问容器中数据的通用表示。因此，copy()函数可用于将double值存储在数组中的容器、将string值存储在链表中容器，也可用于将用户定义的对象存储在树结构中的窗口。因为指针是一种特殊的迭代器，因此诸多copy()等STL函数可用于常规数组。

