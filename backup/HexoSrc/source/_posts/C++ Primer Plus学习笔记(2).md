---
title: C++ Primer Plus学习笔记(2)
comments: true
categories:
  - archives
  - technology
tags:
  - C++
description: 个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
date: {{ date }}
update: {{ update }}
---

### 11.使用类 ###

**操作符重载**是一种形式的C++多态，操作符重载将重载的概念扩展到操作符上，允许赋予C++操作符多种含义。要重载操作符，需使用被称为操作符函数的特殊函数形式。操作符函数的格式如下：

```C++
operator op(argument-list)

//可以像使用成员方法一样使用操作符重载
total = coding.operator+(fixing);
//以可以使用操作符表示法：
total = coding + fixing;

注意，在操作符表示法中，操作符左侧的对象（这里为coding）是调用对象，操作符右边（这里是fixing)是作为参数被传递的对象。
```

其中，op是将要重载的操作符。例如，operator +()重载+操作符，operator *()重载*操作符。op必须是有效的C++操作符，不能虚构一个新的符号。

#### 11.2.2操作符重载的限制 ####

- 重载后的操作符必须至少有一个操作数是用户定义，这将防止用户为标准类型重载操作符。因此不能将减法操作符重载为计算两个double值的和，而不是它们的差。
- 使用操作符时不能违反操作符原来的句法规则。例如，不能将求模操作符(%)重载成使用一个操作数（ --> %x;），同样也不能修改操作符的优先级。因此，如果将加号操作符重载成将两个类相加，则新的操作符与原来的加号具有相同的优先级。
- 不能定义新的操作符。
- 不能重载下面的操作符
>- sizeof----sizeof操作符。
>- .----成员操作符。
>- .*----成员指针操作符。
>- ::----作用域解析操作符。
>- ?:----条件操作符。
>- typeid----一个RTTI操作符。
>- const_cast----强制类型转换操作符。
>- dynamic_cast----强制类型转换操作符。
>- reinterpret_cast----强制类型转换操作符。
>- static_cast----强制类型转换操作符。
- 大多操作符都可以通过成员或非成员函数进行重载，但下面的操作符只能通过成员函数进行重载：
>- =----赋值操作符。
>- ()----函数调用操作符。
>- []----下标操作符。
>- ->----通过指针访问的类成员的操作符。

#### 11.3友元简介 ####
友元有3钟：

- 友元函数。
- 友元类。
- 友元成员函数。

通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显示参数(非this传入)。对于非成员重载操作符函数来说，操作符表达式左边的操作数对应于操作符函数的第一个参数，操作符表达式右边的操作数对应于操作符函数的第二个参数。

创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend：

friend TypeName operator* (double m, const className &T);

- 显然operator*()函数是在类声明中声明的，但它不是成员函数，因此不能使用成员操作符来调用。
- 虽然operator*()函数不是成员函数，但它与函数的访问权限相同。

第二步是编写函数定义。因为它不是成员函数，所以不要使用className::限定符。加外不要在定义中使用关键字friend。简而言之，友元函数是非成员函数，其访问权限与成员函数相同。

ostream类对该操作符进行了重载，将其转换为一个输出工具，前面讲过，cout是一个ostream对象，它是智能的。能够识别所有的C++基本类型。这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的operator<<()定义。

```c++
//实现链式调用
ostream & operator<<(ostream &os, const className &t)
{
	os<< t.intValue << t.floatValue << t.stringValue ;
	return os;
}
```

非成员版本的重载操作符函数所需的形参数目与操作符使用的操作数数目相同dmj成员版本所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象(this)。


#### 11.6类的自动转换和强制类型转换 ####
**只能是基本类型到类类型的隐式转换？**

C++的目标之一就是把类实现为与基本类型一致，所以也存在隐式转换问题。

对于类ClassName，如果存在一个参数的构造函数，那么：

```C++
ClassName classValue ;  // 存在ClassName::ClassName(TypeName)构造函数
classValue = TypeNameValue;  //相当于==>classValue = ClassName::ClassName(TypeNameValue);通过构造函数以参数构造了一个对象。形成隐式转换。 
```
最新的C++实现新增了一个关键字(explicit)，用来关闭这种自动特性。也就是说，可以这样声明构造函数：
```C++
explicit ClassName(TypeName value);          //告知编译器禁止使用隐式转换，但仍然允许显式转换，即显式强制类型转换
ClassNameValue = ClassName(TypeNameValue);   //强制类型转换
```

只接受一个参数的构造函数定义了从参数到类类型的转换。如果使用关键字explicit限定了这种构造函数，则它它只能用于显示转换，否则也可以用于隐式转换。

当没有使用explicit限定只能用于强制转换，则在以下情况发生隐式转换：

- 将ClassName对象初始化为TypeName值时。    //ClassNameValue = ClassName(TypeNameValue);
- 将TypeName值赋给ClassName对象时。       //classValue = TypeNameValue;
- 将TypeName值传递给接受ClassName参数的函数时。   
- 返回值被声明为ClassName类型的函数试图返回一个TypeName类型值时。

函数原型化提供的参数匹配过程，允许使用ClassName(TypeName)构造函数来转换其他数值类型。比如TypeName是float类型，当把int类型当做实参时，int先转换为float，再转换成TypeName给形参.


#### 11.6.2转换函数 ####
构造函数只用于从某种类型到类类型的转换。要进行相反的转换必须使用特殊的C++操作符---转换函数。

```C++
operator typeName();
```
- 转换函数必须是类方法。
- 转换函数不能指定返回类型。(typeName已经指定类型，无需过多注明)
- 转换函数不能有参数。(类的对象即是参数对象)

typeName(这里为double）指出了要转换成的类型，因此不需要指定返回类型。转换函数是类方法意味着：它需要通过类对象来调用，从而告知函数要转换的值。因此，函数不 需要参数。虽然没有返回类型，这二个函数也将返回所需的值。

提供执行自动、隐式转换的函数所存在的问题是：在用户希望转换时，转换函数也可能进行转换。原则来说，最好使用显示转换，而避免隐式转换。关键字explicit不能用于转换函数，但只需用一个功能相同的非转换函数替换访转换函数即可，但仅在补显式地调用时，该函数才会执行。

```C++
ClassName::operator int(){};
//改写为
ClassName::ClassName2int(){};
```

C++提供了下面的类型转换：

- 只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。例如，将int值赋给ClassName对象时，接受int参数的ClassName类构造函数将自动被调用。不过，在构造函数声明中使用explicit可防止隐式转换，而只允许显式转换。
- 被称为转换函数的特殊类成员操作符函数，用于将类对象转换为其他类型。转换函数是类成员，没有返回类型、没有参数类型、名为operator typeName()，其中，typeName是对象将被转换成的类型。将类对象赋给typeName变量或将諆强制转换为typeName类型时，该转换函数将自动被调用。

全局对象，因为全局对象将在程序的main()函数被调用之前创建。程序员可以创建一个类，其默认构造函数将调用所有的bootstrap函数。实现在main()函数调用之前，执行全局类对象的构造函数来初始化一些数据。

C++允许指定在基本类型之间进行转换的方式。首先，任何接受唯一一个参数的构造函数都可被用作转换函数，将类型与该参数相同的值转换为类。如果将类型与该参数相同的值赋给对象，则C++将自动调用访构造函数。要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换。转换函数必须是成员函数。将类对象转换为TypeName类型的转换函数的原型如下：
```C++
//注意，转换函数没有返回类型、没有参数，但必须返回转换后的值（虽然没有声明返回类型）
operator typeName();

```








