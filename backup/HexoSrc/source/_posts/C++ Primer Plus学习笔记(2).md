---
title: C++ Primer Plus学习笔记(2)
comments: true
categories:
  - archives
  - technology
tags:
  - C++
  - C++ Primer Plus
description: 个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
date: {{ date }}
update: {{ update }}
---

## 11.使用类 ##

**操作符重载**是一种形式的C++多态，操作符重载将重载的概念扩展到操作符上，允许赋予C++操作符多种含义。要重载操作符，需使用被称为操作符函数的特殊函数形式。操作符函数的格式如下：

```C++
ClassName total, coding, fixing;
//可以像使用成员方法一样使用操作符重载
total = coding.operator+(fixing);
//以可以使用操作符表示法：
total = coding + fixing;

//注意，在操作符表示法中，操作符左侧的对象（这里为coding）是调用对象，操作符右边（这里是fixing)是作为参数被传递的对象。
```

其中，op是将要重载的操作符。例如，operator +()重载+操作符，operator -()重载-操作符。op必须是有效的C++操作符，不能虚构一个新的符号。

### 11.2.2操作符重载的限制 ###

- 重载后的操作符必须至少有一个操作数是用户定义，这将防止用户为标准类型重载操作符。因此不能将减法操作符重载为计算两个double值的和，而不是它们的差。
- 使用操作符时不能违反操作符原来的句法规则。例如，不能将求模操作符(%)重载成使用一个操作数(%x;），同样也不能修改操作符的优先级。因此，如果将加号操作符重载成将两个类相加，则新的操作符与原来的加号具有相同的优先级。
- 不能定义新的操作符。
- 不能重载下面的操作符
>- sizeof---sizeof操作符。(sizeof操作符是编译时运算)
>- .---成员操作符。
>- .*---成员指针操作符。
>- ::---作用域解析操作符。
>- ?:---条件操作符。
>- typeid---一个RTTI操作符。
>- const_cast---强制类型转换操作符。
>- dynamic_cast---强制类型转换操作符。
>- reinterpret_cast---强制类型转换操作符。
>- static_cast---强制类型转换操作符。
- 大多操作符都可以通过成员或非成员函数进行重载，但下面的操作符只能通过成员函数进行重载：
>- =---赋值操作符。
>- ()---函数调用操作符。
>- []---下标操作符。
>- ->---通过指针访问的类成员的操作符。

### 11.3友元简介 ###
友元有3钟：

- 友元函数。
- 友元类。
- 友元成员函数。

通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显示参数(非this传入)。对于非成员重载操作符函数来说，操作符表达式左边的操作数对应于操作符函数的第一个参数，操作符表达式右边的操作数对应于操作符函数的第二个参数。

创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend：
```C++
friend TypeName operator* (double m, const className &T);
```
- 显然operator*()函数是在类声明中声明的，但它不是成员函数，因此不能使用成员操作符来调用。
- 虽然operator*()函数不是成员函数，但它与函数的访问权限相同。

第二步是编写函数定义。因为它不是成员函数，所以不要使用className::限定符。加外不要在定义中使用关键字friend。简而言之，友元函数是非成员函数，其访问权限与成员函数相同。

ostream类对该操作符进行了重载，将其转换为一个输出工具，前面讲过，cout是一个ostream对象，它是智能的。能够识别所有的C++基本类型。这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的operator<<()定义。

```c++
//通过返回ostream的引用实现链式调用
ostream & operator<<(ostream &os, const className &t)
{
	os<< t.intValue << t.floatValue << t.stringValue ;
	return os;
}
```

非成员版本的重载操作符函数所需的形参数目与操作符使用的操作数数目相同，而成员版本所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象(this)。


### 11.6类的自动转换和强制类型转换 ###

C++的目标之一就是把类实现为与基本类型一致，所以也存在隐式转换问题。

对于类ClassName，如果存在一个参数的构造函数，那么：

```C++
// 存在ClassName::ClassName(TypeName)构造函数
ClassName classValue ;
//相当于==>classValue = ClassName::ClassName(TypeNameValue);通过构造函数以参数构造了一个对象。形成隐式转换。   
classValue = TypeNameValue;  
```
最新的C++实现新增了一个关键字(explicit)，用来关闭这种自动特性。也就是说，可以这样声明构造函数：
```C++
//告知编译器禁止使用隐式转换，但仍然允许显式转换，即显式强制类型转换
explicit ClassName(TypeName value);    
//强制类型转换      
ClassNameValue = ClassName(TypeNameValue);   
```

只接受一个参数的构造函数定义了从参数到类类型的转换。如果使用关键字explicit限定了这种构造函数，则它只能用于显示转换，否则也可以用于隐式转换。

当没有使用explicit限定只能用于强制转换，则在以下情况发生隐式转换：

- 将ClassName对象初始化为TypeName值时。    //ClassNameValue = ClassName(TypeNameValue);
- 将TypeName值赋给ClassName对象时。       //classValue = TypeNameValue;
- 将TypeName值传递给接受ClassName参数的函数时。   
- 返回值被声明为ClassName类型的函数试图返回一个TypeName类型值时。

函数原型提供的参数匹配过程，允许使用ClassName(TypeName)构造函数来转换其他数值类型。比如TypeName是float类型，当把int类型当做实参时，int先转换为float，再转换成TypeName给形参.


### 11.6.2转换函数 ###
构造函数只用于从某种类型到类类型的转换。要进行相反的转换必须使用特殊的C++操作符---转换函数。

```C++
//TypeName为int、float、double等
operator typeName(); 
```
- 转换函数必须是类方法。
- 转换函数不能指定返回类型，但要有返回值。(typeName已经指定类型，无需过多注明)
- 转换函数不能有参数。(类的对象即是参数对象)

TypeName(这里为double）指出了要转换成的类型，因此不需要指定返回类型。转换函数是类方法意味着：它需要通过类对象来调用，从而告知函数要转换的值。因此，函数不需要参数。虽然没有返回类型，这二个函数也将返回所需的值。

提供执行自动、隐式转换的函数所存在的问题是：在用户希望转换时，转换函数也可能进行转换。原则来说，最好使用显示转换，而避免隐式转换。关键字explicit不能用于转换函数，但只需用一个功能相同的非转换函数替换访转换函数即可，但仅在被显式地调用时，该函数才会执行。

```C++
ClassName::operator int()
{
	//todo
	return intValue;
};
//改写为
ClassName::ClassName2int(){};
```

C++提供了下面的类型转换：

- 只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。例如，将int值赋给ClassName对象时，接受int参数的ClassName类构造函数将自动被调用。不过，在构造函数声明中使用explicit可防止隐式转换，而只允许显式转换。
- 被称为转换函数的特殊类成员操作符函数，用于将类对象转换为其他类型。转换函数是类成员，没有返回类型、没有参数类型、名为operator typeName()，其中，typeName是对象将被转换成的类型。**将类对象赋给typeName变量或将其强制转换为TypeName类型时，该转换函数将自动被调用**。

全局对象，因为全局对象将在程序的main()函数被调用之前创建。程序员可以创建一个类，其默认构造函数将调用所有的bootstrap函数。实现在main()函数调用之前，执行全局类对象的构造函数来初始化一些数据。

C++允许指定在基本类型之间进行转换的方式。首先，任何接受唯一一个参数的构造函数都可被用作转换函数，将类型与该参数相同的值转换为类。如果将类型与该参数相同的值赋给对象，则C++将自动调用该构造函数。要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换。转换函数必须是成员函数。将类对象转换为TypeName类型的转换函数的原型如下：
```C++
//注意，转换函数没有返回类型、没有参数(必须是成员函数，this)，但必须返回转换后的值（虽然没有声明返回类型）
operator typeName();

```

## 12.类和动态内存分配 ##

类中定义static成员变量，则该变量存储在全局数据区，所有类对象共有，且作用域为类作用域。不能在类的声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存，可以使用这种格式来创建对象，从而分配和初始化内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型，并使用了作用域操作符。

```C++
//在类声明之外使用单独的语句来进行初始化
staitc int ClassName::ClassNameValue  iValue = 110;
```

如果使用new[]来分配内存，则应使用delete[]来释放内存。并且在类中，所有的构造函数统一使用new或new[]，析构函数中使用delete或delete[]。delete可以释放NULL地址。

自动存储对象被删除的顺序与创建的顺序相反。

当使用一个对象来初始化另一个对象时，编译器将自动生成构造函数(称为复制构造函数，因为它创建对象的一个副本)。自动生成的构造函数不知道需要更新静态变量和深copy成员变量指向new出来的空间。

### 12.1.2 隐式成员函数 ###
隐式成员函数：

- 默认构造函数，如果没有定义构造函数。
- 复制构造函数，如果没有定义。
- 赋值操作符，如果没有定义。
- 默认析构函数，如果没有定义。
- 地址操作符，如果没有定义。


#### 默认构造函数####
如果没有提供任何构造函数，C++将创建默认构造函数。如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象时显式地对它进行初始化，或需要创建对象数组时，则必须显式地定义默认构造函数。


#### 复制构造函数 ####
复制构造函数用于将一个对象复制到新创建的对象中。**也就是说，它用于初始化过程中，而不是常规的赋值过程，执行于构造对象时，是一个构造函数**。

```C++
class ClassName
{
	ClassName(ClassName&);   //复制构造函数
};
```
**何时调用复制构造函数**

新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有的对象。
```C++
class StringBad
{
    StringBad(StringBad&);
}; 
StringBad motto;
StringBad metoo = motto;
StringBad also = StringBad(motto);
```
这二种声明可能会使用复制构造函数直接创建metoo和also对象，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metoo和also。

具体的说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。记住，按值传递意味着创建原始变量的一个副本。编译器生成临时对象，也将使用复制构造函数。例如，将3个Vector对象相加时，编译器可能生成临时的Vector对象来保存中间结果。何时生成临时对象随编译器而异，但无论是哪种编译器，当按值传递和返回时，都将调用复制构造函数。

**复制构造函数的功能**

默认的复制构造函数依次复制非静态成员（成员复制也称为浅复制），复制的是成员变量的值。


#### 赋值操作符 ####
C++允许类对象赋值，这是通过自动为类重载赋值操作符实现的。

**何时使用赋值操作符**

- 将已有对象赋给另一个对象时，将使用重载的赋值操作符。
```C++
class StringBad
{
	operator=(const StringBad&);  //注意自我复制带来的先delete再new的情况。
} 
StringBad metoo = motto;
```
不过，实现时也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时对象的值复制到新对象中，这就是说，初始化总是会调用复制构造函数，而使用=操作符时也有可能调用复制构造函数。

**赋值操作符的功能**：与复制构造函数相似，赋值操作符的隐式实现也对成员进行依次复制，如成员本身就是类对象，则程序将使用为这个类定义的赋值操作符来复制该成员，但静态数据成员不受影响。

**重载时，C++将区分常量与非常量函数的特征标，因此可以提供另一个仅供const String对象使用的operator[] ()版本。**

```C++
//实现对String类对象使用[]操作符取index下标的值
const char & String::operator[](int index)const;
```

### 12.1.4 在构造函数中使用new时应注意的事项 ###
因为**隐式成员函数**的存在，使用new时应当这样做：

- 如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete.
- new和delete必须相互兼容。new对应于delete，new[]对应于delete[]。
- 如果有多个构造函数，则必须以相同的方式使用new，要么都带[]，要么都不带，因为只有一个析构函数，因此所有的构造函数都必须与它兼容。不过，可以在一个构造函数中使用new来初始化指针，而在另一个构造函数中将指针初始化为NULL,这是因为delete(无论是否有[])可以用于NULL。
- 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。
- 复制构造函数应分配足够的空间来存储复制的数据，并复制数据，而不仅仅是数据的地址。另外，还应该更新所有受影响的静态类成员。
- 应当定义一个赋值操作符，通过深度复制将一个对象复制给另一个对象。

**返回const类型，则说明返回值为右值，不可当左值**

###　布局new操作符 ###

布局new操作符让您能够在分配内存时指定内存位置。但在该内存上分配的对象需要显示调用析构函数进行析构。

- 程序员必须负责管理布局new操作符从中使用的缓冲区内存单元。要使用不同的内存单元，程序员需要提供二个位于缓冲区的不同地址，并确保这二个内在单元不重叠(如果对同一个地址使用布局new，则会使后new的对象覆盖前一个对象数据)。
- 如果使用布局new操作符来为对象分配内存，必须确保其析构函数被调用。原因在于delete可与常规new操作符配合使用，但不能与布局new操作符配合使用。为了确保析构函数被调用，显式地为使用布局new操作符创建的对象调用析构函数。正常情况下将自动调用析构函数，这是需要显式调用析构函数的少数几种情况之一。
```C++
ClassName classNameValue;
//或使用指针pClassNameValue->~ClassName;进行显式调用析构函数。
classNameValue.~ClassName();   
```
- 对于使用布局new操作符创建的对象，应以与创建顺序相反的顺序进行析构。原因在于，晚创建的对象可能依赖于早创建的对象。

```C++
class Queue
{
	private:
		struct Node
		{
			//tode
		}
}
```

C++新特性：在类声明中嵌套结构或类声明，通过将Node声明放在Queue类中，可以使其作用域为整个类。也就是说，Node是这样一种类型：可以使用它来声明类成员，也可以将它作为类方法中的类型名称，但只能在类中使用。如果声明在类的私有部分进行的，则只能在这个类使用被声明的类型，如果声明是在公有部分进行的，则可以从类的外部通过作用域解析操作符使用被声明的类型。

```C++
class Queue
{
	Queue();
}
Queue::Queue():refValue(value1),constValue(refValue)
{
	//tode
}
```

对需要在分配内存时就要初始化的成员(const成员，引用变量成员,基类构造)，则必须使用成员初始化列表初始化。

从概念上说，调用构造函数时，对象将在括号中的代码执行之前被创建。因此调用Queue()构造函数将导致程序首先给成员变量分配内存。然后，程序流程进入到括号中，使用常规的赋值方式将值存储到内存中。因此，对于const成员变量和引用成员变量，必须在执行到构造函数体之前，即创建对象时进行初始化。C++提供了一种特殊的句法来完成上述工作，它叫作成员初始化列表。成员初始化列表由逗号分隔的初始化列表组成(前面带冒号)。它位于参数列表的右括号之后，函数体左括号之前。

初值可以是常量或构造函数的参数列表中的参数。只有构造函数可以使用这种初始化列表句法。使用成员初始化列表的效率更高。

数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关。

成员初始化列表中使用的括号方式也可以用于常规的初始化中。

```C++
int games = 163;
double talk = 2.7;
//可改写为
int games(163);
double talk(2.7);
```












