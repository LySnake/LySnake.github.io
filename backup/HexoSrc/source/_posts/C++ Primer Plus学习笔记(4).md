---
title: C++ Primer Plus学习笔记(4)
comments: true
categories:
  - archives
  - technology
tags:
  - C++
  - C++ Primer Plus
description: 个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
date: 2017-06-19 22:06:46
updated: {{ updated }}
---
## 14 C++中的代码重用 ##


### 14.1 包含对象成员的类 ###
**has-a**:本身是另一个类的对象的成员变量。这种方法称为包含、组合或层次化。另一种方法是通过私有或保护继承。获得接口是is-a关系的组成部分。而使用组合，类可以获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。

**多重继承**：使得能够使用两个或更多的基类派生出来新的类，将基类的功能组合在一起。


模板特性意味着声明对象时，必须指定具体的数据类型。

对于继承的基类对象部分，构造函数在成员初始化列表中使用类名来调用特定的基类构造函数。对于成员对象，在成员初始化列表中使用成员名调用构造函数。C++要求在构建对象的其它部分之前，先构建继承对象的所有成员对象。因此，如果初始化列表未显式初始化成员对象，C++将使用成员对象类的默认构造函数。

### 14.2 私有继承 ###
C++还有另一种实现has-a关系的途径--私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。

使用公有继承，基类的公有方法将成为派生类的公有方法。简而言之，派生类将继承基类的接口：这是is-a关系的一部分。使用私有继承，基类的公有方法将成为派生类的私有方法，简而言之，派生类不继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。

包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。

当在头文件使用class声明派生类时，如果没有使用public等关键字声明如何继承基类，则以默认以private方式继承。

使用多个基类的继承被称为多重继承（multiple inheritance,MI）.

对于继承基类的对象部分，使用初始化列表方法，使用基类的构造函数初始化基类的对象部分。

私有继承时，通过强制类型转换访问基类对象部分。

用类名显式地限定函数名不适合于友元函数，这是因为友元不属于类。不过，可以通过显式地转换为基类来调用正确的函数。在私有继承中，在不进行显式类型转换的情况下，不能将指向派生类的引用或指针赋给基类引用或指针(基类公有方法通过私有继承成为派生类的私有方法，不具有is-a关系)。另外，由于派生类使用的是多继承，编译器将无法确定应转换成哪个基类，如果两个基类都提供了相同的函数。

类声明中包含表示被包含类的显式命名对象，代码可以通过名称引用这些对象，而 使用继承将使关系更抽象。其次，继承会引起许多问题，尤其从多个基类继承时，可能必须处理许多问题，例如包含同名方法的独立的基类，或共享祖先的独立的基类。另外，包含能够包括多个同类的子对象。如果某个类需要3个string对象，可以使用包含声明3个独立的string成员。而继承则只能使用一个这样的对象(当对象都没有名称时，将难以区分)。


类包含保护成员(可以是数据成员，也可以成员函数)，则这样的成员在派生类中是可用的，但在继承层次结构外是不可用的。如果使用组合将这样的类包含在另一个类中，则后者将不是派生类，而是位于继承层次结构之外，因此不能访问保护成员。但通过继承得到的将是派生类，因此它能够访问保护成员。另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是公有的。(通常，应使用包含建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承)

### 14.3 保护继承 ###

保护继承是私有继承的变体。保护继承在列出基类时使用关键字protected.

使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员。和私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的。当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别便呈现出来了。使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的公有方法在派生类中将变成私有方法；使用保护继承时，基类的公有方法在第二代中将变成受保护的，因此第三代派生类可以使用它们。

|特征|公有继承|保护继承|私有继承|
|:------:|:------:|:------:|:------:|
|公有成员变成|派生类的公有成员|派生类的保护成员|派生类的私有成员|
|保护成员变成|派生类的保护成员|派生类的保护成员|派生类的私有成员|
|私有成员变成|只能通过基类接口访问|只能通过基类接口访问|只能通过基类接口访问|
|能否隐式向上转换|是|是（但只能在派生类中）|否|

**将函数调用包装在另一个函数调用中，即使用一个using声明（就像名称空间那样）来指出派生类可以使用特定的基类成员(使用using声明基类成员函数的作用域)，即使采用的私有派生。**

```C++
class Student: private std::string ,private std::valarray<double>
{
   pulibc:
        using std::valarray<double>::min; 
        using std::valarray<double>::min;
   //something
}
```
using声明只使用成员名---没有圆括号、函数牲标和返回类型。using声明只适用于继承，而不适用于包含。


### 14.3 多重继承 ###
MI描述的是有多个直接基类的类。与单继承一样，公有MI表示的也是is-a关系。必须使用关键字public来限定每一个类。这是因为除非特别指出，否刚编译器将使用默认的私有派生。

```C++
class Worker{};
class Singing :public Worker{};
class Waiter  :public Worker{};
class SSingingWaiter :public Singing, public Waiter{}

//示例
SingingWaiter ed;
//有歧义
Worker * pw = &ed;
//正确方式
Worker *pw1 = (Waiter *)&ed;
Worker *pw2 = (Singing *)&ed;
```
通常这种赋值将反基类指针设置为派生对象中的基类的地址。但ed中包含两个Worker对象，有两个地址可供选择，所以应使用类型转换来指定对象。这将使得基类指针来引用不同的对象(多态性)复杂化。

当C++引入多重继承的同时，它引入了一种新技术---虚基类(virtual base class)，使MI成为可能。

**虚基类**：虚基类使得从多个类(它们的基类相同)派生出的对象只继承一个基类对象。从本质上说，继承的Singing和Waiter对象共享一个Worker对象，而不是各自引入自己的Worker对象的拷贝。因为SingingWaiter现在只包含一个Worker对象。所以可以使用多态。

为什么不抛弃将基类声明为虚拟的这种方式，而使虚拟行为成为MI准则呢？第一，在一些情况下，可能需要基类的多个拷贝；第二，将基类作为虚拟的要求程序员完成额外的计算，为不需要的工具付出代价是不应该的；


使用虚基类时，需要对类构造函数采用一种新的方法。对于非虚基类，惟一可以出现在初始化列表中的构造函数是相临基类构造函数。但这些构造函数可能需要将信息传递给其基类。C++在基类是虚拟时，禁止信息通过中间类自动传递给基类，可以在初始化列表中使用基类的基类的构造函数，来完成祖父虚拟基类对象部分的初始化(非虚拟基类不可使用该方法)。

在祖先相同时，使用MI必须引入虚基类，并修改构造函数初始化列表的规则。另外，如果在编写这些类时没有考虑到MI，则还可能需要重新编写它们。

如果基类是虚基类，派生类将包含基类的一个子对象；如果基类不是虚基类，派生类将包含多个子对象。当虚 基类和非虚基类混合时，情况将如何呢？如：假设类B被用作类C和D的虚基类，同时被用作类X和Y的非虚基类，而类M是从C、D、X和Y派生而来的。在这种情况下，类M从虚拟派生祖先（即类C和D）那里共继承了一个B类子对象，并从每一个非虚拟派生祖先（即类X和类Y）分别继承了一个B类子对象。因此，它包含三个B类子对象。当类通过多条虚拟途径和非虚拟途径继承某个特定的基类时，该类将包含一个表示所有的虚拟途径的基类子对象和分别表示各条非虚拟途径的多个基类子对象。

使用虚基类将改变C++解析二义性的方式。使用非虚基类时，规则很简单。如果类从不同的类那里继承了两个或更多的同名成员，则使用该成员名时，如果没有用类名进行限定，将导致二义性。但如果使用的是虚基类，则这样做不一定会导致二义性。在这种情况下，如果某个名称优先于其它所有名称，则使用它时，即便不使用限定符也不会导致二义性。


从虚基类的一个或多个实例派生而来的类将只继承了一个基类对象。

- 有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数，这对于间接非虚基类来说是非法的。
- 能过优先规则解决名称二义性。（派生类中的名称优先于直接或间接祖先类中的相同名称）

### 14.4.1 定义类模板 ###

模板提供参数化类型，即能够将类型名作为参数传递给接收方来建立类或函数。使用模板成员函数替换原有类的类方法，每个函数头都将以相同的模板声明打头。

和模板函数一样，模板类以下面这样的代码开：
```C++
template <class Type>
class Stack
{
public:
    void count();
}
//Stack<Type>作限定符
template <class Type>
void Stack<Type>::count(){}
```
其中，Stack<ClassName>作为类型，如果在类声明中定义了方法（内联定义），则可以活力模板前缀和类限定符(Stack<Type>)。

模板的具体实现---例如用来处理string对象的堆栈类---被称为实例化或具体化。除非编译器实现了新的export关键字，否则将模板成员函数旋转在一个独立的实现文件中将无法运行。因为模板不是函数，它们不能编译。模板必须与特定的模板实例化请求一起使用。为此，最简单的方法是将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件。

注意，必须显式地提供所需的类型，这与常规的函数模板是不同的，因为编译器可以根据函数的参数类型来确定要生成哪种函数。

任县指针堆栈的方法之一是，让调用程序提供一个指针数组，基中每个指针都指向不同的字符串，反这些指针放在堆栈中是有意义的，因为每个指针都将指向不同的字符串。

模板常被用作窗口类，这是因为类型参数的概念非常适合于将相同的存储方案用于不同类型。

**表达式参数**：指定特殊的类型而不是用作通用类型名，称为非类型或表达式参数。在实例化模板时，用作表达式的参数的值必须是常量表达式，因为在编译期，要对特定类型进行模板实例化，生成特定类型的类代码。

**模板类可用作基类，也可用作组件类，还可用作基他模板的类型参数，递归使用模板，使用多个类型参数**

```C++
template <class T>
class Array
{
private:
    T entry;
}

//用于基类
template <class Type>
class GrowArray: public<Tyep> {};

//用作组件类
template <class Tp>
class Stack
{
private:
    Array<Tp> ar;
}

//用作基他模板的类开参数
Array <Stack<int> > asi;    //必须使用至少一个空白字符将两个>符号分开，以避免与>>操作符混淆。

//递归使用模板
ArrayTP< ArrayTP<int, 5>， 10> twodee;

//使用多个类型参数

template <class T1, class T2>
class Pair
{
private:
    T1 a;
    T2 b;
public:
    T1 &first();
    T2 &second();
    T1 first()const{};
    T2 second()const{};
    Pair(){};
}

template<class T1, class T2>
T1 & Pair<T1, T2>::first()
{}
//todo
```

**默认类型模板参数**

类模板的另一项新特性是，可以为类型参数提供默认值，在以下代码中，如果省略T2的值，编译器将使用int。
```C++
template<class T1, class T2 = int> 
class Topo{}
```
虽然可以为类模板类型参数提供默认值，但不能为函数模板参数提供默认值。不过可以为非类型参数提供默认值，这对于类模板和函数都是适用的。

### 14.4.6 模板的具体化 ###
类模板与函数模板很相似，因为可以有隐式实例化、显式实例化和显式具体化，它们统称为具体化。模板以通用类型的方式描述类，而具体化是使用具体的类型生成类声明。

**隐式实例化**：它们声明一个或多个对象，所需的类型，而编译器使用通用模板提供的处方生成具体的类定义。编译器在需要对象前，不会生成类的隐式实例化，如：

```C++
ArrayTP<double, 30> *pt;   		//没有生成对象，则不会隐式实例化。
pt = new ArrayTP<double, 30>;   //隐式实例化。
```
**显式实例化**：当使用关键字template并指出所需类型来声明类时，编译器将生成类声明的显式实例化。声明必须位于模板定义所在的名称空间中。

```C++
//在这种情况下，虽然没有创建或提及类对象，编译器也将通过通过模板生成类声明和定义。
template class ArrayTP<string, 100>;
```

**显式具体化**：是特定类型(用于替换模板中的通用类型)的定义，有时候可能需要在为特殊类型实例化时，对模板进行修改，使基行为不同。在这种情况下，可以创建显式具体化。当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化版本。具体化类模板定义的格式如下：
```C++
template<> class ClassName<specialized-type-name>{...};
//使用新表示法提供一个专供char*类型使用的SortedArray模板，可以使用与下面类似的代码
template<> class SortedArray<char*>{...};
```

**部分具体化**：C++还允许部分具体化，即部分限制模板的通用。如：部分具体化可以给类型参数之一指定具体的类型。
```C++
//通用模板
template<class T1, class T2> class Pair{};
//部分具体化模板
template<class T1> class Pair<T1, int>{};
```
关键字template后面的<>声明的是没有被具体化的类型参数。 因此，上述第二个声明将T2具体化为int，但T1保持不变。注意，如果指定所有的类型，则<>内将为空，这将导致显式具体化。

如果有多个模板可供选择，则编译器将使用具体化程度最高的模板。

### 14.4.7 成员模板 ###
C++模板支持的另一个新特性是：模板可用作结构、 类或模板类的成员。

```C++
template <typename T>
class Beta
{
private:  
    template<typename V> 
    class Hold
	{
	private:
		V val;
	public:
		Hold(V v = 0):V(v){};
	}
public:
    Beta(T t,int i):q(t), n(i){};
}
```
Hold模板类是在私有部分声明的，因此只能在Beta类中访问它。

### 14.4.8 将模板用作参数 ###

```C++
#include<iostream>
#include　"stacktp.h"
//模板参数
template<template <typename T> class Thing>
class Crab
{
private:
    Thing<int> s1;
    Thing<double> s2;
public:
    Crab();
    bool push(int a, double x);
}

int main()
{
  Crab<Stack> nebula;
  //todo
}
```
Crab模板的成员s1、s2，使用模板参数声明的Thing模板去实例化成员，当使用时模板参数为Stack，则使用Stack去实例化s1、s2。

### 14.4.9 模板类和友元 ###
模板类声明也可以有码元，模板的友元分3类：

- 非模板友元
- 约束模板友元，即友元的类型取决于类被实例化时的类型。
- 非约束模板码元，即友元的所有具体化都是类的每一个具体化的友元。

**非模板友元**：为具体模板实例化编写不同的友元。如果友元不带模板类型参数，则所有模板实例化共用一个友元函数，如果友元带模板类型参数，则为不同类型的模板实例化编写相应的友元。

**模板类的约束模板友元函数**：约束模板友元函数是在类外面声明的模板的具体化。

```C++
template <typename TT>
CLASS HasFriendT
{
private: 
    TT item;
    static int ct;
public:
    HasFriendT(const TT &i):item(i){ct++;}
    ~HasFriendT(){ct--;}

    //声明中的<>指出这是模板具体化。
    friend void counts<TT>();
    //对于report，<>可以为空，这是因为可以从函数参数推断出模板类型参数。
    friend void report<> (HasFriendT<TT> &);
}

//模板类外声明的模板函数友元
template <typename T>
int HasFriendT<T>::ct = 0;

template <typename T>
void counts()
{
  cout << hf.item << endl;
}

void main()
{
    //声明中的<>指出这是模板具体化。
    counts<int>();
    
}
```
**模板类的非约束模板友元函数**：通过在类内部声明模板，可以创建非约束码元函数，即每个函数具体化都是每个类具体化的码元。对于非约束友元，友元模板类型参数与模板类型参数是不同的。

```C++
template <typename T>
class ManyFriend
{
private:
    T item;
public:
    ManyFriend (const T &i):item(i) {}
     
    //模板类内声明的模板函数友元，定义与类成员模板函数一起定义
    template<typename C, typename D> 
    friend void show2(C & c, D & d);
}

template < typename C, typename D> 
void show2(C & c, D & d)
{
    cout << c.item << "," << d.item << endl;
}

int main()
{
    //todo
    show2(hfdb, hfi2);
    //todo
}
```

### 14.5 总结 ###
使用私有继承时，基类的公有成员和保护成员将成为派生类的私有成员；使用保护继承时，基类的公有成员和保护成员将成为派生类的保护成员。无论使用哪种继承，基类的公有接口都将成为派生类的内部接口。这有时候被称为继承实现，但不继承接口，因为派生类对象不能显式地使用基类的接口。因此，不能将派生对象看作是一种基类的对象。由于这个原因，在不进行显式类型转换的情况下，基类指针或引用将不能指向派生类对象。

还可以通过开发包含对象成员的类来重用类代码。这种方法被称为包含、 层次化或组合，它建立的也是has-a关系。与私有继承和保护继承相比，包含更容易实现和使用，所以通常优先采用这种方式。不过，私有继承和保护继承与包含有一些不同的功能。例如，继承允许派生类访问基类的保护成员；还允许派生类重新定义从基类那里继承的虚函数。因为包含不是继承，所以通过包含来重用类代码时， 不能使用这些功能。 另一方面，如果需要使用某个类的几个对象，则用包含更适合。

可以提供显式具体化---覆盖模板定义的具体类声明。方法是以template<>打头，然后是模板类名称，再加上尖括号（其中包含要具体化的类型）。
