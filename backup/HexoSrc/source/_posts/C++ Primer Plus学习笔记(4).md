---
title: C++ Primer Plus学习笔记(4)
comments: true
categories:
  - archives
  - technology
tags:
  - C++
  - C++ Primer Plus
  - cocos2d-x
description: 个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
date:  {{ date }}
update: {{ update }}
---
## 14 C++中的代码重用 ##


### 14.1 包含对象成员的类 ###
**has-a**:本身是另一个类的对象的成员变量。这种方法称为包含、组合或层次化。另一种方法是通过私有或保护继承。获得接口是is-a关系的组成部分。而使用组合，类可以获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。

**多重继承**：使得能够使用两个或更多的基类派生出来新的类，将基类的功能组合在一起。


模板特性意味着声明对象时，必须指定具体的数据类型。

对于继承的基类对象部分，构造函数在成员初始化列表中使用类名来调用特定的基类构造函数。对于成员对象，在成员初始化列表中使用成员名调用构造函数。C++要求在构建对象的其它部分之前，先构建继承对象的所有成员对象。因此，如果初始化列表未显式初始化成员对象，C++将使用成员对象类的默认构造函数。

### 14.2 私有继承 ###
C++还有另一种实现has-a关系的途径--私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。

使用公有继承，基类的公有方法将成为派生类的公有方法。简而言之，派生类将继承基类的接口：这是is-a关系的一部分。使用私有继承，基类的公有方法将成为派生类的私有方法，简而言之，派生类不继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。

包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。

当在头文件使用class声明派生类时，如果没有使用public等关键字声明如何继承基类，则以默认以private方式继承。

使用多个基类的继承被称为多重继承（multiple inheritance,MI）.

对于继承基类的对象部分，使用初始化列表方法，使用基类的构造函数初始化基类的对象部分。

私有继承时，通过强制类型转换访问基类对象部分。

用类名显式地限定函数名不适合于友元函数，这是因为友元不属于类。不过，可以通过显式地转换为基类来调用正确的函数。在私有继承中，在不进行显式类型转换的情况下，不能将指向派生类的引用或指针赋给基类引用或指针(基类公有方法通过私有继承成为派生类的私有方法，不具有is-a关系)。另外，由于派生类使用的是多继承，编译器将无法确定应转换成哪个基类，如果两个基类都提供了相同的函数。

类声明中包含表示被包含类的显式命名对象，代码可以通过名称引用这些对象，而 使用继承将使关系更抽象。其次，继承会引起许多问题，尤其从多个基类继承时，可能必须处理许多问题，例如包含同名方法的独立的基类，或共享祖先的独立的基类。另外，包含能够包括多个同类的子对象。如果某个类需要3个string对象，可以使用包含声明3个独立的string成员。而继承则只能使用一个这样的对象(当对象都没有名称时，将难以区分)。


类包含保护成员(可以是数据成员，也可以成员函数)，则这样的成员在派生类中是可用的，但在继承层次结构外是不可用的。如果使用组合将这样的类包含在另一个类中，则后者将不是派生类，而是位于继承层次结构之外，因此不能访问保护成员。但通过继承得到的将是派生类，因此它能够访问保护成员。另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是公有的。(通常，应使用包含建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承)

### 14.3 保护继承 ###

保护继承是私有继承的变体。保护继承在列出基类时使用关键字protected.

使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员。和私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的。当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别便呈现出来了。使用私有继承时，第代工类将不能使用基类的接口，这是因为基类的公有方法在派生类中将变成私有方法；使用保护继承时，基类的公有方法在第二代中将变成受保护的，因此第三代派生类可以使用它们。

|特征|公有继承|保护继承|私有继承|
|:------:|:------:|:------:|:------:|
|公有成员变成|派生类的公有成员|派生类的保护成员|派生类的私有成员|
|保护成员变成|派生类的保护成员|派生类的保护成员|派生类的私有成员|
|私有成员变成|只能通过基类接口访问|只能通过基类接口访问|只能通过基类接口访问|
|能否隐式向上转换|是|是（但只能在派生类中）|否|

**将函数调用包装在另一个函数调用中，即使用一个using声明（就像名称空间那样）来指出派生类可以使用特定的基类成员，即使采用的私有派生。**

```C++
class Student: private std::string ,private std::valarray<double>
{
   pulibc:
        using std::valarray<double>::min; 
        using std::valarray<double>::min;
   //something
}
```
using声明只使用成员名---没有圆括号、函数牲标和返回类型。using声明只适用于继承，面不适用于包含。


### 14.3 多重继承 ###





