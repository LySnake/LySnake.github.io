---
title: C++ Primer Plus学习笔记(5)
comments: true
categories:
  - archives
  - technology
tags:
  - C++
  - C++ Primer Plus
  - cocos2d-x
description: 个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
date:  {{ date }}
update: {{ update }}
---
	
## 15. 友元、异常和其他 ##

### 15.1 友元类 ###
将类作为友元，友元类的所有方法都可以访问原始类的私有成员和保护成员。另外，也可以做更严格的限制，只将特定的成员函数指定为另一个类的友元。

友元声明可以位于公胡、私有或保护部分，其所在的位置无关紧要。由于友元类中的方法使用了包含类相关信息，所以编译器必须了解包含类后才能处理友元类。

类友元是一种自然用语，用于表示一些关系。如果不使用某些形式的友元关系，则必须将包含类的私有部分设置为公有，或者创建一个笨拙的、大型类来包含这二个类。

```C++
class Tv
{
public:
    friend class Remote; 
    //todo
}

class Remote
{
public:
    bool set_chan(Tv &t, int c){t.channel = c}
}
```

### 15.2 友元成员函数 ###

确实可以选择仅让特定的类成员成为加一个类的友元，而不必让整个类成为友元，不过这样做稍微有点麻烦，必须小心排列各种声明和定义的顺序。为此，将使用前向声明来处理。

```C++
class Tv;     		//前向声明
class Remote{...};  //友元类
class Tv{...};      //包含类
```
另外，可以把友元类的成员函数，实现写在Tv类的后边（头文件中），加inline关键字实现成员方法为内联方法，这样，可以让编译器不在类声明中就要知道包含类的过多信息，避免因编译器不知道包含类的成员信息而无法编译。

```C++
#ifndef TVFM_H_
#define TVFM_H_

class Tv;   //前向声明
class Remote 
{
public:
   enum {TV};
private:
   int mode;
public:
   Remote(int m =TV):mode(TV){}
   bool set_mode(Tv &t);
   void Remote::set_chan(Tv &t, int c);
}

class Tv
{
public:
    friend void Remote::set_chan(Tv &t, int c);
private:
    int channel;
//todo
}

inline void Remote::set_chan(Tv &t, int c){t.channel = c;}
#endif 
```
内联函数的链接性是内部的，这意味着函数定义必须在使用函数的文件中，在这个例子中，内联定义位于头文件中，因此在使用函数的文件中包含头文件可确保将定义放在正确的地方。也可以将定义放在实现文件中，但必须删除关键字inline，这样函数的链接性将是外部的。

### 15.1.3 其他友好关系 ###

**二个类相互成为友元**：当二个类都要修改另一个类的成员信息时。

**共同的友元**：函数需要访问二个类的私有数据。从逻辑上看，这样的函数应是每个类的成员函数，但这是不可能的，它可以是一个类的成员，同时是另一个类的友元，不过有时将函数作为二个类的友元更合理。


### 15.2 嵌套类 ###
在C++中，可以将类声明放在另一个类中。在另一个类中声明的类被称为嵌套类，它通过提供新的类型类作用域来避免名称混乱。包含类的成员函数可以创建和使用被嵌套类的对象；而声明位于公有部分，才能在包含类的外面使用嵌套类，而且必须使用作用域解析操作符。

对类进行嵌套与包含并不同。包含意味着将类对象作为另一个类的成员，而对类进行嵌套不创建类成员，而是定义了一种类型，该类型仅在包含嵌套类声明的类中有效。

由于结构体是一种其成员在默认情况下为公有的类，所以Node结构体实际上是一个嵌套类，但该定义并没有充分利用类的功能。具体地说，它没有显式构造函数。可以如下添加：
```C++
class Queue
{
	class Node
	{
	 public:
     	Item item;
		Node* next;
		Node(const Item &i):item(i),next(0){}
	};
//todo
}
```

### 15.2.1 嵌套类和访问权限 ###
嵌套类的声明位置决定了嵌套类的作用域，即它决定了程序的哪些部分可以创建这种类的对象。其次，和其他类一样，嵌套类的公有部分、保护部分和私有部分控制了对类成员的访问。

如果嵌套类是在另一个类的私有部分声明的，则只有后者知道它。另外，类的成员的默认访问权限是私有的。

如果嵌套类是在另一个类的保护部分声明的，则它对于后者来说是可见的，但是对于外部世界则是不可见的。不过，在这种情况中，派生类将知道嵌套类，并可以直接创建这种类型的对象。如果嵌套类是在另一个类的仅有部分声明的，则允许后者、后者的派生类以及外部世界使用它，轩为它是公有的。不过，由于嵌套类的作用域为包含它的类，因此外部世界使用它时，使用类限定符。

嵌套结构和枚举的作用域与些相同。其实，很多程序员都使用公有枚举来提供可供客户程序员使用的类常数。

|声明位置|包含它的类是否可以使用它|从包含它的类派生而来的类是否可以使用它|外部世界是否可以使用|
|<---->|<---->|<---->|<---->|
|私有部分|是|否|否|
|保护部分|是|是|否|
|公有部分|是|是|是，通过类限定符来使用|

### 15.2.2 模板中的嵌套 ###
STL中的迭代器就是通过模板中嵌套类定义实现的，并且可以与包含模板使用同样的类型作为参数而不用再使用template声明。

```C++
#ifdef QUEUETP_H_
#define QUEUETP_H_

template <typename Item>
class QueueTP
{
private:
    enum{Q_SIZE = 10};

	class Node
	{
	public:
	    Item item;
	    Node *next;
	    Node(const Item &i):item(i),next(0){}
	}

//todo
}

#endif
```

### 15.3 异常 ###

程序有时会遇到运行阶段的错误，导致程序无法正常地运行下去。例如，程序可能试图打开一个不可用的文件，请求过多的内在，或者遭遇不能容忍的值。通常，程序员都会试图这种意外的情况。C++异常为处理这种情况提供了一种功能强大而灵活的工具。有些编译器默认关闭这种特性，可能需要使用编译器选项来启用它。

abort()函数的原型位于头文件cstdlib（或stdlib.h)中，其典型实现是向标准错误流(即cerr使用的错误流)发送消息abnormal program termination (程序异常终止)，然后终止程序。它还返回一个随实现而异的值，告诉操作系统（如果程序是由另一个程序调用的，则告诉父进程），处理失败。abort()是否刷新文件缓冲区（用于存储读写到文件中的数据的内存区域）取决于实现。

### 15.3.3 异常机制 ###
C++异常是对程序运行过程中发生的异常情况（例如被0除）的一种响应。异常提供了将控制权从程序的一个部分传递到另一部分的途径。对异常的处理有3个组成部分：

- 引发异常
- 捕获有处理程序的异常
- 使用try块

 throw语句实际上是跳转，即命令程序跳到另一条语句。throw关键字表示引发异常，紧随其后的值（例如字符串或对象）指出了异常的特征。

程序使用异常处理程序来捕获异常，异常处理程序位于要处理问题的程序中。catch关键字表示捕获异常。处理程序以关键字catch开头，随后是位于括号中的类型声明，它指出了异常处理程序要响应的异常类型。然后是一个用花括号括起的代码块，指出要采取的措施。catch关键字和异常类型用作标签，指出当异常被引发时，程序应跳到这个位置执行。异常处理程序也被称为catch块。

try块标识其中特定的异常可能被激活的代码块，它后面跟一个或多个catch块。try块是由关键字try指示的，关键字try的后面是一个由花括号括起的代码块，表明需要注意这些代码引发的异常。

如果try块中某条语句导致异常被引发，则后面的catch块将对异常进行处理。如果程序在try块的外面产生异常，将无法被catch捕获。

异常类型可以是字符串（就像这个例子中那样）或其它C++类型，通常为类类型。执行throw语句类似执行返回语句，因为它也将终止函数的执行，但throw不是将控制权返回给调用程序，而是导致程序沿函数调用序列后妈，直到找到包含try块的函数。

关键字catch表明这是一个处理程序，而chatch(type &value)中的type则表明该处理程序与字符串异常匹配，value与函数参数定义极其相似，因为匹配的细皮引发将被赋给value。另外，当异常与该处理程序匹配时，程序将执行括号中的代码。

执行完try块中的语句后，如果没有引发任何异常，则程序跳过try块后面的catch块，直接执行处理程序后面的第一条语句。

如果函数引发了异常，而没有try块或没有匹配的处理程序时，在默认情况下，程序最终将调用abort()函数，但可以修改这种行为。

通常，引发异常的函数将传递一个对象，这样做的主要优点之王是，可以使用不同的这类型来区分不同的函数在不同情况下引发的异常。另外，对象可以拾信息，程序员可以根据这些信息来确定引发异常的原因，同是，catch块可以根据这些信息来决定采取什么样的措施。

可使用异常规范对函数定义进行限定，指出它将引发哪些类型的异常。为此，可在函数定义的后面加上异常规范，它由关键字throw和异常类型列表组成，异常类型列表被括在括号中，并用逗号分隔。

```C++
//异常规范
double hmean(double a, double b) throw(bad_hmean);
```
这无成了二项工作，首先，它告诉编译器，该函数引发哪些类型的异常。如果以后该函数引发了其他类型的异常，程序(最终)将调用abort()函数，对这种越权做出反应。其次，使用异常规范将提醒阅读该原型的人，该函数引发异常，应提供try块和处理程序。对于引发多种异常的函数，可提供一个由逗号分隔的异常类型列表。这种句法与函数原型参数列表句法类似。如果异常规范中的括号内为空，则表明该函数不会引发异常。

C++通常通过将信息放在堆栈中来处理函数调用，具体地说，程序将调用函数的指令的地址(返回地址)放到堆栈中。当被调用的函数执行完毕后，程序将使用该地址来确定从哪里开始继续执行。另外，函数调用将函数参数放到堆栈中。 在堆栈中，这些函数参数被视为自动变量。如果被调用的函数创建了新的自动变量，则这些变量也将被添加到堆栈中。如果被调用的函数调用了另一个函数，则后者的信息将被添加到堆栈中，依此类推。当函数结束时，程序流将跳到该函数被调用时存储的地址处，同时堆栈顶端的元素被释放。因此，函数通常都返回到调用它的函数，依此类推，同时每个函数都在结束时释放其自动变量。如果自动变量是类对象，则类的析构函数(如果有的话-->只有需要的时候编译器才会创建)将被调用。

现在假设函数由于出现异常(而不是由于返回)而终止，则程序也将释放堆栈中的内存，但不会在释放堆栈的第一个返回地址后停止，而是继续释放堆栈，直到找到一个位于try块中的返回地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句，这个过程被称为堆栈解退。引发机制的一个非常重要的特性是，和函数返回一样，对于堆栈中的自动类对象，类的析构函数将被调用。不过函数返回仅仅处理该函数放在堆栈中的对象，而throw语句则处理try块和throw之间整个函数调用序列放在堆栈中的对象。如果没有堆栈解退这种特性，则引发异常后，对于中间函数调用放在堆栈中的自动类对象，其析构函数将不会被调用。

程序进行堆栈解退以回到能够捕获异常的地方时，将释放堆栈中的自动存储型变量。如果变量是类对象，将为该对象调用析构函数。

普通函数中，返回语句将控制权返回到调用函数，但throw语句将控制权向上返回到第一个这样的函数：包含能够捕获相应异常的try-catch组合。

catch中的类型变量，使用的是throw的类型变量的一个副本，因为自动变量将会释放。

throw语句将生拷贝，为何代码中使用引用呢？毕竟将引用作为返回值的通常原因是避免创建拷贝以提高效率。答案是，引用还有另一个重要牲：基类引用可以执行派生类对象，假设有一组通过继承关联起来的异常类型，则在异常规范中只需列出一个类型引用，它将与任何派生类对象匹配。

如果有一个异常类继承层次结构，应这样排列catch块：将捕获位于层次结构最下面的异常类的catch语句放在最前面，将捕获基类异常的catch语句放在最后面。






