---
title: C++ Primer Plus学习笔记(1)
comments: true
categories:
  - archives
  - technology
tags:
  - C++
  - C++ Primer Plus
description: 个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
date: 2017-05-21 18:47:33
update:
---

### 0.预备知识 ###

C++是C语言的超集，这意味着任何有效的C程序都是有效的C++程序。

最初，Stroustrup实现C++时，使用了一个C++到C的编译器程序，而不是开发直接的C++到目标代码的编译器。前者叫做cfront（表示C前端，C fron end），它将C++源代码翻译成C源代码，然后使用一个标准C编译器对其进行编译。这种方法简化了向C的领域引入C++的过程，其它实现也采用这种方法将C++引入到其它平台。随着C++的日渐普及，越来越多的实现转向创建C++编译器，直接将C++源代码生成目标代码。

### 8.函数控幽 ###
**名称修饰**：对原始名称进行的表面看来无意义的修饰（或矫正，因人而异）将对参数数目和类型进行编码。添加的一组符号随函数特征标而异，而修饰时使用的约定随编译器而异。比如，正常的c函数声明void fn(int);在\*.o文件中，链接器查看到的符号表差不多就是_fn，并没有带有参数类型标识，但C++因为有重载，重写，同一个函数名可能存在于多个类中或一个类中存在相同函数名但参数表不一样，此时目标文件\*.obj中连接器查看到的符号表是带参数类型和顺序的，如_fn_i。

TIP：**C++标准允许每个编译器设计人员以他认为合适的方式实现名称修饰，因此由不同编译器创建的二进制模块（对应目标文件）很可能无法正确地链接。也就是说，这二个编译器将为同一个函数生成不同的修饰名称。名称的不同将使链接器无法将一个编译器生的函数调用与另一个编译器生成的函数定义匹配。在链接编译模块时，请确保所有文件或库都是由同一个编译器生成的。**

**函数模板**：是通用的函数描述，也就是说，它们使用通用类型来定义函数，其中的通用类型可用具体的类型（如int或float）替换，通过将类型作为参数传递给模板，可使编译器生成对应类型的函数。

```c++

template <class T>   //也可使用 template <typename T>

void Swap(T& a, T& b)
{
    //todo.
}

```
关键字template和class是必需的，除非可以使用关键字typename代替class，typename关键字使得参数T表示类型这一点更为明显；不过，有大量的代码库是使用关键字class开发的。在这种上下文中这二个关键字是等同的。另外使用尖括号。模板并不创建任何函数，而只是告诉编译器如何定义函数。

并非所有的模板参数都是必须是模板参数类型。使用模板的好处是，它使生成多个函数定义更简单、更可靠。

如果有多个原型，则编译器在选择原型时，非模板版本将优先于显式具体化和模板版本，而具体化将优先于使用模板生成的版本。

在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例。

**编译器选择使用哪个函数版本**：

1. 创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。
2. 使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐匿转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将参数转换为double类型，从而是与double形参匹配，而模板可以为float生成一个实例。
3. 确定是否有最佳的可行函数。如果有，则使用它，否则访函数调用出错。


### 9.内存模型和名称空间 ###

如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找;但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录（或其它目录，这取决于编译器）。如果没有在那里找到头文件，则将在标准位置查找。因此在包含自己的头文件时，应使用引号而不是尖括号。

**作用域**：描述了名称在文件（翻译单元）的多大范围内可见。例如，函数中定义的变量可在该函数中使用，但不能在其它函数中使用;而在文件中的函数定义之前定义的变量则可在所有函数中使用。

**链接性**：描述了名称如何在不同单元（源文件）间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量没有链接性，因此它们不能共享。



堆栈的默认长度取决于实现，但编译器通常提供改变堆栈长度的选项。

如果变量被关键字register修饰而存储在寄存器中，则没有内存地址，因此不能将地址操作符用于寄存器变量。

如果没有初始化静态变量，编译器就将它设置为0.在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0.

**关键字valatile**：表明即使程序代码没有对内存单元进行修改，其值也可能发生改变。例如，可以将一个指针指向某个硬件位置，其中包含了来自串行端口的时间或信息，在这种情况下，硬件可能修改其中的内容。该关键字的作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值二次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这二次使用之间不会变化，如果不将变量声明为volatile，则编译器将进行这种优化，将变量声明为volatile，相当于告诉编译器，不要进行这种优化。

**关键字mutable**：指出即使结构（或类）变量为const，其某个成员也可以被修改(修饰某个成员)。

**const**:在C++中(但不是在C中)，const限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。也就是说，C++看来，全局const就像使用了static说明符一样.
```c++

const int state = 50;   //内部链接性，常数变量

```

**extern**：程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性.

```c++

extern const int state = 50;  //external linkge

```

**布局new操作符**：指定要使用的位置地址，程序员可能使用这种特性来设置其内存管理规程或处理需要通过特定地址进行访问的硬件。但不可delete(delete只能用于这样的指针：指向常规new操作符分配的堆内存。)。


```c++

auto p1 = new (pointName) typeName;   //向地址为pointName申请一个类型为typeName的空间地址给p1;
auto p2 = new (pointName) typeName;   //向地址为pointName申请一个类型为typeName的空间地址给p2,如此便覆盖了p1所指向的空间。

```

#### 名称空间 ####

**声明区域**：是可以在其中进行声明的区域。例如，可以在函数外面声明全局变量，对于这种变量，其声明区域为其声明所在的文件，对于在函数中声明的变量，其声明区域为其声明所在的代码块。

**潜在作用域**：变量的潜在作用域从声明开始，到其声明作用域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。

**作用域**：变量对程序而言可见的区域。变量并不是在潜在作用域内都可见，比如子代码块定义的变量隐藏现象。

**名称空间**：通过定义一种新的声明来创建命名的名称空间。这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间中相同名称发生冲突，同时允许程序的其它部分使用该名称空间中的声明的东西。

名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。

```c++

//名称空间中的声明和定义规则同全局声明和定义规则相同。

//在*.h中的声明
namespace Jace
{
int i;
float f;
void fn();
struck Well{};
}

//在*.cpp中的定义
namespace Jace
{
  using std::cout ;
  using namespace std;
  void fn()
  {
      //todo.
  }
}
```

**全局名称空间**：它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于于全局名称空间中，引用全局变量可以为::valueName。

**using声明**：使特定的标识符在当前作用域可用。

```c++

using std::cout; //仅使用std::cout时可直接使用cout而不带作用域解析操作符，但std中的其它名称不可以。
```

**using编译指令**：使整个名称空间中的名称在当前作用域可用。

```c++
using namespace std; //则std名称空间中所有名称可在当前作用域中直接使用而不用带有作用域解析操作符。
```
使用using声明时，就好像声明了相应的名称一样。如果某个名称已经在函数中声明了，则不能用using声明导入相同的名称。然而，使用using编译指令时，将进行名称解析，就像在包含using声明和名称空间本身的最小声明区域中声明了名称一样。如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。

假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，则这二个名称会发生冲突，从而出错。如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。


在名称空间中可以嵌套使用using声明和using编译指令来生成新的名称空间。如：

```c++

namespace elements
{
 using namespace std;
 //或
 using std::cout;
}

```


**名称空间别名**：using myNewName = myth::elements::fire;

**未命名的名称空间**：就像后面跟着using编译指令一样，也就是说，在该名称空间中声明的名称的潜在作用域为：从声明点到该点声明区域末尾，从这个方面看，它们与全局变量相似。不过由于这种名称空间没有名称，因此不能显式地使用using声明或using编译指令来使它在其它位置都可用。具体地说，不能在当前的名称空间所属文件之外的其它文件中，使用该名称空间中的名称，因此这种方法可以替代链接性为内部的静态变量。实际上，C++标准不建议在名称空间和全局作用域中使用关键字static。

**名称空间指导原则**：

- 使用在已命名的名称空间中的变量，而不是使用外部全局变量。
- 使用在已命名的名称空间中的变量，而不是使用静态全局变量。
- 如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++当前提倡将标准函数库放在名称空间为std中，这种做法扩展到了来自C语言中的函数。
- 仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。
- 不要在头文件中使用using编译指令。首先这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include之后。
- 导入名称时，首选使用作用域解析操作符或using声明的方法。
- **对于using声明，首选将其域设置为局部而不是全局**。

**老式头文件（如iostream.h)没有使用名称空间，但新头文件iostream使用了std名称空间。**


### 10.对象和类 ###

**构造函数**：专门用于构造新对象、将值赋给它们的数据成员。

1. 没有返回值，但没有被声明为void类型。实际上，构造函数没有声明类型。
2. 当构造函数可使用一个参数时，接受一个参数的赋值句法来将对象初始化为一个值。如：ClassName obj = value;
3. 如果没有定义任何构造函数，当构造函数被需要时，编译器会生成一个啥也不作的默认构造函数(比如生成对象数组时要使用构造函数)。若类定义了构造函数后，程序员就必须为它提供默认构造函数。
4. 使用构造函数初始化对象。 

```c++
ClassName a = ClassName(value1, value2);   //使用带参构造函数初始化对象a或临时对象(先初始化临时对象，再赋值给a对象，临时对象释放调用析构函数)，C++标准允许编译器使用两种方式来执行，第一种是直接初始化对象a,无临时对象，另一种是初始化临时对象，再赋值给对象a，然后临时变量调用析构函数释放。

ClassName a();                             //使用无参构造函数初始化对象a，没有临时对象产生。 

```

**析构函数**：对象过期时，程序将自动调用一个特殊的成员函数，完成清理工作。

1. 析构函数没有返回值类型，没有参数，其名称为类名称前加上~，且每个类只能有一个析构函数。
2. 如果创建的是静态存储对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时自动被调用。如果对象是通过new创建的，则它将驻留在堆栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动调用。
3. 自动变量放在堆栈中，优先清理后定义的变量，因此最后创建的对象将最先被删除，最先创建的对象将最后被删除。

**const成员函数**：如果定义了一个ClassName类型的对象a,且修饰成const，那么对象a的成员变量不能改变，但如果调用其成员方法，不能确保方法不修改其成员变量。因些对于这些方法，使用const关键字，保证函数不会修改调用对象。声明和定义如下：

```c++
void fn(int, float)const;                //类中声明

void ClassName::fn(int, float)const{};   //定义

const Stock & top(const Stock &s)const;  //括号中的const表明，该函数不会修改被显式地访问的对象，而括号后的const表明，该函数不会修改被隐式地访问的对象。由于该函数返回了二个const对象之一的引用，因些返回值类型也应为const引用。
```

**this**:this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）。

毕竟类的目标之一是使用户定义的类型与内置类型尽可能的相似，类的构造函数负责确保调用对象成员的构造函数。名为成员初始化列表的特性可提高构造函数设计的效率(因为对于基类部分与成员为类成员的部分，先于该类被初始化，然后再执行该类的构造函数对基本类型进行```赋值而非初始化```，如果类成员在构造函数中被赋值，则该成员类对象先在构造函数之前使用默认构造函数，在该类构造函数中被赋值)。

**类作用域**：在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类之外是不可知的。

**作用域为整个类的常量**：

1. **在类中声明一个枚举**：在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称。用这种方式声明枚举并不会创建类数据成员，也就是说，所有对象中都不包含枚举。另外，枚举常量只是一个符号名称，在作用域整个类的代码中遇到它时，编译器将用实际值来替换它。
2. **使用static关键字创建一个常量**：该常量与静态变量存储在全局区，而不是存储在对象中。作用域为类作用域，存储在全局区，被这个类的所有对象共享。





