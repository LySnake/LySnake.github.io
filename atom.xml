<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LySnake个人博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://LySnake.github.io/"/>
  <updated>2018-02-24T13:23:18.370Z</updated>
  <id>http://LySnake.github.io/</id>
  
  <author>
    <name>LySnake</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ Primer Plus学习笔记(7)</title>
    <link href="http://LySnake.github.io/archives/technology/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7).html"/>
    <id>http://LySnake.github.io/archives/technology/C++ Primer Plus学习笔记(7).html</id>
    <published>2017-07-22T02:13:12.000Z</published>
    <updated>2018-02-24T13:23:18.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第17章-输入、输出和文件"><a href="#第17章-输入、输出和文件" class="headerlink" title="第17章 输入、输出和文件"></a>第17章 输入、输出和文件</h2><h3 id="17-1-C-输入和输出概述"><a href="#17-1-C-输入和输出概述" class="headerlink" title="17.1 C++输入和输出概述"></a>17.1 C++输入和输出概述</h3><p>C++程序把输入和输出看作是字节流。输入时，程序从输入流中抽取字节；输出时，程序将字节插入到输出流中。对于面向文本的程序，每个字节代表一个字符，更通俗地说，字节可以构成字符或数值数据的二进制表示。输入流中的字节可能来自键盘，也可能来自存储设备（如硬盘）或其它程序。同样，输入流中的字节可以流向屏幕、打印机、存储设备或其它程序。流充当了程序和流源或流目标之间的桥梁。这使得C++程序可以以相同的方式对待来自键盘的输入和来自文件的输入。C++程序只是检查字节流，而不需要知道字节来自何向。</p>
<p>通常，通过使用缓冲区可以更高效地处理输入和输出。缓冲区是用作中介的内存块，它是将信息从设备传输到程序或从程序传输给设备的临时存储工具。通常，像磁盘驱动器这样的设备，以512字节(或更多)的块为单位来传输信息，而程序通常每次只能处理一个字节的信息。缓冲区帮助匹配这二种不同的信息传输速率。</p>
<p>键盘输入每次提供一个字符，因此在这种情况下，程序无须缓冲区来帮助匹配不同的数据传输速率。不过，对键盘输入进行缓冲可以让用户在将输入传输给程序之前返回并更正。C++程序通常在用户按下回车键时刷新输入缓冲区。</p>
<p>使用ostream对象(如cout)来处理输出。创建这样的对象将打开一个流，自动创建缓冲区，并将其与流关联起来，同时使得能够使用类成员函数。</p>
<p>I/O类被重新编写。为成为国际语言，C++必须能够处理需要要16位的国际字符集或更宽的字符类型。因此，该语言在传统的8位char（或”窄”)类型的基础上添加了wchar_t(或“宽”)字符类型。每种类型都需要有自己的I/O工具。</p>
<p>C++的iostream类库管理了很多细节。例如，在程序中包含iostream文件将自动创建8个流对象(4个用于窄字符流，4个用于宽字符流)：</p>
<ul>
<li>cin对象对应于标准输入流。在默认情况下，这个流被关联到标准输入设备（通常为键盘）。wcin对象与此类似，但处理的是wchar_t类型。</li>
<li>cout对象与标准输出流相对应是。在默认情况下，这个流被关联到标准输出设备(通常为显示器)。wcout对象与此类似，但处理的是wchar_t类型。</li>
<li>cerr对象与标准错误流相对应，可用于显示错误消息。在默认情况下，这个流被关联到标准输出设备(通常为显示器)。这个流没有被缓冲，这意味着信息将被直接发送给屏幕，而不会等到缓冲区填满或新的换行符。wcerr对象与此类似，但处理的是wchar_t类型。</li>
<li>clog对象也对应着标准错误流。在默认情况下，这个流被关联到标准输出设备(通常为显示器)。这个流被缓冲。wclog对象与此类似，但处理的是wchar_t类型。</li>
</ul>
<h3 id="17-2-使用cout进行输出"><a href="#17-2-使用cout进行输出" class="headerlink" title="17.2 使用cout进行输出"></a>17.2 使用cout进行输出</h3><p>如果您是C语言程序员，深受%类型说明符过多，当说明符类型与值不匹配时将发生问题等痛苦，则使用cout非常简单(当然，由于有cin，C++输入也非常简单)。</p>
<p>C++用指向字符串存储位置的指针来表示字符串，对于其它类型的指针，C++将其对应于void *，并打印地址的数值表示。如果要获得字符串的地址，则必须将其强制转换为其它类型。</p>
<p>wirte()方法并不会在遇到空字符时自动停止打印字符，而只是打印指定数目的字符，即使超出了字符串的边界。</p>
<p>由于ostream类对cout对象处理的输出进行缓冲，所以输出不会立即发送到目标地址，而是被存储在缓冲区中，直到缓冲区填满。然后，程序将刷新(flush)缓冲区，把内容发送出去，并清空缓冲区，以存储新的数据。</p>
<p>多数C++实现都会在输入即将发生时刷新缓冲区。</p>
<p>如果实现不能在所希望时刷新输出，可以使用二个控制符中的一个来强行进行刷新。控制符flush刷新缓冲区，而控制符endl刷新缓冲区，并插入一个换行符。这二个控制符的使用方式与变量名相同。实际上，控制符也是函数，如flush()刷新cout缓冲区。</p>
<p>ostream类是从ios类派生而来的，而后者是从ios_base类派生而来的。ios_base类存储了描述格式状态的信息。例如，一个类成员中某些位决定了使用计数系统，而另一个成员则决定了字段宽度。通过使用控制符，可以控制显示整数时使用的计数系统。通过使用ios_base的成员函数，可以控制字段宽度和小数倍数。由于ios_base类是ostream的间接基类，因此可以将其方法用于ostream对象(或子代)，如cout。</p>
<p>三个最常用的控制符分别是setprecision()、setfill()和setw(),它们分别用来设置精度、填充字符和字段宽度。与前面讨论的控制符不同的是，这三个控制符带参数。setprecison()控制符接受一个指定精度的整数参数；setfill()控制符接受一个指定填充字符的char参数；setw()控制符接受一个指定字段宽度的整数参数。 由于它们都是控制符，因此可以用cout语句连接起来。</p>
<h3 id="17-3-使用cin进行输入"><a href="#17-3-使用cin进行输入" class="headerlink" title="17.3 使用cin进行输入"></a>17.3 使用cin进行输入</h3><p>不同版本的读取操作符查看输入流的方法是相同的。它们跳过空白(空格、 换行符和制表符)，直到遇到非空白字符。即使对于单字符模式(参数类型为char、unsigned char和signed char)，情况也是如此，但对于C语言的字符输入函数，情况并非如此。在单字符模式下，&gt;&gt;操作符将读取该字符，将它放置到指定的位置。在其他模式下，&gt;&gt;操作符将读取一个指定类型的数据。也就是说，它读取从非空白字符开始到与目标类型不匹配的第一个字符之间的全部内容。</p>
<p><strong>流状态</strong>(被定义为iostate类型，而iostate是一种bitmask类型)，由3个ios_base元素组成：eofbit、badbit和failbit，其中每个元素都是一位，可以是1（设置）或0（清除）。当cin操作到达文件未必时，它将设置eofbit；当cin操作未能读取到预期的字符时(像前一个例子那样)，它将设置failbit。I/O失败(如试图读取不可访问的文件或试图写入写保护的磁盘)，也可能将failbit设置为1。在一些无法诊断的失败破坏流时，badbit元素将被设置(实现没有必要就哪些情况下设置failbit，哪些情况下设置badbit达成一致)。当全部3个状态位都设置为0时，说明一切顺利。</p>
<h3 id="17-4-文件输入与输出"><a href="#17-4-文件输入与输出" class="headerlink" title="17.4 文件输入与输出"></a>17.4 文件输入与输出</h3><p>C++在头文件fstream(以前为fstream.h)中定义了多个新类，其中包括用于文件输入的ifstream类和用于文件输出的ofstream类。C++还定义了一个fstream类，用于同步文件I/O。这些类都是从头文件iostream中的类派生而来的。</p>
<p>使用文件I/O：</p>
<p><strong>写文件</strong></p>
<ol>
<li>创建一个ofstream对象来管理输出流。首先应包含头文件fstream。</li>
<li>将该对象与特定的文件关联起来。</li>
<li>以使用cout的文件使用该对象，惟一的区别是：输出将进入文件，而不屏幕。</li>
</ol>
<p>对于大多数(但不是全部)实现来说，包含该文件便自动包括iostream文件，因此不必显示包含iostram。然后声明一个ofstream对象<strong>ofstream fout;</strong>。接下来必须将这个对象与特定的文件想关联。为此可以使用open()方法<strong>fout.open(“jar.txt”);</strong>，可以使用另一个构造函数将这二步合并成一条语句<strong>ofstream fout(“jar.txt”);</strong>。以这种方式打开文件来进行输出时， 如果没有这样的文件，将创建一个新文件；如果有这样的文件，则打开文件将清空文件，输出将进入到一个空文件中。以默认模式打开文件进行输出将自动把文件的长度截短为0，这相当于删除已有内容。</p>
<p><strong>读文件</strong></p>
<ol>
<li>创建一个ifstream对象来管理输入流。</li>
<li>将该对象与特定的文件关联起来。</li>
<li>以使用cin的方式使用该对象。</li>
</ol>
<p>当输入和输出流对象过期时，到文件的连接将自动关闭。另外，也可以使用close()方法来显示地关闭到文件的连接<figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以同时打开的文件数取决于操作系统，但通常为20个左右。</div><div class="line"></div><div class="line">**文件模式**：描述的是文件将被如何使用：读、写、追加等。将流与文件关联时(无论是使用文件名初始化文件流对象，还是使用open()方法)，都可以提供指定文件模式的第二个参数：</div><div class="line"></div><div class="line">```C++</div><div class="line">ifstream fin(&quot;banjo&quot;,mode1);   //constructor with mode argument </div><div class="line">ofstream fout();</div><div class="line">fout.open(&quot;harp&quot;,mode2);       //open() with mode arguments</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">常量</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ios_bash::in</td>
<td style="text-align:center">打开文件，以便读取</td>
<td style="text-align:center">ios_bash::app</td>
<td style="text-align:center">追加到文件尾</td>
</tr>
<tr>
<td style="text-align:left">ios_bash::out</td>
<td style="text-align:center">打开文件，以便写入</td>
<td style="text-align:center">ios_bash::trun</td>
<td style="text-align:center">如果文件存在，则截短文件</td>
</tr>
<tr>
<td style="text-align:left">ios_bash::ate</td>
<td style="text-align:center">打开文件，并移到文件尾</td>
<td style="text-align:center">ios_bash::binary</td>
<td style="text-align:center">二进制文件</td>
</tr>
</tbody>
</table>
<p>二进制格式指的是存储值的计算机内部表示。也就是说，计算机不是存储字符，而是存储这个值的64位double表示。对于字符来说，二进制表示与文件表示是一样的，即字符的ASCII码的二进制表示。对于数字来说，二进制的表示与文件表示有很大差别。</p>
<p>文本格式便于读取，可以使用编辑器或字处理器来读取和编辑文本文件，可以很方便地将文本文件从一个计算机系统传输到另一个计算机系统。二进制格式对于数字来说比较精确，因为它存储的是值的内部表示，因此不会有转换误或舍入误差，以二进缺点格式保存数据的速度更快，因为不需要转换，并可以大块地存储数据。二进制格式通常占用的空间较小，这取决于数据的特征。不过，如果另一个系统使用另一种内部表示，则可能无法将数据传输给该系统。同一系统上不同的编译器也可能使用不同的内部结构布局表示。在这种情况下，则必须编写一个将一种数据转换成另一种的程序。</p>
<p>对于二进制数据，文本格式会引起问题，因此double值中间的字节可能与换行符的ASCII码有相同的模式。另外，在文件尾的检测方式也有区别。因此以二进制格式保存数据时，应使用二进制文件模式(UNIX系统只有一种文件模式，因此对于它来说，二进制模式和文本模式是一样的)</p>
<p><strong>随机存取</strong></p>
<p>随机存取指的是直接移动（不是依次移动）到文件的任何位置。随机存取常被用于数据库文件，程序维护一个独立的索引文件，该文件指出数据在主数据文件中的位置。这样，程序便可以直接跳到这个位置，读取（还可能修改）其中的数据。如果文件由长度相同的记录组成，这种方法实现起来最简单。每条记录表示一组相关的数据。</p>
<p>fstream类为此继承了二个方法：seekg()和seekp()，前者将输入指针移到指定的文件位置，后者将输出指针移到指定的文件位置（实际上，由于fstream类使用缓冲区来存储中间数据，因此指向的是缓冲区中的位置，而不是实际的文件）。也可以将seekg()用于ifstream对象，将seekp()用于ofstream对象。</p>
<h3 id="17-5-内核格式化"><a href="#17-5-内核格式化" class="headerlink" title="17.5 内核格式化"></a>17.5 内核格式化</h3><p>iostream族(family)支持程序与终端之间的I/O，而fstream族使用相同的接口提供程序和文件之间的I/O。C++库还提供了sstream族，它们使用相同的接口提供程序和string对象之间的I/O。也就是说，可以使用于cout的ostream方法将格式化信息写入到string对象中，并使用istream方法（如getline())来读取string对象中的信息。读取string对象中的格式化信息或将格式化信息写入string对象中被称为内核格式化(incore formatting)。</p>
<p>sstream头文件定义了一个从ostream类派生而来的ostringstream类（还有一个基于wostream的wostringstream类，这个类用于宽字符集）。如果创建了一个ostringstream对象，则可以将信息写入其中，它将存储这些信息。可以将可用于cout的方法用于ostringstream对象。</p>
<p>istringstream类允许使用istream方法族读取istringstream对象中的数据，istringstream对象可以使用string对象进行初始化。</p>
<p>在用法案例分析中，开发小组列出了常用的方法或预期最终的系统将用于场景；找出元素、操作和职责，以确定可能要使用的类和类特性。CRC卡片是一种分析场景的简单方法。开发小组为每个类创建索引卡片，卡片上列出了类名、类责任（如表示的数据和执行的操作）以及类的合作者（如必须与之交互的其它类）。然后小组使用CRC卡片提供的接口便可以进入场景。</p>
<p>在这方面，最新的工具是统一建模语言（Unified Modeling Language,UML），它不是一种编程语言，而是一种用于表示编程项目的分析和设计的语言，是由Grady Booch、Jim Rumbaugh和Ivar Jacobson开发的，他们分别更早的3种建语言OMT、OOSE的主要开发人员。</p>
<p>缓冲区是内存中的临时存储区域，是程序与文件或其它I/O设备之间的桥梁。信息在缓冲区和文件之间传输时，将使用设备（如磁盘驱动器）处理效率最高的尺寸以大块数据的方式进行传输。信息在缓冲区和程序之间传输时，是逐字节传输的，这种方式对于程序中的处理操作更为方便。</p>
<p>iostream和fstream文件构成了I/O类库，该类库定义了大量用于管理流的类。包含了iostream文件的C++程序将自动打开8个流，并使用8个对象管理它们。cin对象管理标准输入流，后者默认与标准输入设备（通常为键盘）相连；cout对象管理标准输出流，后者默认与标准输出设备（通常为显示器）相连；cerr和clog对象管理与标准错误设备（通常为显示器）相连的未被缓冲的流和被缓冲的流。</p>
]]></content>
    
    <summary type="html">
    
      个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="C++" scheme="http://LySnake.github.io/tags/c/"/>
    
      <category term="C++ Primer Plus" scheme="http://LySnake.github.io/tags/c-primer-plus/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus学习笔记(6)</title>
    <link href="http://LySnake.github.io/archives/technology/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6).html"/>
    <id>http://LySnake.github.io/archives/technology/C++ Primer Plus学习笔记(6).html</id>
    <published>2017-07-05T13:59:27.000Z</published>
    <updated>2018-02-24T13:23:22.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="16-string类和标准模板库"><a href="#16-string类和标准模板库" class="headerlink" title="16 string类和标准模板库"></a>16 string类和标准模板库</h2><h3 id="16-1-string类"><a href="#16-1-string类" class="headerlink" title="16.1 string类"></a>16.1 string类</h3><p>string实际上是模板规范basic_string<char>的一个tyepdef,同时省略了与内存管理相关的参数。</char></p>
<p>第一个限制因素是string对象的最大允许长度，由常量string::npos指定。这通常是最大的unsigned int值或最大的unsigned long值，因此对于普通的交互式输入，这不会带来实际的限制；但如果您试图将整个文件的内容读取到单个string对象中，这可能成为限制因素。第二个限制因素是程序可以使用的内存量。</p>
<p>string版本的getline()函数从输入中读取字符，并将其存储到目标string中，直到发生下列3种情况之一：</p>
<ul>
<li>到达文件尾，在这种情况下，输入流的eofbit将会被设置，这意味着方法fail()和eof()都将返回true;.</li>
<li>遇到分界字符(默认为\n)，在这种情况下，将把分界字符从输入流中删除，但不存储它。</li>
<li>读取的字符数达到最大允许值(string::npos和可供分配的内存字节数中较小的一个)，在这种情况下，将设置输入流failbit，这意味着方法fail()将返回true.</li>
</ul>
<p>输入流对象有一个统计系统，用于跟踪流的错误状态，在这个系统中，检测到文件尾后将设置eofbit寄存器，检测到输入错误时将设置failbit寄存器，一切顺利时将设置goodbit寄存器。</p>
<p>string版本的operator&gt;&gt;()函数的行为与此类似，只是它不断读取，直到遇到空白字符并将其留在输入队列中，而不是不断读取，直到遇到分界字符并将其丢弃。空白字符指的是空格、换行符和制表符，更普遍地说，是任何将其作为参数来调用isspace()时，该函数返回ture的字符。</p>
<p>string库还提供了：删除字符串的部分或分部内容、用一个字符串的部分或全部内容替换另一个字符串的部分或全部内容、 将数据插入到字符串中或删除字符串中的数据、将一个字符串的部分或全部内容与另一个字符串的部分或全部内容进行比较、从字符串中提取子字符串、将一个字符串中的内容复制到另一个字符串中、交换二个字符串的内容。</p>
<p>很多C++ std::string类的实现分配一个比实际字符串大的内存块，为字符串提供了增大空间。然而，如果字符串不断增大，超过了内存块的大小，程序将分配一个大小为原来二倍的新内存块，以提供足够的增大空间，避免不断地分配新的内存块。</p>
<h3 id="16-2-auto-ptr类"><a href="#16-2-auto-ptr类" class="headerlink" title="16.2 auto_ptr类"></a>16.2 auto_ptr类</h3><p>auto_ptr是一个模板类，用于管理动态内存分配的用法。</p>
<p>对于基本类型，并没有提供这种额外服务；但对于类，则可以通过析构函数机制来提供。因此，普通指针的问题在于：它只是一个常规指针，不是类对象。如果它是类是对象，则可以在对象过期时，让它的析构函数删除被指向的内存。这正是auto_ptr背后的思想。</p>
<p>auto_ptr模板定义了类似指针的对象，可以将new获得(直接或间接)的地址赋给这种对象。当auto_ptr对象过期时，其析构函数将使用delete来释放内存。 因此，如果将new返回的地址赋给auto_ptr对象时，无须记住稍后释放这些内存。在auto_ptr对象过期时，这些内在将自动被释放。</p>
<p>auto_ptr是一种智能指针(smart pointer)—类似于指针，但特性比指针更多。auto_ptr类被定义为在很多方面与常规指针类似。例如，如果ps是一个auto_ptr，则可以对它执行解除引用操作(*ps)和递增操作(++ps)，用它来访问结构成员(ps-&gt;puffIndex)，将它赋给指向相同类型的常规指针。</p>
<p>对于new和new[]，必须相应地使用delete和delete[]。auto_ptr模板使用的是delete，而不是delete[]，因此它只能与new一起使用，而不能与new[]一起使用。没有适用于动态数组的auto_ptr等同物。可以复制头文件memory中的auto_ptr模板，将它重命名为auto_arr_ptr，然后对基进行修改，使之使用delete[]，而不是delete。</p>
<p>只以有对new分配的内存使用auto_ptr对象，而不要对由new[]分配的或通过声明变量分配的内存使用它。</p>
<p>智能指针是这样一种类，即其对象的特征类似于指针。例如，智能指针可以存储new分配的内存地址，也可以被解除引用。因为智能指针是一个类对象，因此它可以修改和扩充简单指针的行为。例如，智能指针可以建立引用计数，这样多个对象可共由智能指针跟踪的同一个值。当使用该值的对象数为0时，智能指针将删除这个值。智能指针可以提高内存的使用效率，帮助防止内存泄漏，但并不要求用户熟悉新的编程技术。</p>
<h3 id="16-3-STL"><a href="#16-3-STL" class="headerlink" title="16.3 STL"></a>16.3 STL</h3><p>STL提供了一组表示容器、迭代器、函数对象和算法的模板。容器是一个与数组类似的单元，可以存储若干个值。STL容器是同质的，即存储的值的类型相同；算法是完成特定任务(如对数组进行排序或在链表中查找特定值)的处方；迭代器能够用来遍历容器中的对象，与能够遍历数组的指针类似，是广义的指针；函数对象是类似于函数的对象，可以是类对象或函数指针(包括函数名，因为函数名被用作指针)。STL使得能够构造各种容器(包括数组、队列、链表)和执行各种操作(包括搜索、排序和随机排列)。</p>
<p>STL不是面向对象的编程，而是一种不同的编程模式—通用编程技术。</p>
<p><strong>矢量(vector)</strong>：对应数组，但不是数学矢量，计算矢量存储了一组可随机访问的值，即可以使用索引来直接访问矢量的第10个元素，而不必首先访问前面第9个元素。将一个vector对象赋给另一个对象，使用[]操作符来访问vector元素。要使类成为通用的，应将它设计为模板类。这正是STL所做的工作—在头文件vector中定义了一个模板。</p>
<p><strong>分配器</strong>：各种 STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存。如果未使用该模板参数的值，则容器模板将默认使用allocator<t>类。这个类以标准方式使用new和delete。</t></p>
<p>所有的STL容器都提供了一些基本方法，其中包括size()—返回容器中元素数目、swap()—交换二个容器的内容、begin()—返回一个指向容器中第一个元素的迭代器，end()—返回一个表示超过容器尾的迭代器。</p>
<p><strong>迭代器</strong>：是一个广义的指针，事实上，它可以是指针，也可以是一个可对其执行类似指针的操作—如解引用、和递增操作的对象。稍后将知道，对指向迭代器的指针进行广义化使得STL能够为各种不同的容器类(包括那些简单指针无法处理的类)提供统一的接口。每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为iterator的typedef，其作用域为整个类(模板中嵌套类定义iterator)。</p>
<p><strong>超过结尾(past-the-end)</strong>：它是一种迭代器，指向容器最后一个元素后面的那个元素。这与C-风格字符串最后一个字符后面的空字符类似，只是空字符是一个值，而“超过结尾”是一个指向元素的指针（迭代器）。end()成员函数标识超过结尾的位置。如果将迭代器设置为容器的第一个元素，并不断地递增，则最终它将到达容器结尾，从而遍历整个容器的内容。</p>
<p>push_back()是一个方便的方法，它将元素添加到矢量的末尾。erase()方法删除矢量中给定区间的元素。insert()方法的功能与erase()相反。它接受3个迭代器参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，该区间通常是另一个容器对象的一部分。</p>
<p><strong>算法</strong>：STL从更广泛的角度定义了非成员函数来执行这些操作，即不是为每个容器类定义find()函数，而是定义一个适用于所有容器类的非成员函数find()。这种设计理念省去了大量重复工作。如for_each()函数可用于许多容器类，它接受3个参数。前二个是定义容器中区间的迭代器，最后一个是指向函数的指针（更普遍地说，最后一个参数是一个函数对象）。for_each()函数将被指向的函数应用于容器区间中的各个元素。被指向的函数不能修改容器元素的值。</p>
<h3 id="16-4-通用编程技术"><a href="#16-4-通用编程技术" class="headerlink" title="16.4 通用编程技术"></a>16.4 通用编程技术</h3><p>STL是一种通用编程技术，面向对象编程关注的是编程的数据方面，而通用编程技术关注的是算法。它们之间的共同点是抽象和创建可重用代码，但它们的理念绝然不同。在C++中，完成通用程序的工具是模板。当然，模板使得能够按通用类型定义函数或类，而STL通过通用算法更进一步。</p>
<p>模板使得算法独立于存储的数据类型，而迭代器使得算法独立于使用的容器类型。因此，它们都是STL通用方法的重要组成部分。</p>
<p>即函数不仅独立于容器中存储的数据类型，而且独立于容器本身的数据结构。模板提供了存储在容器中数据类型的通用表示，因此还需要遍历容器中的值的通用表示，迭代器正是这样的通用表示。</p>
<p><strong>为区分++操作符的前缀版本和后缀版本，C++将operator++()作为前缀版本，将operator++(int)作为后缀版本；其中的参数永远也不会被使用到，所以不必指定其名称。</strong></p>
<p>首先，每个容器类(vector、list、deque等)定义了相应的迭代器类型。对于其中的某个类，迭代器可能是指针；而对于另一个类，则可能是对象。不管实现方式如何，迭代器都将提供扬需的操作，如*和++。其次，每个容器类都有一个超尾标记，它们分别返回一个指向超越容器的最后一个值后，这个值将被赋给迭代器，每个容器类都有一个超尾标记，它们分别返回一个指向容器的第一个元素和超尾位置的迭代器。每个容器类都使用++操作，让迭代器从指向第一个元素逐步指向超尾位置，从而遍历容器中每一个元素。</p>
<p>STL通过为每个类定义适当的迭代器，并以统一的风格设计类，能够对内部表示绝然不同的容器，编写相同的代码。</p>
<p>STL定义了5种迭代器，并根据所需的迭代器类型对算法进行了描述。这5种迭代器分别是输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机迭代器。</p>
<p><strong>输入迭代器</strong>：术语“输入”是从程序的角度说的，即来自容器的信息被视为输入，就像来自键盘的信息对程序来说是输入一样。因此，输入迭代器可被程序用来读取容器中的信息。</p>
<p><strong>输入迭代器</strong>：STL使用术语“输出”来指向于将信息从程序传输给容器的迭代器，因此程序的输出就是容器的输入。输出迭代器与输入迭代器相似，只是解除引用让程序能修改容器值，而不能读取。简而言之，对于单通告、 只读算法，可以使用输入迭代器；而对于单通行、只写算法，则可以使用输出迭代器。</p>
<p><strong>正向迭代器</strong>：与输入迭代器和输出迭代器相似，正向迭代器只使用++操作符来遍历容器，所以它每次沿容器向前移动一个元素；不过，与输入和输出迭代器不同的是，它总是按相同的顺序遍历一系列值。另外，将正向迭代器递增后，仍然可以对前面的迭代器值解除引用，并可以得到相同的值。</p>
<p><strong>双向迭代器</strong>：假设算法需要能够双向遍历容器，情况将如何呢？例如，reveerse函数可以交换第一个元素和最后一个元素，将指向第一个元素的指针加1、将指向第二个元素的指针减1，并重复这种处理过程。双向迭代器具有正向迭代器的所有特性，同时支持两种(前缀和后缀)递增操作符。</p>
<p><strong>随机访问迭代器</strong>：随机访问迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针增加运算）和用于对元素进行排序的关系操作符。</p>
<p>为何需要这么多迭代器呢？目的是为了在编写算法时尽可能使用要求最低的迭代器，并让它适用于容器的最大区间。这样，通过使用级别最低的输入迭代器，find()函数便可用于任何包含可读取值的容器。而sort()函数由于需要随机访问迭代器，所以只能用于支持这种迭代器的容器。</p>
<p>迭代器是广义的，而满足所有迭代器要求。迭代器是STL算法的接口，而指针是迭代器，因此STL算法可以使用指针来对基于指针的非STL容器进行操作。</p>
<h3 id="16-4-5-容器各类"><a href="#16-4-5-容器各类" class="headerlink" title="16.4.5 容器各类"></a>16.4.5 容器各类</h3><p>STL具有容器概念和容器类型。概念是具有名称（如容器、序列容器、联合容器等）的通用类别 ；容器类型是可用于创建具体容器对象的模板。11个容器类型分别是deque、list、queue、priority_queue、stack、vector、map、multimap、set、multiset、和bitst。</p>
<p>####　容器概念 ####<br>没有与基本容器概念对应的类型，但概念描述了所有容器类通用的元素。它是一个概念化的抽象基类—说它概念化，是因为容器类并不真正使用继承机制。换句话说，容器概念指定了所有STL容器类都必须满足的一系列要求。</p>
<p>容器是存储其它对象。被存储的对象必须是同一种类型的，它们可以是OOP意义上的对象，也可以是内置类型值。被存储在容器中的数据为容器所有，这意味着当容器过期时，存储在容器中的数据也将过期（不过，如果数据是指针的话，则它指向的数据并不一定过期）。</p>
<p>不有将任何类型的对象存储在容器中，具体地说，类型必须是可复制构造的和可赋值的。基本类型满足这些要求；只要类定义没有将复制构造函数和同仁操作符声明为私有或保护的，则类也满足这种要求。</p>
<h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><p>可以通过添加要求来改进基本的容器的概念。序列是一种重要的改进，因为6种STL容器类型（deque、list、queue、priority_queue、stack和vector）都是序列（队列能够在队尾添加元素，在队首删除元素。Deque表示的双端队列允许在两端添加和删除元素）。序列概念增加了迭代器至少是正向迭代器这样的要求。这保证了元素将按特定的顺序排列，不会在二次迭代之间发生变化。</p>
<p>序列还要求其元素按严格的线性顺序排列，即存在第一个元素、最后一个元素，除第一个元素和最后一个元素外，每个元素前后都分别有一个元素。</p>
<ul>
<li>vector</li>
<li>简单地说，vector是数组的一种表示，它提供了自动内在管理功能，可以动态地改变vector对象的长度，并随着元素的添加和删除而增大和缩小。它提供了对元素的随机访问。在尾部添加和删除元素的时间是固定的，但在头部或中间插入和删除元素的复杂度为线性时间。</li>
</ul>
<p>vector还是可反转容器概念的模型。这增加了二个类方法：rbegin()和rend()，前者返回一个指向反转序列的第一个元素的迭代器，后者返回反转序列的超尾迭代器。vector模板类是最简单的序列类型，除非其他类型的特殊优点能够更好地满足程序的要求，否则应默认使用这种类型。</p>
<ul>
<li>deque</li>
</ul>
<p>deque模板类表示双端队列，通常被简称为deque。在STL中，其实现类似于vector容器，支持随机访问。主要区别在于，从deque对象的开始位置插入和删除的时间是固定的，而不像vector中那样的纯属时间的。所以，如果多数操作发生在序列的超始和结尾处， 则应考虑使用deque数据结构。</p>
<ul>
<li>list</li>
</ul>
<p>list模板类表示双向链表。除了第一个和最后一个元素外，每个元素都与前后的元素相链接，这意味着可以双向遍历链表。list和vector之间的关键区别在于，list在娶个中任一位置进行插入和删除的时间都是固定的(vector模板提供了除结尾处外的线性时间的插入和删除，在结尾处，它提供了固定时间的插入和删除）。因此，vector强调的是通过随机访问进行快速访问，而list强调的是元素的快速插入和删除。</p>
<ul>
<li>queue </li>
</ul>
<p>queue模板类是一个甜酸器类。由前所述，ostream_iterator模板类就是一个适配器，让输出流能够使用迭代器接口。同样，queue模板让底层类展示典型的队列接口。</p>
<h4 id="16-4-6-联合容器"><a href="#16-4-6-联合容器" class="headerlink" title="16.4.6 联合容器"></a>16.4.6 联合容器</h4><p>联合容器是对容器概念的另一个改进。联合容器将值与关键字关联在一起，使用关键字来查找值。</p>
<p>联合容器的长处在于，它提供了对元素的快速访问。与序列相似，联合容器也允许插入新元素，不过不能指定元素的插入位置。原因是联合容器通常包含于确定数据旋转位置的算法，以便能够很快检索信息。</p>
<p>STL提供4种联合容器：set、multiset、map和multimap。前两种是在set头文件中定义的，后两种是在map头文件中定义的。</p>
<p>最简单的簇是set，其值的类型与关键字相同，关键字是惟一的—集合中不会有多个相同的关键字。确实，对于set来说，值就是关键字。multiset类型类似于set,只是前者可能有多个值的关键字相同。</p>
<p>对于map类型来说，值的类型与关键字不同，关键字是惟一的，每个关键字只对应一个值。multimap类型与map相似，只是一个关键字可以与多个值关联。</p>
<ul>
<li>set范例</li>
</ul>
<p>STL set是多个櫂的模型，它是一个联合集合，可反转，可排序，关键字是惟一的，所以它只能存储同一种类型的值。与vector和list相似，set也使用模板参数来提供要存储的值的类型。数学为集合定义了一些标准操作，例如，并集包含二个集合合并后的内容。如果二个集合中包含相同的值，则这个值将在并集中只出现一次，这是因为关键字是惟一的。次包含二个集合公有的元素。二个集合的差是第一个集合减去二个集合公有元素。</p>
<ul>
<li>multmap范例</li>
</ul>
<p>与set相似，multimap也是可反转的，经过排序的联合容器，但在multimap中，关键字的类型与值类型不同，在multimap对象中，特定的关键字可能与多个值相关联。基本的multimap声明使用模板参数指定了关键字的类型和扬存储的值的类型。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">multmap&lt;int,string&gt; codes;</div></pre></td></tr></table></figure></p>
<h3 id="16-5-函数对象"><a href="#16-5-函数对象" class="headerlink" title="16.5 函数对象"></a>16.5 函数对象</h3><p>很多STL算法都使用函数对象—也叫函数符。函数符是可以以函数方式与()结合使用的任意对象。这包括函数名、指向函数的指针和重载了()操作符的类对象(即定义了函数operator()()的类)。</p>
<p>对于STL中的算法<figure class="highlight plain"><figcaption><span>templateObj.end(), ShowReview);```，通常算3个参数可以是常规函数，也可以是函数符。实际上，这提出了一个问题：如何声明第3个参数呢？不能把它声明为函数指针，因为函数指针指定了参数类型。由于容器可以包含任意类型，所以预先是无法知道应使用哪种参数类型的。STL通过使用模板解决了这个问题。for_each的原型看上去就像这样：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```C++</div><div class="line">template&lt;class InputIterator, class Function&gt;</div><div class="line">Function for_each(InputIterator first, InputItertor last, Function f);</div><div class="line"></div><div class="line">void ShowReview(const Review&amp;);</div></pre></td></tr></table></figure></p>
<p>这样，标识符ShowReview的类型为void(*)(const Review &amp;),这也是赋给模板参数Function的类型，对于不同的函数调用，Function参数可以表示具有重载的()操作符的类类型。</p>
<h4 id="16-5-1-函数符的概念"><a href="#16-5-1-函数符的概念" class="headerlink" title="16.5.1 函数符的概念"></a>16.5.1 函数符的概念</h4><p><strong> 函数符的概念 </strong>：</p>
<ul>
<li>生成器是不用参数就可以调用的函数符。</li>
<li>一元函数是用一个参数可以调用的函数符。</li>
<li>二元函数是用二个参数可以调用的函数符。</li>
</ul>
<p>改进版：</p>
<ul>
<li>返回bool值的一元函数是断言。</li>
<li>返回bool值的二元函数是二元断言。</li>
</ul>
<h4 id="16-5-2-预定义的函数符"><a href="#16-5-2-预定义的函数符" class="headerlink" title="16.5.2 预定义的函数符"></a>16.5.2 预定义的函数符</h4><p>STL定义了多个基本函数符，它们执行诸多如将两个值相加、比较两个值是否相等操作。提供这些函数对象是为了支持将函数作为参数的STL函数。对于所有内置的自述操作符、关系操作符和逻辑操作符，STL都提供了等价的函数符。</p>
<h4 id="16-5-3-自适应函数和函数适配器"><a href="#16-5-3-自适应函数和函数适配器" class="headerlink" title="16.5.3 自适应函数和函数适配器"></a>16.5.3 自适应函数和函数适配器</h4><p>自适应生成器、自适应一元函数、自适应二元函数、自适应断言和自适应二元断言，如下表列出的预定义函数都是自适应的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">函数</th>
<th style="text-align:center">操作符</th>
<th style="text-align:center">函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">plus</td>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center">greater</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code>;</td>
<td style="text-align:center">minus</td>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center">less</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">multiplies</td>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">greater_equal</td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center">divides</td>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">less_equal</td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center">modulus</td>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">logical_and</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">negate</td>
<td style="text-align:center"><code>丨丨</code></td>
<td style="text-align:center">logical_or</td>
</tr>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">equal_to</td>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center">logical_not</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">not_equal_to</td>
</tr>
</tbody>
</table>
<p>使用函数符成为自适应的原因是，它携带了标识参数类型和返回值类型的typedef成员。这些成员分别是result_type、first_argument_type和second_argument_type，它们的作用是不言自明的。函数符自适应性的意义在于：函数适配器对象可以使用函数对象，并认为存在这些typedef成员。</p>
<h4 id="16-6-算法"><a href="#16-6-算法" class="headerlink" title="16.6 算法"></a>16.6 算法</h4><p>STL包含了很多处理容器的非成员函数，前面已经介绍过其中的一些：sort()、copy()、find()、random_shuffle()、set_union()、set_intersection()、set_difference()和transform()。可能已经注意到，它们的总体设计是相同的，都使用迭代器来标识要处理的数据敬意和结果的放置位置。有些函数还接受一个函数对象参数，并使用它来处理数据。</p>
<p>对于算法函数设计，有二个主要的通用部分。首先，它们都使用模板来提供通用类型；其次，它们都使用迭代器来提供访问容器中数据的通用表示。因此，copy()函数可用于将double值存储在数组中的容器、将string值存储在链表中容器，也可用于将用户定义的对象存储在树结构中的窗口。因为指针是一种特殊的迭代器，因此诸多copy()等STL函数可用于常规数组。</p>
]]></content>
    
    <summary type="html">
    
      个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="C++" scheme="http://LySnake.github.io/tags/c/"/>
    
      <category term="C++ Primer Plus" scheme="http://LySnake.github.io/tags/c-primer-plus/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus学习笔记(5)</title>
    <link href="http://LySnake.github.io/archives/technology/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5).html"/>
    <id>http://LySnake.github.io/archives/technology/C++ Primer Plus学习笔记(5).html</id>
    <published>2017-07-01T14:28:08.127Z</published>
    <updated>2018-02-24T13:23:05.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="15-友元、异常和其他"><a href="#15-友元、异常和其他" class="headerlink" title="15. 友元、异常和其他"></a>15. 友元、异常和其他</h2><h3 id="15-1-友元类"><a href="#15-1-友元类" class="headerlink" title="15.1 友元类"></a>15.1 友元类</h3><p>将类作为友元，友元类的所有方法都可以访问原始类的私有成员和保护成员。另外，也可以做更严格的限制，只将特定的成员函数指定为另一个类的友元。</p>
<p>友元声明可以位于公有、私有或保护部分，其所在的位置无关紧要。由于友元类中的方法使用了包含类相关信息，所以编译器必须了解包含类后才能处理友元类。</p>
<p>类友元是一种自然用语，用于表示一些关系。如果不使用某些形式的友元关系，则必须将包含类的私有部分设置为公有，或者创建一个笨拙的、大型类来包含这二个类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Tv</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Remote; </div><div class="line">    <span class="comment">//todo</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Remote</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">set_chan</span><span class="params">(Tv &amp;t, <span class="keyword">int</span> c)</span></span>&#123;t.channel = c&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="15-2-友元成员函数"><a href="#15-2-友元成员函数" class="headerlink" title="15.2 友元成员函数"></a>15.2 友元成员函数</h3><p>确实可以选择仅让特定的类成员成为另一个类的友元，而不必让整个类成为友元，不过这样做稍微有点麻烦，必须小心排列各种声明和定义的顺序。为此，将使用前向声明来处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Tv;           <span class="comment">//前向声明</span></div><div class="line"><span class="keyword">class</span> Remote&#123;...&#125;;  <span class="comment">//友元类</span></div><div class="line"><span class="keyword">class</span> Tv&#123;...&#125;;      <span class="comment">//包含类</span></div></pre></td></tr></table></figure>
<p>另外，可以把友元类的成员函数，实现写在Tv类的后边（头文件中），加inline关键字实现成员方法为内联方法，这样，可以让编译器不在类声明中就要知道包含类的过多信息，避免因编译器不知道包含类的成员信息而无法编译。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TVFM_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TVFM_H_</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Tv;   <span class="comment">//前向声明</span></div><div class="line"><span class="keyword">class</span> Remote </div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="keyword">enum</span> &#123;TV&#125;;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">   <span class="keyword">int</span> mode;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   Remote(<span class="keyword">int</span> m =TV):mode(TV)&#123;&#125;</div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">set_mode</span><span class="params">(Tv &amp;t)</span></span>;</div><div class="line">   <span class="keyword">void</span> Remote::set_chan(Tv &amp;t, <span class="keyword">int</span> c);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Tv</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Remote::set_chan(Tv &amp;t, <span class="keyword">int</span> c);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> channel;</div><div class="line"><span class="comment">//todo</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Remote::set_chan(Tv &amp;t, <span class="keyword">int</span> c)&#123;t.channel = c;&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>内联函数的链接性是内部的，这意味着函数定义必须在使用函数的文件中，在这个例子中，内联定义位于头文件中，因此在使用函数的文件中包含头文件可确保将定义放在正确的地方。也可以将定义放在实现文件中，但必须删除关键字inline，这样函数的链接性将是外部的。</p>
<h3 id="15-1-3-其他友好关系"><a href="#15-1-3-其他友好关系" class="headerlink" title="15.1.3 其他友好关系"></a>15.1.3 其他友好关系</h3><p><strong>二个类相互成为友元</strong>：当二个类都要相互修改另一个类的成员信息时。</p>
<p><strong>共同的友元</strong>：函数需要访问二个类的私有数据。从逻辑上看，这样的函数应是每个类的成员函数，但这是不可能的，它可以是一个类的成员，同时是另一个类的友元，不过有时将函数作为二个类的友元更合理。</p>
<h3 id="15-2-嵌套类"><a href="#15-2-嵌套类" class="headerlink" title="15.2 嵌套类"></a>15.2 嵌套类</h3><p>在C++中，可以将类声明放在另一个类中。在另一个类中声明的类被称为嵌套类，它通过提供新的类型类作用域来避免名称混乱。包含类的成员函数可以创建和使用被嵌套类的对象；而声明位于公有部分，才能在包含类的外面使用嵌套类，而且必须使用作用域解析操作符。</p>
<p>对类进行嵌套与包含并不同。包含意味着将类对象作为另一个类的成员，而对类进行嵌套不创建类成员，而是定义了一种类型，该类型仅在包含嵌套类声明的类中有效。</p>
<p>由于结构体是一种其成员在默认情况下为公有的类，所以Node结构体实际上是一个嵌套类，但该定义并没有充分利用类的功能。具体地说，它没有显式构造函数。可以如下添加：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Queue</div><div class="line">&#123;</div><div class="line">	<span class="keyword">class</span> Node</div><div class="line">	&#123;</div><div class="line">	 <span class="keyword">public</span>:</div><div class="line">     	Item item;</div><div class="line">		Node* next;</div><div class="line">		Node(<span class="keyword">const</span> Item &amp;i):item(i),next(<span class="number">0</span>)&#123;&#125;</div><div class="line">	&#125;;</div><div class="line"><span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="15-2-1-嵌套类和访问权限"><a href="#15-2-1-嵌套类和访问权限" class="headerlink" title="15.2.1 嵌套类和访问权限"></a>15.2.1 嵌套类和访问权限</h3><p>嵌套类的声明位置决定了嵌套类的作用域，即它决定了程序的哪些部分可以创建这种类的对象。其次，和其他类一样，嵌套类的公有部分、保护部分和私有部分控制了对类成员的访问。</p>
<p>如果嵌套类是在另一个类的私有部分声明的，则只有后者知道它。另外，类的成员的默认访问权限是私有的。</p>
<p>如果嵌套类是在另一个类的保护部分声明的，则它对于后者来说是可见的，但是对于外部世界则是不可见的。不过，在这种情况中，派生类将知道嵌套类，并可以直接创建这种类型的对象。如果嵌套类是在另一个类的公有部分声明的，则允许后者、后者的派生类以及外部世界使用它，因为它是公有的。不过，由于嵌套类的作用域为包含它的类，因此外部世界使用它时，使用类限定符。</p>
<p>嵌套结构和枚举的作用域有些相同。其实，很多程序员都使用公有枚举来提供可供客户程序员使用的类常数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">声明位置</th>
<th style="text-align:center">包含它的类是否可以使用它</th>
<th style="text-align:center">从包含它的类派生而来的类是否可以使用它</th>
<th style="text-align:center">外部世界是否可以使用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">私有部分</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">保护部分</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">公有部分</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是，通过类限定符来使用</td>
</tr>
</tbody>
</table>
<h3 id="15-2-2-模板中的嵌套"><a href="#15-2-2-模板中的嵌套" class="headerlink" title="15.2.2 模板中的嵌套"></a>15.2.2 模板中的嵌套</h3><p>STL中的迭代器就是通过模板中嵌套类定义实现的，并且可以与包含模板使用同样的类型作为参数而不用再使用template声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> QUEUETP_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUETP_H_</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</div><div class="line"><span class="keyword">class</span> QueueTP</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">enum</span>&#123;Q_SIZE = <span class="number">10</span>&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">class</span> Node</div><div class="line">	&#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">	    Item item;</div><div class="line">	    Node *next;</div><div class="line">	    Node(<span class="keyword">const</span> Item &amp;i):item(i),next(<span class="number">0</span>)&#123;&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">//todo</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h3 id="15-3-异常"><a href="#15-3-异常" class="headerlink" title="15.3 异常"></a>15.3 异常</h3><p>程序有时会遇到运行阶段的错误，导致程序无法正常地运行下去。例如，程序可能试图打开一个不可用的文件，请求过多的内存，或者遭遇不能容忍的值。通常，程序员都会试图避免这种意外的情况。C++异常为处理这种情况提供了一种功能强大而灵活的工具。有些编译器默认关闭这种特性，可能需要使用编译器选项来启用它。</p>
<p>abort()函数的原型位于头文件cstdlib（或stdlib.h)中，其典型实现是向标准错误流(即cerr使用的错误流)发送消息abnormal program termination (程序异常终止)，然后终止程序。它还返回一个随实现而异的值，告诉操作系统（如果程序是由另一个程序调用的，则告诉父进程），处理失败。abort()是否刷新文件缓冲区（用于存储读写到文件中的数据的内存区域）取决于实现。</p>
<h3 id="15-3-3-异常机制"><a href="#15-3-3-异常机制" class="headerlink" title="15.3.3 异常机制"></a>15.3.3 异常机制</h3><p>C++异常是对程序运行过程中发生的异常情况（例如被0除）的一种响应。异常提供了将控制权从程序的一个部分传递到另一部分的途径。对异常的处理有3个组成部分：</p>
<ul>
<li>引发异常</li>
<li>捕获有处理程序的异常</li>
<li>使用try块</li>
</ul>
<p>throw语句实际上是跳转，即命令程序跳到另一条语句。throw关键字表示引发异常，紧随其后的值（例如字符串或对象）指出了异常的特征。</p>
<p>程序使用异常处理程序来捕获异常，异常处理程序位于要处理问题的程序中。catch关键字表示捕获异常。处理程序以关键字catch开头，随后是位于括号中的类型声明，它指出了异常处理程序要响应的异常类型。然后是一个用花括号括起的代码块，指出要采取的措施。catch关键字和异常类型用作标签，指出当异常被引发时，程序应跳到这个位置执行。异常处理程序也被称为catch块。</p>
<p>try块标识其中特定的异常可能被激活的代码块，它后面跟一个或多个catch块。try块是由关键字try指示的，关键字try的后面是一个由花括号括起的代码块，表明需要注意这些代码引发的异常。</p>
<p>如果try块中某条语句导致异常被引发，则后面的catch块将对异常进行处理。如果程序在try块的外面产生异常，将无法被catch捕获。</p>
<p>异常类型可以是字符串或其它C++类型，通常为类类型。执行throw语句类似执行返回语句，因为它也将终止函数的执行，但throw不是将控制权返回给调用程序，而是导致程序沿函数调用序列后退，直到找到包含try块的函数。</p>
<p>关键字catch表明这是一个处理程序，而chatch(type &amp;value)中的type则表明该处理程序与type类型异常匹配，value与函数参数定义极其相似，因为匹配的类型对象将被赋给value。另外，当异常与该处理程序匹配时，程序将执行括号中的代码。</p>
<p>执行完try块中的语句后，如果没有引发任何异常，则程序跳过try块后面的catch块，直接执行处理程序后面的第一条语句。</p>
<p>如果函数引发了异常，而没有try块或没有匹配的处理程序时，在默认情况下，程序最终将调用abort()函数，但可以修改这种行为。</p>
<p>通常，引发异常的函数将传递一个对象，这样做的主要优点之是，可以使用不同的类型来区分不同的函数在不同情况下引发的异常。另外，对象可以提供信息，程序员可以根据这些信息来确定引发异常的原因，同是，catch块可以根据这些信息来决定采取什么样的措施。</p>
<p>可使用异常规范对函数定义进行限定，指出它将引发哪些类型的异常。为此，可在函数定义的后面加上异常规范，它由关键字throw和异常类型列表组成，异常类型列表被括在括号中，并用逗号分隔。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//异常规范</span></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">hmean</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> <span class="title">throw</span><span class="params">(bad_hmean)</span></span>;</div></pre></td></tr></table></figure>
<p>这完成了二项工作，首先，它告诉编译器，该函数引发哪些类型的异常。如果以后该函数引发了其他类型的异常，程序(最终)将调用abort()函数，对这种越权做出反应。其次，使用异常规范将提醒阅读该原型的人，该函数引发异常，应提供try块和处理程序。对于引发多种异常的函数，可提供一个由逗号分隔的异常类型列表。这种句法与函数原型参数列表句法类似。如果异常规范中的括号内为空，则表明该函数不会引发异常。</p>
<p>C++通常通过将信息放在堆栈中来处理函数调用，具体地说，程序将调用函数的指令的地址(返回地址)放到堆栈中。当被调用的函数执行完毕后，程序将使用该地址来确定从哪里开始继续执行。另外，函数调用将函数参数放到堆栈中。 在堆栈中，这些函数参数被视为自动变量。如果被调用的函数创建了新的自动变量，则这些变量也将被添加到堆栈中。如果被调用的函数调用了另一个函数，则后者的信息将被添加到堆栈中，依此类推。当函数结束时，程序流将跳到该函数被调用时存储的地址处，同时堆栈顶端的元素被释放。因此，函数通常都返回到调用它的函数，依此类推，同时每个函数都在结束时释放其自动变量。如果自动变量是类对象，则类的析构函数(如果有的话–&gt;只有需要的时候编译器才会创建)将被调用。</p>
<p>现在假设函数由于出现异常(而不是由于返回)而终止，则程序也将释放堆栈中的内存，但不会在释放堆栈的第一个返回地址后停止，而是继续释放堆栈，直到找到一个位于try块中的返回地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句，这个过程被称为堆栈解退。引发机制的一个非常重要的特性是，和函数返回一样，对于堆栈中的自动类对象，类的析构函数将被调用。不过函数返回仅仅处理该函数放在堆栈中的对象，而throw语句则处理try块和throw之间整个函数调用序列放在堆栈中的对象。如果没有堆栈解退这种特性，则引发异常后，对于中间函数调用放在堆栈中的自动类对象，其析构函数将不会被调用。</p>
<p>程序进行堆栈解退以回到能够捕获异常的地方时，将释放堆栈中的自动存储型变量。如果变量是类对象，将为该对象调用析构函数。</p>
<p>普通函数中，返回语句将控制权返回到调用函数，但throw语句将控制权向上返回到第一个这样的函数：包含能够捕获相应异常的try-catch组合。</p>
<p>catch中的类型变量，使用的是throw的类型变量的一个副本，因为自动变量将会释放。</p>
<p>throw语句将生成拷贝，为何代码中使用引用呢？毕竟将引用作为返回值的通常原因是避免创建拷贝以提高效率。答案是，引用还有另一个重要牲：基类引用可以执行派生类对象，假设有一组通过继承关联起来的异常类型，则在异常规范中只需列出一个类型引用，它将与任何派生类对象匹配。</p>
<p>如果有一个异常类继承层次结构，应这样排列catch块：将捕获位于层次结构最下面的异常类的catch语句放在最前面，将捕获基类异常的catch语句放在最后面。</p>
<h3 id="15-3-7-exception"><a href="#15-3-7-exception" class="headerlink" title="15.3.7 exception"></a>15.3.7 exception</h3><p>C++异常的主要目的是为设计容错程序提供语言级支持，即异常使得在程序设计中包含错误处理功能更容易，以免事后采取一些严格的错误处理方式。异常的灵活性和相对方便性激励着程序员在条件允许的情况下在程序设计中加入错误处理功能。简而言之，异常是这样的一种特性：类似于类，可以改变您的编程方式。</p>
<p>为支持该语言，exception头文件(以前为exception.h或except.h)定义了exception类，C++可以把它用作其他异常类的基类。代码可以引发exception异常，也可以将exception类用作基类。有一个名为what()的虚拟成员函数，它返回一个字符串，该字符串的特征随实现而异，然而，由于这是一个虚方法，因此可以从exception派生而来的类中重新定义它。</p>
<p>C++库定义了很多基于exception的异常类型。头文件exception提供了bad_exception，供函数unexpected()使用。</p>
<p>头文件stdexcept定义了其他几个异常类，首先，该文件定义了logic_error和runtime_error类，它们都是以公有方式从exception派生而来的。</p>
<p><strong>下溢错误</strong>：下溢错误在浮点数计算中，一般而言，存在浮点类型可以表示的最小非零值，计算结果比这个值还小时将导致下溢错误。整形和浮点型都可能发生上溢错误，当计算结果超过了某种类型能够表示的最大数量级时，将发生上溢错误。计算结果可能不在函数允许范围之内，但没有发生上溢或下溢错误，在这种情况下，可以使用range_error异常。</p>
<p>对于处理使用new时可能出现的内存分配问题，C++提供了二种可供选择的方式。第一种方式（一度是惟一的方式）是，让new在无法满足内存请求时返回一个空指针；第二种方式是，让new引发bad_alloc异常。new文件(以前为new.h)中包含了bad_alloc类的声明，它是从exception类公有派生而来的。实现只能提供一种方式，但也可以使用编译器开关或其它一些方法，让编程都能够选择喜欢的方式。</p>
<p>异常、类和继承以三种方式相互关联。首先，可以像标准C++库所做的那样，从一个异常类派生出另一个；其次，可以在类定义中嵌套异常类声明来组合异常；第三，这种嵌套声明本身可被继承，还可用作基类。</p>
<p>C++规定， 在派生类中重新定义基类的方法时，函数特征标必须相同，但返回类型可以不同，条件是派生类方法的返回类型是直接或间接地从基类方法的返回类型派生而来的。这种规则也适用于异常规范。派生类方法的异常规范必须与基类方法相同，或者使用的类型是直接或间接从基类方法的异常规范中使用的类型派生而来的。</p>
<h3 id="15-3-9-异常何时会迷失方向"><a href="#15-3-9-异常何时会迷失方向" class="headerlink" title="15.3.9 异常何时会迷失方向"></a>15.3.9 异常何时会迷失方向</h3><p>异常被引发后，在二种情况下，会导致问题。首先，如果它是在带异常规范的函数中引发的，则必须与规范列表中的某种异常匹配(在继承层次结构中，类类型与这个类及其派生类的对象匹配)，否则称为意外异常。在默认情况下，这将导致程序异常终止。如果异常不是在函数中引发的(或者函数没有异常规范)，则它必须被捕获。如果没有被捕获(在没有try块或没有匹配的catch块时，将出现这种情况)，则异常被称为未捕获异常。在默认情况下，这将导致程序异常终止。不过，可以修改程序对意外异常和未捕获异常的反应。</p>
<p>未捕获异常不会导致程序立刻终止。相反，程序将首先调用函数terminate()。在默认情况下，terminate()调用abort()函数。可以指定terminate()应调用的函数(而不是abort())来修改terminate()的这种行为。 为此，可调用set_terminate()函数。set_terminate()函数和terminate()都是在头文件exception中声明的。</p>
<p>原则上，异常规范应包含函数调用的其他函数引发的异常。</p>
<p>使用异常会增加代码，降低程序的运行速度。异常规范不适用于模板，因为模板函数引发的异常可能随特定的具体化而异。异常和动态内在分配不能总是协同工作。</p>
<p>简而言之，虽然异常处理对于某些项目极为重要，但它也会增加编程的工作量、增大程序、降低程序的速度。另外，编译器对异常的支持以及用户的经验还没有达到成熟的程度，所以应有节制地使用这种特性。</p>
<h3 id="15-4-RTTI"><a href="#15-4-RTTI" class="headerlink" title="15.4 RTTI"></a>15.4 RTTI</h3><p>RTTI是运行阶段类型识别(Runtime Type Identification)的简称。这是新添加到C++中的特性之一，很多老式实现并不支持。另一些实现可能包含开关RTTI的编译器设置。RTTI旨在为程序在运行阶段确定对象的类型提供一种标准方式。</p>
<p>为何要知道类型？可能希望调用类方法的正确版本，在这种情况下，只要该函数是类层次结构中所有成员都拥有的虚函数，则并不真正需要知道对象的类型。但派生对象可能包含不是继承而来的方法，在这种情况下，只有某些类型的对象可以使用该方法。也可能是出于调用目的，想跟踪生成的对象的类型。</p>
<h3 id="15-4-2-RTTI的工作原理"><a href="#15-4-2-RTTI的工作原理" class="headerlink" title="15.4.2 RTTI的工作原理"></a>15.4.2 RTTI的工作原理</h3><p>C++有3个支持RTTI的元素：</p>
<ul>
<li>如果可能的话，dynamic_cast操作符将使用一个指向基类的指针来生成一个指向派生类的指针；否则，该操作符返回0–空指针。</li>
<li>typeid操作符返回一个指出对象的类型的值。</li>
<li>type_info结构存储了有关特定类型的信息。</li>
</ul>
<p>只能将RTTI用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才应该将派生对象的地址赋给基类的指针。</p>
<p><strong>dynamic_case操作符</strong>：</p>
<p>dynamic_cast操作符是最常用的RTTI组件。它不能回答“指针指向的是哪类对象”这样的问题，但能够回答“是否可以安全地将对象的地址赋给特定类型的指针”这样的问题。</p>
<p>通常想知道类型的原因在于：知道类型后，就可以知道调用特定的方法是否安全。要调用方法，类型并不一定要完全匹配，而可以是定义了方法的虚拟版本的基类类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//指针pg的类型是否可被安全地转换为Superb *?如果可以，操作符将返回对象的地址，否则返回一个空指针。</span></div><div class="line">Superb *pm = dynamic_case&lt;Superb *&gt; (pg);</div></pre></td></tr></table></figure>
<p>编译器支持RTTI，在默认情况下，它也可能关闭该特性。如果该特性被关闭，程序可能仍能够通过编译，但将出现运行阶段错误。在这种情况下，读者应查看文档或菜单选项。</p>
<p>也可以将dynamic_cast用于引用，其用法稍微有点不同：没有与空指针对应的引用值，因此无法使用特殊的引用值来指示失败。当请求不正确时，dynamic_cast将引发类型为bad_cast的异常，这种异常是从exception类派生而来的。它是在头文件typeinfo中定义。</p>
<p><strong>typeid操作符和type_info类</strong>：</p>
<p>typeid关键字使得能够确定二个对象是否为同种类型。它与sizeof有些想像，可以接受二种参数：</p>
<ul>
<li>类名。</li>
<li>结果为对象的表达式。</li>
</ul>
<p>typeid操作符返回一个对type_info对象的引用，其中，type_info是在头文件typeinfo(以前为typeinfo.h)中定义的一个类。type_info类重载了==和!=操作符，以便可以使用这些操作符来对类型进行比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeid</span>(ClassName) == <span class="keyword">typeid</span>(Obj)</div></pre></td></tr></table></figure>
<h3 id="15-5-类型转换操作符"><a href="#15-5-类型转换操作符" class="headerlink" title="15.5 类型转换操作符"></a>15.5 类型转换操作符</h3><ul>
<li>dynamic_cast </li>
<li>const_cast</li>
<li>static_cast</li>
<li>reinterpret_cast</li>
</ul>
<p><strong>dynamic_cast</strong>操作符使得能够在类层次结构中进行向上转换(由于is-a关系，这样的类型转换是安全的），而不允许其它转换。</p>
<p><strong>const_cast</strong>操作符用于执行只有一种用途的类型转换，即改变值为const或volatile。</p>
<p><strong>static_cast</strong>:<code>static_cast&lt; type-name&gt; (expression)</code>仅当type_name可被隐匿转换为expression所属的类型或expression可被隐匿转换为type_name所属的类型时，上述转换才是合法的，否则将出错。</p>
<p><strong>reinterpret_cast</strong>操作符用于天生危险的类型转换。它不允许删除const，但会执行其他令人生厌的操作。有时程序员必须做一些依赖于实现的、令人生厌的操作，使用reinterpret_cast操作符可以简化对这种行为的跟踪工作。然而，reinterprete_cast操作符并不支持所有的类型转换。例如，可以将指针类型转换为足以存储指针表示的整形，但不能将指针转换为更小的整形或浮点型，另一个限制是，不能将函数指针转换为数据指针，反之亦然。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>类可以将其他函数，其他类和其他类的成员函数作为友元。在某些情况下，可能需要使用前向声明，需要特别注意类和方法声明的顺序，以正确地组合友元。</p>
<p>嵌套类是在其他类中声明的类，它有助于设计这样的助手类，即实现其他类，但不必是公有接口的组成部分。</p>
<p>C++异常机制为处理拙劣的编程事件，如不适当的值、I/O失败等，提供了一种灵活的方式。引发异常将终止当前执行的函数，将控制权付给匹配的catch块。catch块紧跟在try块后面，为捕获异常，直接或间接导致的函数调用必须位于try块中。这样的程序将执行catch块中的代码。这些代码试图解决问题或终止程序。类可以包含嵌套的异常类，嵌套异常类在相应的问题被发现时将被引发。函数可以包含异常规范，指出在该函数中可能引发的异常。未被捕获的异常(没有匹配的catch块的异常)在默认情况下将终止程序，意外异常也是如些。</p>
<p>RTTI特性让程序能够检测对象的类型。dynamic_cast操作符用于将派生类指针转换为基类指针，其主要是确保可以安全地调用虚函数。typeid操作符返回一个type_info对象。可以对二个typeid的返回值进行比较，以确定对象是否为特定的类型，而返回的type_info对象可用于获得关于对象的信息。</p>
]]></content>
    
    <summary type="html">
    
      个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="C++" scheme="http://LySnake.github.io/tags/c/"/>
    
      <category term="C++ Primer Plus" scheme="http://LySnake.github.io/tags/c-primer-plus/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus学习笔记(4)</title>
    <link href="http://LySnake.github.io/archives/technology/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4).html"/>
    <id>http://LySnake.github.io/archives/technology/C++ Primer Plus学习笔记(4).html</id>
    <published>2017-06-19T14:28:39.997Z</published>
    <updated>2018-02-24T13:22:55.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="14-C-中的代码重用"><a href="#14-C-中的代码重用" class="headerlink" title="14 C++中的代码重用"></a>14 C++中的代码重用</h2><h3 id="14-1-包含对象成员的类"><a href="#14-1-包含对象成员的类" class="headerlink" title="14.1 包含对象成员的类"></a>14.1 包含对象成员的类</h3><p><strong>has-a</strong>:本身是另一个类的对象的成员变量。这种方法称为包含、组合或层次化。另一种方法是通过私有或保护继承。获得接口是is-a关系的组成部分。而使用组合，类可以获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。</p>
<p><strong>多重继承</strong>：使得能够使用两个或更多的基类派生出来新的类，将基类的功能组合在一起。</p>
<p>模板特性意味着声明对象时，必须指定具体的数据类型。</p>
<p>对于继承的基类对象部分，构造函数在成员初始化列表中使用类名来调用特定的基类构造函数。对于成员对象，在成员初始化列表中使用成员名调用构造函数。C++要求在构建对象的其它部分之前，先构建继承对象的所有成员对象。因此，如果初始化列表未显式初始化成员对象，C++将使用成员对象类的默认构造函数。</p>
<h3 id="14-2-私有继承"><a href="#14-2-私有继承" class="headerlink" title="14.2 私有继承"></a>14.2 私有继承</h3><p>C++还有另一种实现has-a关系的途径–私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。</p>
<p>使用公有继承，基类的公有方法将成为派生类的公有方法。简而言之，派生类将继承基类的接口：这是is-a关系的一部分。使用私有继承，基类的公有方法将成为派生类的私有方法，简而言之，派生类不继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。</p>
<p>包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。</p>
<p>当在头文件使用class声明派生类时，如果没有使用public等关键字声明如何继承基类，则以默认以private方式继承。</p>
<p>使用多个基类的继承被称为多重继承（multiple inheritance,MI）.</p>
<p>对于继承基类的对象部分，使用初始化列表方法，使用基类的构造函数初始化基类的对象部分。</p>
<p>私有继承时，通过强制类型转换访问基类对象部分。</p>
<p>用类名显式地限定函数名不适合于友元函数，这是因为友元不属于类。不过，可以通过显式地转换为基类来调用正确的函数。在私有继承中，在不进行显式类型转换的情况下，不能将指向派生类的引用或指针赋给基类引用或指针(基类公有方法通过私有继承成为派生类的私有方法，不具有is-a关系)。另外，由于派生类使用的是多继承，编译器将无法确定应转换成哪个基类，如果两个基类都提供了相同的函数。</p>
<p>类声明中包含表示被包含类的显式命名对象，代码可以通过名称引用这些对象，而 使用继承将使关系更抽象。其次，继承会引起许多问题，尤其从多个基类继承时，可能必须处理许多问题，例如包含同名方法的独立的基类，或共享祖先的独立的基类。另外，包含能够包括多个同类的子对象。如果某个类需要3个string对象，可以使用包含声明3个独立的string成员。而继承则只能使用一个这样的对象(当对象都没有名称时，将难以区分)。</p>
<p>类包含保护成员(可以是数据成员，也可以成员函数)，则这样的成员在派生类中是可用的，但在继承层次结构外是不可用的。如果使用组合将这样的类包含在另一个类中，则后者将不是派生类，而是位于继承层次结构之外，因此不能访问保护成员。但通过继承得到的将是派生类，因此它能够访问保护成员。另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是公有的。(通常，应使用包含建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承)</p>
<h3 id="14-3-保护继承"><a href="#14-3-保护继承" class="headerlink" title="14.3 保护继承"></a>14.3 保护继承</h3><p>保护继承是私有继承的变体。保护继承在列出基类时使用关键字protected.</p>
<p>使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员。和私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的。当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别便呈现出来了。使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的公有方法在派生类中将变成私有方法；使用保护继承时，基类的公有方法在第二代中将变成受保护的，因此第三代派生类可以使用它们。</p>
<table>
<thead>
<tr>
<th style="text-align:center">特征</th>
<th style="text-align:center">公有继承</th>
<th style="text-align:center">保护继承</th>
<th style="text-align:center">私有继承</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">公有成员变成</td>
<td style="text-align:center">派生类的公有成员</td>
<td style="text-align:center">派生类的保护成员</td>
<td style="text-align:center">派生类的私有成员</td>
</tr>
<tr>
<td style="text-align:center">保护成员变成</td>
<td style="text-align:center">派生类的保护成员</td>
<td style="text-align:center">派生类的保护成员</td>
<td style="text-align:center">派生类的私有成员</td>
</tr>
<tr>
<td style="text-align:center">私有成员变成</td>
<td style="text-align:center">只能通过基类接口访问</td>
<td style="text-align:center">只能通过基类接口访问</td>
<td style="text-align:center">只能通过基类接口访问</td>
</tr>
<tr>
<td style="text-align:center">能否隐式向上转换</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是（但只能在派生类中）</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p><strong>将函数调用包装在另一个函数调用中，即使用一个using声明（就像名称空间那样）来指出派生类可以使用特定的基类成员(使用using声明基类成员函数的作用域)，即使采用的私有派生。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Student: <span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span> ,<span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;</div><div class="line">&#123;</div><div class="line">   pulibc:</div><div class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::min; </div><div class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::min;</div><div class="line">   <span class="comment">//something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>using声明只使用成员名—没有圆括号、函数牲标和返回类型。using声明只适用于继承，而不适用于包含。</p>
<h3 id="14-3-多重继承"><a href="#14-3-多重继承" class="headerlink" title="14.3 多重继承"></a>14.3 多重继承</h3><p>MI描述的是有多个直接基类的类。与单继承一样，公有MI表示的也是is-a关系。必须使用关键字public来限定每一个类。这是因为除非特别指出，否刚编译器将使用默认的私有派生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Worker&#123;&#125;;</div><div class="line"><span class="keyword">class</span> Singing :<span class="keyword">public</span> Worker&#123;&#125;;</div><div class="line"><span class="keyword">class</span> Waiter  :<span class="keyword">public</span> Worker&#123;&#125;;</div><div class="line"><span class="keyword">class</span> SSingingWaiter :<span class="keyword">public</span> Singing, <span class="keyword">public</span> Waiter&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//示例</span></div><div class="line">SingingWaiter ed;</div><div class="line"><span class="comment">//有歧义</span></div><div class="line">Worker * pw = &amp;ed;</div><div class="line"><span class="comment">//正确方式</span></div><div class="line">Worker *pw1 = (Waiter *)&amp;ed;</div><div class="line">Worker *pw2 = (Singing *)&amp;ed;</div></pre></td></tr></table></figure>
<p>通常这种赋值将反基类指针设置为派生对象中的基类的地址。但ed中包含两个Worker对象，有两个地址可供选择，所以应使用类型转换来指定对象。这将使得基类指针来引用不同的对象(多态性)复杂化。</p>
<p>当C++引入多重继承的同时，它引入了一种新技术—虚基类(virtual base class)，使MI成为可能。</p>
<p><strong>虚基类</strong>：虚基类使得从多个类(它们的基类相同)派生出的对象只继承一个基类对象。从本质上说，继承的Singing和Waiter对象共享一个Worker对象，而不是各自引入自己的Worker对象的拷贝。因为SingingWaiter现在只包含一个Worker对象。所以可以使用多态。</p>
<p>为什么不抛弃将基类声明为虚拟的这种方式，而使虚拟行为成为MI准则呢？第一，在一些情况下，可能需要基类的多个拷贝；第二，将基类作为虚拟的要求程序员完成额外的计算，为不需要的工具付出代价是不应该的；</p>
<p>使用虚基类时，需要对类构造函数采用一种新的方法。对于非虚基类，惟一可以出现在初始化列表中的构造函数是相临基类构造函数。但这些构造函数可能需要将信息传递给其基类。C++在基类是虚拟时，禁止信息通过中间类自动传递给基类，可以在初始化列表中使用基类的基类的构造函数，来完成祖父虚拟基类对象部分的初始化(非虚拟基类不可使用该方法)。</p>
<p>在祖先相同时，使用MI必须引入虚基类，并修改构造函数初始化列表的规则。另外，如果在编写这些类时没有考虑到MI，则还可能需要重新编写它们。</p>
<p>如果基类是虚基类，派生类将包含基类的一个子对象；如果基类不是虚基类，派生类将包含多个子对象。当虚 基类和非虚基类混合时，情况将如何呢？如：假设类B被用作类C和D的虚基类，同时被用作类X和Y的非虚基类，而类M是从C、D、X和Y派生而来的。在这种情况下，类M从虚拟派生祖先（即类C和D）那里共继承了一个B类子对象，并从每一个非虚拟派生祖先（即类X和类Y）分别继承了一个B类子对象。因此，它包含三个B类子对象。当类通过多条虚拟途径和非虚拟途径继承某个特定的基类时，该类将包含一个表示所有的虚拟途径的基类子对象和分别表示各条非虚拟途径的多个基类子对象。</p>
<p>使用虚基类将改变C++解析二义性的方式。使用非虚基类时，规则很简单。如果类从不同的类那里继承了两个或更多的同名成员，则使用该成员名时，如果没有用类名进行限定，将导致二义性。但如果使用的是虚基类，则这样做不一定会导致二义性。在这种情况下，如果某个名称优先于其它所有名称，则使用它时，即便不使用限定符也不会导致二义性。</p>
<p>从虚基类的一个或多个实例派生而来的类将只继承了一个基类对象。</p>
<ul>
<li>有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数，这对于间接非虚基类来说是非法的。</li>
<li>能过优先规则解决名称二义性。（派生类中的名称优先于直接或间接祖先类中的相同名称）</li>
</ul>
<h3 id="14-4-1-定义类模板"><a href="#14-4-1-定义类模板" class="headerlink" title="14.4.1 定义类模板"></a>14.4.1 定义类模板</h3><p>模板提供参数化类型，即能够将类型名作为参数传递给接收方来建立类或函数。使用模板成员函数替换原有类的类方法，每个函数头都将以相同的模板声明打头。</p>
<p>和模板函数一样，模板类以下面这样的代码开：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class</span> Stack</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Stack&lt;Type&gt;作限定符</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">void</span> Stack&lt;Type&gt;::count()&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>其中，Stack<classname>作为类型，如果在类声明中定义了方法（内联定义），则可以活力模板前缀和类限定符(Stack<type>)。</type></classname></p>
<p>模板的具体实现—例如用来处理string对象的堆栈类—被称为实例化或具体化。除非编译器实现了新的export关键字，否则将模板成员函数旋转在一个独立的实现文件中将无法运行。因为模板不是函数，它们不能编译。模板必须与特定的模板实例化请求一起使用。为此，最简单的方法是将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件。</p>
<p>注意，必须显式地提供所需的类型，这与常规的函数模板是不同的，因为编译器可以根据函数的参数类型来确定要生成哪种函数。</p>
<p>任县指针堆栈的方法之一是，让调用程序提供一个指针数组，基中每个指针都指向不同的字符串，反这些指针放在堆栈中是有意义的，因为每个指针都将指向不同的字符串。</p>
<p>模板常被用作窗口类，这是因为类型参数的概念非常适合于将相同的存储方案用于不同类型。</p>
<p><strong>表达式参数</strong>：指定特殊的类型而不是用作通用类型名，称为非类型或表达式参数。在实例化模板时，用作表达式的参数的值必须是常量表达式，因为在编译期，要对特定类型进行模板实例化，生成特定类型的类代码。</p>
<p><strong>模板类可用作基类，也可用作组件类，还可用作基他模板的类型参数，递归使用模板，使用多个类型参数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> Array</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T entry;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用于基类</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class</span> GrowArray: <span class="keyword">public</span>&lt;Tyep&gt; &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//用作组件类</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Tp&gt;</div><div class="line"><span class="keyword">class</span> Stack</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Array&lt;Tp&gt; ar;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用作基他模板的类开参数</span></div><div class="line">Array &lt;Stack&lt;<span class="keyword">int</span>&gt; &gt; asi;    <span class="comment">//必须使用至少一个空白字符将两个&gt;符号分开，以避免与&gt;&gt;操作符混淆。</span></div><div class="line"></div><div class="line"><span class="comment">//递归使用模板</span></div><div class="line">ArrayTP&lt; ArrayTP&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt;， <span class="number">10</span>&gt; twodee;</div><div class="line"></div><div class="line"><span class="comment">//使用多个类型参数</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</div><div class="line"><span class="keyword">class</span> Pair</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T1 a;</div><div class="line">    T2 b;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">T1 &amp;<span class="title">first</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">T2 &amp;<span class="title">second</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">T1 <span class="title">first</span><span class="params">()</span><span class="keyword">const</span></span>&#123;&#125;;</div><div class="line">    <span class="function">T2 <span class="title">second</span><span class="params">()</span><span class="keyword">const</span></span>&#123;&#125;;</div><div class="line">    Pair()&#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</div><div class="line">T1 &amp; Pair&lt;T1, T2&gt;::first()</div><div class="line">&#123;&#125;</div><div class="line"><span class="comment">//todo</span></div></pre></td></tr></table></figure>
<p><strong>默认类型模板参数</strong></p>
<p>类模板的另一项新特性是，可以为类型参数提供默认值，在以下代码中，如果省略T2的值，编译器将使用int。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2 = <span class="keyword">int</span>&gt; </div><div class="line"><span class="keyword">class</span> Topo&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>虽然可以为类模板类型参数提供默认值，但不能为函数模板参数提供默认值。不过可以为非类型参数提供默认值，这对于类模板和函数都是适用的。</p>
<h3 id="14-4-6-模板的具体化"><a href="#14-4-6-模板的具体化" class="headerlink" title="14.4.6 模板的具体化"></a>14.4.6 模板的具体化</h3><p>类模板与函数模板很相似，因为可以有隐式实例化、显式实例化和显式具体化，它们统称为具体化。模板以通用类型的方式描述类，而具体化是使用具体的类型生成类声明。</p>
<p><strong>隐式实例化</strong>：它们声明一个或多个对象，所需的类型，而编译器使用通用模板提供的处方生成具体的类定义。编译器在需要对象前，不会生成类的隐式实例化，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArrayTP&lt;<span class="keyword">double</span>, <span class="number">30</span>&gt; *pt;   		<span class="comment">//没有生成对象，则不会隐式实例化。</span></div><div class="line">pt = <span class="keyword">new</span> ArrayTP&lt;<span class="keyword">double</span>, <span class="number">30</span>&gt;;   <span class="comment">//隐式实例化。</span></div></pre></td></tr></table></figure>
<p><strong>显式实例化</strong>：当使用关键字template并指出所需类型来声明类时，编译器将生成类声明的显式实例化。声明必须位于模板定义所在的名称空间中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在这种情况下，虽然没有创建或提及类对象，编译器也将通过通过模板生成类声明和定义。</span></div><div class="line"><span class="keyword">template</span> <span class="keyword">class</span> ArrayTP&lt;<span class="built_in">string</span>, <span class="number">100</span>&gt;;</div></pre></td></tr></table></figure>
<p><strong>显式具体化</strong>：是特定类型(用于替换模板中的通用类型)的定义，有时候可能需要在为特殊类型实例化时，对模板进行修改，使基行为不同。在这种情况下，可以创建显式具体化。当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化版本。具体化类模板定义的格式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> ClassName&lt;specialized-type-name&gt;&#123;...&#125;;</div><div class="line"><span class="comment">//使用新表示法提供一个专供char*类型使用的SortedArray模板，可以使用与下面类似的代码</span></div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> SortedArray&lt;<span class="keyword">char</span>*&gt;&#123;...&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>部分具体化</strong>：C++还允许部分具体化，即部分限制模板的通用。如：部分具体化可以给类型参数之一指定具体的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通用模板</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt; <span class="keyword">class</span> Pair&#123;&#125;;</div><div class="line"><span class="comment">//部分具体化模板</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1&gt; <span class="keyword">class</span> Pair&lt;T1, <span class="keyword">int</span>&gt;&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>关键字template后面的&lt;&gt;声明的是没有被具体化的类型参数。 因此，上述第二个声明将T2具体化为int，但T1保持不变。注意，如果指定所有的类型，则&lt;&gt;内将为空，这将导致显式具体化。</p>
<p>如果有多个模板可供选择，则编译器将使用具体化程度最高的模板。</p>
<h3 id="14-4-7-成员模板"><a href="#14-4-7-成员模板" class="headerlink" title="14.4.7 成员模板"></a>14.4.7 成员模板</h3><p>C++模板支持的另一个新特性是：模板可用作结构、 类或模板类的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Beta</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt; </div><div class="line">    <span class="keyword">class</span> Hold</div><div class="line">	&#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		V val;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Hold(V v = <span class="number">0</span>):V(v)&#123;&#125;;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Beta(T t,<span class="keyword">int</span> i):q(t), n(i)&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Hold模板类是在私有部分声明的，因此只能在Beta类中访问它。</p>
<h3 id="14-4-8-将模板用作参数"><a href="#14-4-8-将模板用作参数" class="headerlink" title="14.4.8 将模板用作参数"></a>14.4.8 将模板用作参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">"stacktp.h"</span></span></div><div class="line"><span class="comment">//模板参数</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Thing&gt;</div><div class="line"><span class="keyword">class</span> Crab</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Thing&lt;<span class="keyword">int</span>&gt; s1;</div><div class="line">    Thing&lt;<span class="keyword">double</span>&gt; s2;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Crab();</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> x)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  Crab&lt;Stack&gt; nebula;</div><div class="line">  <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Crab模板的成员s1、s2，使用模板参数声明的Thing模板去实例化成员，当使用时模板参数为Stack，则使用Stack去实例化s1、s2。</p>
<h3 id="14-4-9-模板类和友元"><a href="#14-4-9-模板类和友元" class="headerlink" title="14.4.9 模板类和友元"></a>14.4.9 模板类和友元</h3><p>模板类声明也可以有码元，模板的友元分3类：</p>
<ul>
<li>非模板友元</li>
<li>约束模板友元，即友元的类型取决于类被实例化时的类型。</li>
<li>非约束模板码元，即友元的所有具体化都是类的每一个具体化的友元。</li>
</ul>
<p><strong>非模板友元</strong>：为具体模板实例化编写不同的友元。如果友元不带模板类型参数，则所有模板实例化共用一个友元函数，如果友元带模板类型参数，则为不同类型的模板实例化编写相应的友元。</p>
<p><strong>模板类的约束模板友元函数</strong>：约束模板友元函数是在类外面声明的模板的具体化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;</div><div class="line">CLASS HasFriendT</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>: </div><div class="line">    TT item;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ct;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    HasFriendT(<span class="keyword">const</span> TT &amp;i):item(i)&#123;ct++;&#125;</div><div class="line">    ~HasFriendT()&#123;ct--;&#125;</div><div class="line"></div><div class="line">    <span class="comment">//声明中的&lt;&gt;指出这是模板具体化。</span></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> counts&lt;TT&gt;();</div><div class="line">    <span class="comment">//对于report，&lt;&gt;可以为空，这是因为可以从函数参数推断出模板类型参数。</span></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> report&lt;&gt; (HasFriendT&lt;TT&gt; &amp;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//模板类外声明的模板函数友元</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">int</span> HasFriendT&lt;T&gt;::ct = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; hf.item &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//声明中的&lt;&gt;指出这是模板具体化。</span></div><div class="line">    counts&lt;<span class="keyword">int</span>&gt;();</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>模板类的非约束模板友元函数</strong>：通过在类内部声明模板，可以创建非约束码元函数，即每个函数具体化都是每个类具体化的码元。对于非约束友元，友元模板类型参数与模板类型参数是不同的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> ManyFriend</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T item;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ManyFriend (<span class="keyword">const</span> T &amp;i):item(i) &#123;&#125;</div><div class="line">     </div><div class="line">    <span class="comment">//模板类内声明的模板函数友元，定义与类成员模板函数一起定义</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt; </div><div class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">(C &amp; c, D &amp; d)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">(C &amp; c, D &amp; d)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; c.item &lt;&lt; <span class="string">","</span> &lt;&lt; d.item &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//todo</span></div><div class="line">    show2(hfdb, hfi2);</div><div class="line">    <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="14-5-总结"><a href="#14-5-总结" class="headerlink" title="14.5 总结"></a>14.5 总结</h3><p>使用私有继承时，基类的公有成员和保护成员将成为派生类的私有成员；使用保护继承时，基类的公有成员和保护成员将成为派生类的保护成员。无论使用哪种继承，基类的公有接口都将成为派生类的内部接口。这有时候被称为继承实现，但不继承接口，因为派生类对象不能显式地使用基类的接口。因此，不能将派生对象看作是一种基类的对象。由于这个原因，在不进行显式类型转换的情况下，基类指针或引用将不能指向派生类对象。</p>
<p>还可以通过开发包含对象成员的类来重用类代码。这种方法被称为包含、 层次化或组合，它建立的也是has-a关系。与私有继承和保护继承相比，包含更容易实现和使用，所以通常优先采用这种方式。不过，私有继承和保护继承与包含有一些不同的功能。例如，继承允许派生类访问基类的保护成员；还允许派生类重新定义从基类那里继承的虚函数。因为包含不是继承，所以通过包含来重用类代码时， 不能使用这些功能。 另一方面，如果需要使用某个类的几个对象，则用包含更适合。</p>
<p>可以提供显式具体化—覆盖模板定义的具体类声明。方法是以template&lt;&gt;打头，然后是模板类名称，再加上尖括号（其中包含要具体化的类型）。</p>
]]></content>
    
    <summary type="html">
    
      个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="C++" scheme="http://LySnake.github.io/tags/c/"/>
    
      <category term="C++ Primer Plus" scheme="http://LySnake.github.io/tags/c-primer-plus/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus学习笔记(3)</title>
    <link href="http://LySnake.github.io/archives/technology/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3).html"/>
    <id>http://LySnake.github.io/archives/technology/C++ Primer Plus学习笔记(3).html</id>
    <published>2017-06-11T09:15:03.000Z</published>
    <updated>2018-02-24T13:23:00.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="13-类继承"><a href="#13-类继承" class="headerlink" title="13. 类继承"></a>13. 类继承</h2><h3 id="13-1派生一个类"><a href="#13-1派生一个类" class="headerlink" title="13.1派生一个类"></a>13.1派生一个类</h3><p>从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。</p>
<ul>
<li>派生类对象存储了基类的数据成员（派生类继承了基类的实现）。</li>
<li>派生类对象可以使用基类的方法（派生类继承了基类的接口）。</li>
<li>派生类需要自己的构造函数，构造函数必须给新成员和继承的成员提供数据。</li>
<li>派生类可以根据需要添加额外的数据成员和成员函数。</li>
</ul>
<h3 id="13-1-2-构造函数：访问权限的考虑"><a href="#13-1-2-构造函数：访问权限的考虑" class="headerlink" title="13.1.2 构造函数：访问权限的考虑"></a>13.1.2 构造函数：访问权限的考虑</h3><p>派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。例如，派生类的构造函数不能直接设置继承的成员数据，而必须使用基类的公有方法或保护方法来访问私有的基类成员。具体地说，派生类构造函数必须使用基类的构造函数。</p>
<p>创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员初始化列表句法来完成这种工作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassName::ClassName(<span class="keyword">int</span> a, <span class="keyword">int</span> b):BaseClass(a, b)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中BaseClass是成员初始化列表。它是可执行的代码，它调用BaseClass构造函数。</p>
<p>基类必须首先被创建，如果不调用基类构造函数，程序将使用默认的基类构造函数，除非要使用默认构造函数，否则应显式调用正确的基类构造函数。</p>
<p>有关派生类构造函数的要点：</p>
<ul>
<li>基类对象首先被创建。</li>
<li>派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数。</li>
<li>派生类构造函数应初始化派生类新增的数据成员。释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。（TIP:创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。基类构造函数负责初始化继承数据成员派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表句法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。）</li>
</ul>
<h3 id="13-2-派生类和基类之间的特殊关系"><a href="#13-2-派生类和基类之间的特殊关系" class="headerlink" title="13.2 派生类和基类之间的特殊关系"></a>13.2 派生类和基类之间的特殊关系</h3><p>基类指针和引用可以在不进行显式类型转换的情况下指向或引用派生类对象.</p>
<p>C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是例外。不过这种例外是只单向的，不可以将基类对象和地址赋给派生类引用和指针。如果允许基类引用隐式地引用派生类对象，则可以使用基类引用为派生类对象调用基类的方法。因为派生类继承了基类的方法，所以这样做不会出现问题。如果可以将基类对象赋给派生类对象，派生类引用能够为基对象调用派生类方法，这样做将出现问题。</p>
<h3 id="13-3-继承–is-a关系"><a href="#13-3-继承–is-a关系" class="headerlink" title="13.3 继承–is-a关系"></a>13.3 继承–is-a关系</h3><p>C++有3种继承方式：公有继承、保护继承和私有继承。公有继承是最常用的方式，它建立一种is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。</p>
<ul>
<li>公有继承不建立has-a关系。has-a关系最容易的建模方式是，将一个对象作为另一个类的数据成员。</li>
<li>公有继承不建立is-like-a关系，也就是说，它不采用明喻。继承可以在基类的基础上添加属性，但不能删除基类的属性。</li>
<li>公有继承不建立is-implemented-as-a关系。</li>
<li>公有继承不建立uses-a关系。如PC对象派生出Printer对象是没有意义的，不过可以使用友元函数或友元类处理Printer与PC类之间的关系。</li>
</ul>
<h3 id="13-4-多态公有继承"><a href="#13-4-多态公有继承" class="headerlink" title="13.4 多态公有继承"></a>13.4 多态公有继承</h3><p>同一个方法在派生类和基类中的行为是不同的，换句话说，方法的行为应取决于调用该方法的对象，这种较复杂的行为称为多态–具有多种形态，就是指同一个方法的行为将随上下文而异。有二种重要的机制可用于实现多态公有继承：</p>
<ul>
<li>在派生类中重新定义基类的方法。</li>
<li>使用虚方法(推荐作法)。</li>
</ul>
<p>如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针指向的对象类型来选择方法。</p>
<p>经常在基类中将派生类会重新定义的方法声明为虚方法。方法在基类中被声明为虚拟的后，它在派生类中将自动成为虚方法。不过，在派生类声明中使用关键字virtual来指出哪些函数是虚函数也不失为一个好办法。（如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚拟的。这样，程序将根据对象类型而不是引用或指针类型来选择方法版本。关键字virtual只用于类声明的方法原型中，而没有用于实现中。）</p>
<p>派生类并不能直接访问基类的私有数据，而必须使用基类的公有方法才能访问这些数据。</p>
<p>非构造函数不能使用成员初始化列表句法，但派生类方法可以调用公有的基类方法。在派生类方法中，标准的技术是使用作用域解析操作符来调用基类方法，如BaseClass::func()。(同样包含隐式参数this)</p>
<p>使用delete释放由new分配的对象说明了为何基类应包含一个虚拟析构函数，虽然有时好像并不需要析构函数。如果析构函数不是虚拟的，则将只调用对应于指针类型的析构函数。如果析构函数是虚拟的，将调用相应的对象类型的析构函数。因此，如果指针指向的是派生类对象，将调用派生类的析构函数，然后自动调用基类的析构函数。因此，使用虚拟析构函数可以确保正确的析构函数序列被调用。</p>
<h3 id="13-4-2-静态联编和动态联编"><a href="#13-4-2-静态联编和动态联编" class="headerlink" title="13.4.2 静态联编和动态联编"></a>13.4.2 静态联编和动态联编</h3><p>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编。在C语言中，这非常简单，因为每一个函数名都对应一个不同的函数。在C++中，由于函数重载的缘故，这项任务更复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。然而，C/C++编译器可以在编译过程完成这种联编。在编译过程中进行联编被称为静态联编，又称为早期联编。不过，虚函数使这项工作变得更困难，使用哪一个函数是不能在编译时确定的，因为编译器不知道用户将选择哪种类型的对象。所以编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编，又称为晚期联编，编译器对非虚方法使用静态联编，对虚方法使用动态联编。</p>
<h3 id="13-4-3指针和引用类型兼容性"><a href="#13-4-3指针和引用类型兼容性" class="headerlink" title="13.4.3指针和引用类型兼容性"></a>13.4.3指针和引用类型兼容性</h3><p>在C++中，动态联编与指针和引用调用的方法相关，从某种程度上说，这是由继承控制的，公有继承建立is-a关系的一种方法是如何处理指向对象的指针和引用。通常，C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型，不过指向基类的引用或指针可以引用派生类对象，而不必进行显式类型转换。将派生类引用或指针转换为基类引用或指针被称为向上强制转换，这使公有继承不需要进行显式类型转换。该规则是is-a关系的一部分。将基类指针或引用转换为派生类指针或引用–称为向下强制转换。如果不使用显式类型转换，则向下强制转换是不允许的。原因是is-a关系通常是不可逆的。派生类可以新增数据成员，因此使用这些数据成员的类函数不能应用于基类。</p>
<h4 id="动态联编和静态联编对比"><a href="#动态联编和静态联编对比" class="headerlink" title="动态联编和静态联编对比"></a>动态联编和静态联编对比</h4><p><strong>效率</strong>：为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销。</p>
<p><strong>概念模型</strong>：在设计类时，可能包含一些不在派生类重新定义的成员函数。对于这些函数不设置为虚函数有二方面的好处：首先效率更高，基次指出不要重新定义该函数。这表明，仅将那些预期将被重新定义的方法声明为虚拟的。</p>
<p><strong>虚函数的工作原理</strong>：C++规定了虚函数的行为，但将实现方法留给了编译器作者。通常，编译器处理虚函数的方法是，给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table,vtbl)。虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含了一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中，注意，无论类中包含的虚函数是1个还是10个，都只需要在对象中添加1个地址成员，只是表的大小不同而已。（虚函数表记录的函数并不记录参数特征标（非重载而是重写））</p>
<p>使用虚函数时，在内存和执行速度方面有一定的成本，包括：</p>
<ul>
<li>每个对象都将增大，增大量为存储地址的空间。</li>
<li>每个类，编译器都创建一个虚函数地址表。</li>
<li>每个函数调用都需要执行一步额外的操作，即到表中查找地址。</li>
</ul>
<h3 id="13-4-5-有关虚函数注意事项"><a href="#13-4-5-有关虚函数注意事项" class="headerlink" title="13.4.5 有关虚函数注意事项"></a>13.4.5 有关虚函数注意事项</h3><p>虚函数要点：</p>
<ul>
<li>在基类的声明中使用关键字virtual可使该方法在基类以及所有的派生类中是虚拟的。</li>
<li>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样的基类指针或引用可以指向派生类</li>
<li>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚拟的。</li>
</ul>
<p>对于虚方法，还需要了解其它的一些知识：</p>
<ul>
<li>构造函数<blockquote>
<p>构造函数不能是虚函数，派生类不继承基类的构造函数，所以将类构造函数声明为虚拟的没有什么意义。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>析构函数</p>
<blockquote>
<p>析构函数应当是虚函数，除非类不用做基类。如果析构函数是虚拟的，则当基类指针或引用使用的派生类被析构时，将先调用派生类构造函数，再自动调用基类的析构函数，如果不是虚拟的，将是直接调用基类的析构函数。顺便说一句，给类定义一个虚拟析构函数并非错误，即使这个类不用做基类；这只是一个效率方面的问题。通常应给基类一个虚拟析构函数，即使它并不需要析构函数。</p>
</blockquote>
</li>
<li><p>友元</p>
<blockquote>
<p>友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。如果由于这个原因引起了设计问题，可以通过让友元函数使用虚拟成员函数来解决。</p>
</blockquote>
</li>
<li><p>没有重新定义</p>
<blockquote>
<p>如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>虚拟函数重新定义不会生成函数的二个重载版本，而是隐藏了基类的所有同名虚函数版本。简而言之，重新定义继承的方法并不是重载。如果在派生类中重新定义函数，将不是使用相同的函数特征标基类声明，而隐藏同名的基类方法，不管参数特征标如何。因此引出了二条经验规则：</p>
<ol>
<li>如果重新定义继承的虚方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。</li>
</ol>
<p>2.如果基类声明被重载了，则应在派生类中重新定义所有基类版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BaseClass</div><div class="line">&#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">     <span class="comment">//三个被重载的虚函数声明</span></div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span>)</span></span>;</div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span>)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> ClassName:<span class="keyword">public</span> BaseClass</div><div class="line">&#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="comment">//三个基类同名的虚函数都要重新定义，避免覆盖基类其它同名的虚函数 </span></div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span>)</span></span>;</div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span>)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<h3 id="13-5-访问控制：protected"><a href="#13-5-访问控制：protected" class="headerlink" title="13.5 访问控制：protected"></a>13.5 访问控制：protected</h3><p>关键字protected与private相似，在类外只能用公有类成员函数来访问protected部分中的类成员。private和protected之间的区别只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。而对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。（最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据）</p>
<p><strong>单设计模式</strong>：希望有且只有一个类的实例返回给调用程序时，就可以使用单设计模式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> TheOnlyInstance</div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">static</span> TheOnlyInstance *<span class="title">GetTheOnlyInstance</span><span class="params">()</span></span>;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        <span class="comment">//无公有构造函数，可以防止实例被创建。只能通过公有静态方法来访问。</span></div><div class="line">        TheOnlyInstance()&#123;&#125;;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">//other data</span></div><div class="line">&#125;</div><div class="line">TheOnlyInstance &amp;TheOnlyInstance::GetTheOnlyInstance()</div><div class="line">&#123;</div><div class="line">    <span class="comment">//静态局部变量只在第一次执行时初始化，生命期为整个函数，作用域为定义到该函数结尾</span></div><div class="line">    <span class="keyword">static</span> TheOnlyInstance objTheOnlyInstance;</div><div class="line">    <span class="keyword">return</span> objTheOnlyInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="13-6-抽象基类"><a href="#13-6-抽象基类" class="headerlink" title="13.6 抽象基类　"></a>13.6 抽象基类　</h3><p>C++通过使用纯虚函数提供未实现的函数。纯虚函数声明的结尾处为=0。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BaseClass</div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">double</span> x,y;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">virtual</span> ~BaseClass();</div><div class="line">        <span class="comment">//纯虚函数</span></div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span><span class="params">()</span><span class="keyword">const</span></span>=<span class="number">0</span>;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当类声明中包含纯虚函数时，则不能创建该类的对象。这里的理念是，包含纯虚函数的类只能作基类。要成为真正的抽象基类(abstract base class,ABC),必须至少包含一个纯虚函数。原型中的=0使虚函数成为纯虚函数。总之，在原型中使用=0指出类是一个抽象基类，在类中可以不定义该函数。ABC描述的是至少使用一个纯虚函数的接口，从ABC派生出的类将根据派生类的具体特征，使用常规虚函数来实现这种接口。</p>
<p>设计ABC之前，首先应开发一个模型–指出编程问题所需的类以及它们之间相互关系。一种学院派思想认为，如果要设计类继承层次，则只能将那些不会被用作基类的类设计为具体的类。</p>
<p><strong>ABC要求具体派生类覆盖其纯虚函数–迫使派生类遵循ABC所设置的接口规则。这种模型在基于组件的编程模式中很常见，在这种情况下，使用ABC使组件设计人员能够制定“接口约定”，这样确保了从ABC派生的所有组件都至少支持ABC指定的功能。</strong></p>
<h3 id="13-7-继承和动态内存分配"><a href="#13-7-继承和动态内存分配" class="headerlink" title="13.7 继承和动态内存分配"></a>13.7 继承和动态内存分配</h3><p>当声明中的构造函数使用new操作符时，需要使用特殊方法：析构函数、复制构造函数和重载赋值操作符。</p>
<p>当派生类构造函数不使用new操作符或静态成员变量时：</p>
<ul>
<li>如果没有定义析构函数，编译器将定义一个不执行任何操作的默认构造函数。实际上，派生类的默认构造函数总是要进行一些操作：执行自身的代码后调用基类析构函数。</li>
<li>成员复制将根据数据类型采用相应的复制方式，但复制类成员或继承的类组件时，则是使用该类的复制构造函数完成的。所以派生类的默认复制构造函数使用显示的基类复制构造函数来复制派生类对象的基类数据部分。</li>
<li>类的默认赋值操作符将自动使用基类的赋值操作符来对基类组件进行赋值。</li>
</ul>
<p>当派生类构造函数使用new操作符或静态成员变量时，必须为派生类定义显式析构函数、复制构造函数和赋值操作符：</p>
<ul>
<li>派生类析构函数自动调用基类的析构函数，因此其自身的职责是对派生类构造函数执行工作的进行清理。</li>
<li>派生类的复制构造函数只能访问派生类新增的成员，因此它必须调用基类的复制构造函数来处理共享的基类数据部分。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassName::ClassName(<span class="keyword">const</span> ClassName &amp;rs):BaseClass(rs)</div><div class="line">&#123;</div><div class="line">     <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>成员初始化列表将一个派生类引用传递给基类构造函数。没有参数类型为派生类的引用的基类构造函数，也不需要这样的构造函数。因为复制构造函数派生类有一个以派生类为引用的参数，而基类引用可以指向派生类型。因此基类复制构造函数将使用参数为派生类的基类数据部分来构造新对象的基类部分。</p>
</blockquote>
<ul>
<li>由于派生类使用了动态内存分配，所以它也需要一个显式赋值操作符。作为派生类的方法，它只能直接访问派生类的数据。然而派生类的显式赋值操作符必须负责所有继承的派生类对象的赋值，可以通过显式调用基类赋值操作符来完成。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ClassName&amp; ClassName::<span class="keyword">operator</span>=(<span class="keyword">const</span> ClassName &amp;rs):BaseClass(rs)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span>(<span class="keyword">this</span> == rs)</div><div class="line">         <span class="keyword">return</span> rs;</div><div class="line">     <span class="comment">//显式调用基类的赋值操作符 </span></div><div class="line">     BaseClass::<span class="keyword">operator</span>=(rs);</div><div class="line">     <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>总之，当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数以及赋值操作符都必须使用相应的基类方法来处理基类的元素。这种要求是通过三种不同的方式来满足的。对于析构函数，这是自动完成的；对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做将自动调用基类的默认构造函数。对于赋值操作符，这是通过使用作用域解析操作符显式地调用基类的赋值操作符来完成。</p>
<p>因为友元不是成员函数，所以不能使用作用域解析操作符来指出要使用哪个函数。这个问题解决方法是使用强制类型转换，以便匹配原型时能够选择正确的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> ClassName &amp; hs)</div><div class="line">&#123;</div><div class="line">    os&lt;&lt;(<span class="keyword">const</span> ClassName &amp;)hs;</div><div class="line">    <span class="comment">//todo;</span></div><div class="line">    <span class="keyword">return</span> hs;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="13-8-类设计回顾"><a href="#13-8-类设计回顾" class="headerlink" title="13.8 类设计回顾"></a>13.8 类设计回顾</h3><ul>
<li>默认构造函数 </li>
</ul>
<p>默认构造函数要么没有参数，要么所有参数都有默认值，如果没有定义任何构造函数，编译器将定义默认构造函数，让您能够创建对象。自动生成的默认构造函数的另一个功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数。另外，如果派生类构造函数的成员初始化列表中没有显式地调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。如果定义了某种构造函数，编译器将不会定义默认构造函数。在这种情况下，如果需要默认构造函数，则必须自己提供。提供构造函数的动机之一是确保对象总能被正确地初始化。另外，如果类包含指针成员，则必须初始化这些成员。因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值。</p>
<ul>
<li>复制构造函数</li>
</ul>
<p>复制构造函数接受其所属类的对象作为参数。在以下情况，将使用复制构造函数：</p>
<ol>
<li>将新的对象初始化为一个同类对象。</li>
<li>按值将对象传递给函数。</li>
<li>函数按值返回对象。</li>
<li>编译器生成临时对象。  //obj1 = obj2 + obj3 + obj4; </li>
</ol>
<p>如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。也就是说，新对象的 每个成员都被初始化为原始对象相应的成员的值。</p>
<p>在某些情况下，成员初始化是不合适的。如：使用new初始化的成员指针通常要求执行深复制，或者类可能包含需要修改的静态变量。</p>
<ul>
<li>赋值操作符</li>
</ul>
<p>默认的赋值操作符用于处理同类对象之间的赋值。不要将赋值与初始化混淆了。如果语句创建新的对象，则使用复制构造函数；如果语句修改已有对象的值，则是赋值。编译器不会生成将一种赋值给另一种类型的赋值操作符。如果希望能够将一种对象赋值给另一个对象，则方法之一是显式定义相应的赋值操作符。</p>
<ul>
<li>构造函数</li>
</ul>
<p>构造函数不同于其他类方法，因为它创建新的对象，而其它类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。继承意味着派生类对象可以使用基类的方法，然而，构造函数在完成其工作之前，对象并不存在。</p>
<ul>
<li>析构函数 </li>
</ul>
<p>一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。</p>
<ul>
<li>隐式转换和转换</li>
</ul>
<p><strong>隐式转换</strong>：使用一个参数就可以调用的构造函数定义从参数类型到类类型的转换。带一个参数的构造函数原型中使用explicit将禁止进行隐式转换，但仍允许显式转换。</p>
<p><strong>转换</strong>：转换函数可以是没有参数的类成员，也可以是返回类型被声明为目标类型的为成员函数。即使没有声明返回类型，函数也应返回所需的转换值。</p>
<ul>
<li>按值传递对象与传递引用</li>
</ul>
<p>按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数。按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。</p>
<ul>
<li>返回对象和返回引用</li>
</ul>
<p>应返回引用而不是返回对象的原因在于，返回对象涉及到生成返回对象的临时拷贝，这是调用函数的程序可以使用的拷贝。因此返回对象的时间成本包括调用复制构造函数来生成拷贝所需的时间和调用析构函数删除拷贝所需的时间。返回引用可节省时间和内存。直接返回对象与按值传递对象相似：它们都生成临时拷贝。同样，返回引用与按引用传递对象相似：调用和被调用的函数对同一个对象进行操作。</p>
<ul>
<li>使用const </li>
</ul>
<p>可用const来确保方法不修改参数（修饰参数），确保方法不修改调用它的对象（修饰方法代码块）。确保引用或指针返回的值不能用于修改对象的数据，使之成为左值。</p>
<p>如果函数将参数声明为指向const的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改。</p>
<h4 id="13-8-3-公有继承的考虑因素"><a href="#13-8-3-公有继承的考虑因素" class="headerlink" title="13.8.3 公有继承的考虑因素"></a>13.8.3 公有继承的考虑因素</h4><p><strong>is-a关系</strong>：在某些情况下，最好的方法可能是创建包含纯虚函数的抽象数据类，并从它派生出其它类。</p>
<p><strong>为什么不能被继承</strong>：构造函数是不能被继承的，也就是说，创建派生类对象时，必须调用派生类的构造函数。不过，派生类构造函数通常使用成员初始化列表句法来调用基类构造函数，以创建派生对象的基类部分。如果派生类构造函数没有使用成员初始化列表句法显式调用基类构造函数，将使用基类的默认构造函数。在继承链中，每个类都要可以使用初始化列表将信息传递回相近的基类。析构函数也是不能继承的。不过，在释放对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数。如果基类有默认析构函数，编译器将为派生类生成默认析构函数。通常，对于基类，其析构函数应设置为虚拟的。</p>
<p><strong>赋值操作符</strong>：派生类继承的方法的特征标与基类完全相同，但赋值操作符的特征标随类而异，这是因为它包含一个类型为其所属类的的参数。如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值操作符。这个操作符的默认或隐式版本将采用成员赋值，即将原对象的相应成员赋给目标对象的每个成员。不过，如果对象属于基类，编译器将使用基类同仁操作符来处理派生对象中基类部分的同仁。如果显式地为基类提供赋值操作符，将使用该操作符。与此相似，如果成员是另一个类的对象，则对于该成员，将使用基所属类的赋值操作符。如果类构造函数使用new来初始化指针，则需要提供一个显式赋值操作符。如果派生类使用了new，则必须提供显式赋值操作符。</p>
<p>如果派生类包含了这样的构造函数，即对将基类对象转换为派生类对象进行了定义，则可以将基类对象赋给派生对象。如果派生类定义了用于将基类对象赋给派生对象的同仁操作符，则也可以这样做。如果上述二个条件都不满足，则不能这样做，除非使用显式强制类型转换。</p>
<p><strong>私有成员与保护成员</strong>：对派生类而言，保护成员类似于公有成员；但对于外部而言，保护成员与私有成员类似。派生类可以直接访问基类的保护成员，但只能通过基类的成员函数来访问私有成员。因此，将基类成员设置为私有的可以提高安全性，而将它们设置为保护成员则可简化代码的编写工作，并提高访问速度。</p>
<p><strong>虚方法</strong>：如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚拟的，这样可以启用晚期联编；如果不希望重新定义方法，则不必将其声明为虚拟的，这样虽然无法禁止他人重新定义方法，但表达了这样的意思。</p>
<p><strong>析构函数</strong>：基类的析构函数应当是虚拟的，这样，当通过指向对象的基类指针或引用来删除派生对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数， 而不仅仅是调用基类的析构函数。</p>
<p><strong>友元函数</strong>：通过强制类型转换将派生类型引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数。</p>
<p><strong>有关使用基类方法的说明</strong>：</p>
<ul>
<li>派生类元旦自使用继承而来的基类方法，如果派生类没有重新定义该方法。</li>
<li>派生类的析构函数自动调用基类的析构函数。</li>
<li>派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数。</li>
<li>派生类构造函数显式地调用成员初以化列表中指定的基类构造函数。</li>
<li>派生类方法可以使用作用域解析操作符来调用仅有的和受保护的基类方法。</li>
<li>派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。</li>
</ul>
<p><strong>new和delete是对象的静态成员函数</strong></p>
<p>派生类继承基类的数据成员和大部分方法，但不继承类开的构造函数、析构函数和同仁操作符。派生类可以直接访问基类的公有成员和保护成员，并能够通过基类的仅有方法和保护方法访问基类的私有成员。可以在派生类中新增数据成员和方法，还可以将派生类用作基类，来做进一步的开发。每个派生类都必须有自己的构造函数。程序创建派生类对象时，将首先调用基类的构造函数，然后调用派生类的构造函数；程序删除对象时，将首先调用派生类的析构函数，再调用基类的析构函数。</p>
<p>ABC：只定义接口，而不涉及实现，ABC必须至少包含一个纯虚方法，可以在声明中的分号前面加上=0来声明纯虚方法。不一定非得定义纯虚方法。对于包含纯虚成员的类，不能使用它来创建对象。纯虚方法用于定义派生类的通用接口。</p>
]]></content>
    
    <summary type="html">
    
      个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="C++" scheme="http://LySnake.github.io/tags/c/"/>
    
      <category term="C++ Primer Plus" scheme="http://LySnake.github.io/tags/c-primer-plus/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus学习笔记(2)</title>
    <link href="http://LySnake.github.io/archives/technology/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2).html"/>
    <id>http://LySnake.github.io/archives/technology/C++ Primer Plus学习笔记(2).html</id>
    <published>2017-06-04T15:16:05.036Z</published>
    <updated>2018-02-24T13:23:03.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-使用类"><a href="#11-使用类" class="headerlink" title="11.使用类"></a>11.使用类</h2><h3 id="11-2-1-操作符重载"><a href="#11-2-1-操作符重载" class="headerlink" title="11.2.1 操作符重载"></a>11.2.1 操作符重载</h3><p><strong>操作符重载</strong>是一种形式的C++多态，操作符重载将重载的概念扩展到操作符上，允许赋予C++操作符多种含义。要重载操作符，需使用被称为操作符函数的特殊函数形式。操作符函数的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ClassName total, coding, fixing;</div><div class="line"><span class="comment">//可以像使用成员方法一样使用操作符重载</span></div><div class="line">total = coding.<span class="keyword">operator</span>+(fixing);</div><div class="line"><span class="comment">//以可以使用操作符表示法：</span></div><div class="line">total = coding + fixing;</div><div class="line"></div><div class="line"><span class="comment">//注意，在操作符表示法中，操作符左侧的对象（这里为coding）是调用对象，操作符右边（这里是fixing)是作为参数被传递的对象。</span></div></pre></td></tr></table></figure>
<p>operator +()重载+操作符，operator -()重载-操作符。op必须是有效的C++操作符，不能虚构一个新的符号。</p>
<h3 id="11-2-2操作符重载的限制"><a href="#11-2-2操作符重载的限制" class="headerlink" title="11.2.2操作符重载的限制"></a>11.2.2操作符重载的限制</h3><ul>
<li>重载后的操作符必须至少有一个操作数是用户定义，这将防止用户为标准类型重载操作符。因此不能将减法操作符重载为计算两个double值的和，而不是它们的差。</li>
<li>使用操作符时不能违反操作符原来的句法规则。例如，不能将求模操作符(%)重载成使用一个操作数(%x;），同样也不能修改操作符的优先级。因此，如果将加号操作符重载成将两个类相加，则新的操作符与原来的加号具有相同的优先级。</li>
<li>不能定义新的操作符。</li>
<li>不能重载下面的操作符<blockquote>
<ul>
<li>sizeof—sizeof操作符。(sizeof操作符是编译时运算)</li>
<li>.—成员操作符。</li>
<li>.*—成员指针操作符。</li>
<li>::—作用域解析操作符。</li>
<li>?:—条件操作符。</li>
<li>typeid—一个RTTI操作符。</li>
<li>const_cast—强制类型转换操作符。</li>
<li>dynamic_cast—强制类型转换操作符。</li>
<li>reinterpret_cast—强制类型转换操作符。</li>
<li>static_cast—强制类型转换操作符。</li>
</ul>
</blockquote>
</li>
<li>大多操作符都可以通过成员或非成员函数进行重载，但下面的操作符只能通过成员函数进行重载：<blockquote>
<ul>
<li>=—赋值操作符。</li>
<li>()—函数调用操作符。</li>
<li>[]—下标操作符。</li>
<li>-&gt;—通过指针访问的类成员的操作符。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="11-3友元简介"><a href="#11-3友元简介" class="headerlink" title="11.3友元简介"></a>11.3友元简介</h3><p>友元有3种：</p>
<ul>
<li>友元函数。</li>
<li>友元类。</li>
<li>友元成员函数。</li>
</ul>
<p>通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显示参数(非this传入)。对于非成员重载操作符函数来说，操作符表达式左边的操作数对应于操作符函数的第一个参数，操作符表达式右边的操作数对应于操作符函数的第二个参数。</p>
<p>创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">friend</span> TypeName <span class="keyword">operator</span>* (<span class="keyword">double</span> m, <span class="keyword">const</span> className &amp;T);</div></pre></td></tr></table></figure></p>
<ul>
<li>显然operator*()函数是在类声明中声明的，但它不是成员函数，因此不能使用成员操作符来调用。</li>
<li>虽然operator*()函数不是成员函数，但它与函数的访问权限相同。</li>
</ul>
<p>第二步是编写函数定义。因为它不是成员函数，所以不要使用className::限定符。加外不要在定义中使用关键字friend。简而言之，友元函数是非成员函数，其访问权限与成员函数相同。</p>
<p>ostream类对该操作符进行了重载，将其转换为一个输出工具，前面讲过，cout是一个ostream对象，它是智能的。能够识别所有的C++基本类型。这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的operator&lt;&lt;()定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过返回ostream的引用实现链式调用</span></div><div class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> className &amp;t)</div><div class="line">&#123;</div><div class="line">	os&lt;&lt; t.intValue &lt;&lt; t.floatValue &lt;&lt; t.stringValue ;</div><div class="line">	<span class="keyword">return</span> os;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非成员版本的重载操作符函数所需的形参数目与操作符使用的操作数数目相同，而成员版本所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象(this)。</p>
<h3 id="11-6类的自动转换和强制类型转换"><a href="#11-6类的自动转换和强制类型转换" class="headerlink" title="11.6类的自动转换和强制类型转换"></a>11.6类的自动转换和强制类型转换</h3><p>C++的目标之一就是把类实现为与基本类型一致，所以也存在隐式转换问题。</p>
<p>对于类ClassName，如果存在一个参数的构造函数，那么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 存在ClassName::ClassName(TypeName)构造函数</span></div><div class="line">ClassName classValue ;</div><div class="line"><span class="comment">//相当于==&gt;classValue = ClassName::ClassName(TypeNameValue);通过构造函数以参数构造了一个对象。形成隐式转换。   </span></div><div class="line">classValue = TypeNameValue;</div></pre></td></tr></table></figure>
<p>最新的C++实现新增了一个关键字(explicit)，用来关闭这种自动特性。也就是说，可以这样声明构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//告知编译器禁止使用隐式转换，但仍然允许显式转换，即显式强制类型转换</span></div><div class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ClassName</span><span class="params">(TypeName value)</span></span>;    </div><div class="line"><span class="comment">//强制类型转换      </span></div><div class="line">ClassNameValue = ClassName(TypeNameValue);</div></pre></td></tr></table></figure></p>
<p>只接受一个参数(可存在其它默认参数)的构造函数定义了从参数到类类型的转换。如果使用关键字explicit限定了这种构造函数，则它只能用于显示转换，否则也可以用于隐式转换。</p>
<p>当没有使用explicit限定只能用于强制转换，则在以下情况发生隐式转换：</p>
<ul>
<li>将ClassName对象初始化为TypeName值时。    //ClassName ClassNameValue = TypeNameValue;</li>
<li>将TypeName值赋给ClassName对象时。       //相当于先调用ClassName(TypeNameValue)构造，再调用Copy构造。</li>
<li>将TypeName值传递给接受ClassName参数的函数时。   </li>
<li>返回值被声明为ClassName类型的函数试图返回一个TypeName类型值时。</li>
</ul>
<p>函数原型提供的参数匹配过程，允许使用ClassName(TypeName)构造函数来转换其他数值类型。比如TypeName是float类型，当把int类型当做实参时，int先转换为float，再转换成TypeName给形参.</p>
<h3 id="11-6-2转换函数"><a href="#11-6-2转换函数" class="headerlink" title="11.6.2转换函数"></a>11.6.2转换函数</h3><p>构造函数只用于从某种类型到类类型的转换。要进行相反的转换必须使用特殊的C++操作符—转换函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//TypeName为int、float、double等</span></div><div class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>转换函数必须是类方法。</li>
<li>转换函数不能指定返回类型，但要有返回值。(typeName已经指定类型，无需过多注明)</li>
<li>转换函数不能有参数。(类的对象this即是参数对象)</li>
</ul>
<p>TypeName(这里为double）指出了要转换成的类型，因此不需要指定返回类型。转换函数是类方法意味着：它需要通过类对象来调用，从而告知函数要转换的值。因此，函数不需要参数。虽然没有返回类型，这二个函数也将返回所需的值。</p>
<p>提供执行自动、隐式转换的函数所存在的问题是：在用户希望转换时，转换函数也可能进行转换。原则来说，最好使用显示转换，而避免隐式转换。关键字explicit不能用于转换函数，但只需用一个功能相同的非转换函数替换访转换函数即可，但仅在被显式地调用时，该函数才会执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ClassName::<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">//todo</span></div><div class="line">	<span class="keyword">return</span> intValue;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//改写为</span></div><div class="line">ClassName::ClassName2int()&#123;&#125;;</div></pre></td></tr></table></figure>
<p>C++提供了下面的类型转换：</p>
<ul>
<li>只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。例如，将int值赋给ClassName对象时，接受int参数的ClassName类构造函数将自动被调用。不过，在构造函数声明中使用explicit可防止隐式转换，而只允许显式转换。</li>
<li>被称为转换函数的特殊类成员操作符函数，用于将类对象转换为其他类型。转换函数是类成员，没有返回类型、没有参数类型、名为operator typeName()，其中，typeName是对象将被转换成的类型。<strong>将类对象赋给typeName变量或将其强制转换为TypeName类型时，该转换函数将自动被调用</strong>。</li>
</ul>
<p>全局对象，因为全局对象将在程序的main()函数被调用之前创建。程序员可以创建一个类，其默认构造函数将调用所有的bootstrap函数。实现在main()函数调用之前，执行全局类对象的构造函数来初始化一些数据。</p>
<p>C++允许指定在基本类型之间进行转换的方式。首先，任何可接受一个参数的构造函数都可被用作转换函数，将类型与该参数相同的值转换为类。如果将类型与该参数相同的值赋给对象，则C++将自动调用该构造函数。要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换。转换函数必须是成员函数。将类对象转换为TypeName类型的转换函数的原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意，转换函数没有返回类型、没有参数(必须是成员函数，存在隐式参数this)，但必须返回转换后的值（虽然没有声明返回类型）</span></div><div class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<h2 id="12-类和动态内存分配"><a href="#12-类和动态内存分配" class="headerlink" title="12.类和动态内存分配"></a>12.类和动态内存分配</h2><p>类中定义static成员变量，则该变量存储在全局数据区，所有类对象共有，且作用域为类作用域。不能在类的声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存，可以使用这种格式来创建对象，从而分配和初始化内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型，并使用了作用域操作符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在类声明之外使用单独的语句来进行初始化</span></div><div class="line">staitc <span class="keyword">int</span> ClassName::ClassNameValue  iValue = <span class="number">110</span>;</div></pre></td></tr></table></figure>
<p>如果使用new[]来分配内存，则应使用delete[]来释放内存。并且在类中，所有的构造函数统一使用new或new[]，析构函数中使用delete或delete[]。delete可以释放NULL地址。</p>
<p>自动存储对象被删除的顺序与创建的顺序相反。</p>
<p>当使用一个对象来初始化另一个对象时，编译器将自动生成构造函数(称为复制构造函数，因为它创建对象的一个副本)。自动生成的构造函数不知道需要更新静态变量和深copy成员变量指向new出来的空间。</p>
<h3 id="12-1-2-隐式成员函数"><a href="#12-1-2-隐式成员函数" class="headerlink" title="12.1.2 隐式成员函数"></a>12.1.2 隐式成员函数</h3><p>隐式成员函数：</p>
<ul>
<li>默认构造函数，如果没有定义构造函数。</li>
<li>复制构造函数，如果没有定义。</li>
<li>赋值操作符，如果没有定义。</li>
<li>默认析构函数，如果没有定义。</li>
<li>地址操作符，如果没有定义。</li>
</ul>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>如果没有提供任何构造函数，C++将创建默认构造函数。如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象时显式地对它进行初始化，或需要创建对象数组时，则必须显式地定义默认构造函数。</p>
<h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><p>复制构造函数用于将一个对象复制到新创建的对象中。<strong>也就是说，它用于初始化过程中，而不是常规的赋值过程，执行于构造对象时，是一个构造函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ClassName</div><div class="line">&#123;</div><div class="line">	ClassName(ClassName&amp;);   <span class="comment">//复制构造函数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>何时调用复制构造函数</strong></p>
<p>新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有的对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> StringBad</div><div class="line">&#123;</div><div class="line">    StringBad(StringBad&amp;);</div><div class="line">&#125;; </div><div class="line">StringBad motto;</div><div class="line">StringBad metoo = motto;</div><div class="line">StringBad also = StringBad(motto);</div></pre></td></tr></table></figure></p>
<p><strong>这二种声明可能会使用复制构造函数直接创建metoo和also对象，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metoo和also。</strong></p>
<p>具体的说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。记住，按值传递意味着创建原始变量的一个副本。编译器生成临时对象，也将使用复制构造函数。例如，将3个Vector对象相加时，编译器可能生成临时的Vector对象来保存中间结果。何时生成临时对象随编译器而异，但无论是哪种编译器，当按值传递和返回时，都将调用复制构造函数。</p>
<p><strong>复制构造函数的功能</strong></p>
<p>默认的复制构造函数依次复制非静态成员（成员复制也称为浅复制），复制的是成员变量的值。</p>
<h4 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h4><p>C++允许类对象赋值，这是通过自动为类重载赋值操作符实现的。</p>
<p><strong>何时使用赋值操作符</strong></p>
<ul>
<li>将已有对象赋给另一个对象时，将使用重载的赋值操作符。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> StringBad</div><div class="line">&#123;</div><div class="line">	<span class="keyword">operator</span>=(<span class="keyword">const</span> StringBad&amp;);  <span class="comment">//注意自我复制带来的先delete再new的情况。</span></div><div class="line">&#125; </div><div class="line">StringBad metoo = motto;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不过，实现时也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时对象的值复制到新对象中，这就是说，初始化总是会调用复制构造函数，而使用=操作符时也有可能调用复制构造函数。</p>
<p><strong>赋值操作符的功能</strong>：与复制构造函数相似，赋值操作符的隐式实现也对成员进行依次复制，如成员本身就是类对象，则程序将使用为这个类定义的赋值操作符来复制该成员，但静态数据成员不受影响。</p>
<p><strong>重载时，C++将区分常量与非常量函数的特征标，因此可以提供另一个仅供const String对象使用的operator[] ()版本。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现对String类对象使用[]操作符取index下标的值</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)<span class="keyword">const</span>;</div></pre></td></tr></table></figure>
<h3 id="12-1-4-在构造函数中使用new时应注意的事项"><a href="#12-1-4-在构造函数中使用new时应注意的事项" class="headerlink" title="12.1.4 在构造函数中使用new时应注意的事项"></a>12.1.4 在构造函数中使用new时应注意的事项</h3><p>因为<strong>隐式成员函数</strong>的存在，使用new时应当这样做：</p>
<ul>
<li>如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete.</li>
<li>new和delete必须相互兼容。new对应于delete，new[]对应于delete[]。</li>
<li>如果有多个构造函数，则必须以相同的方式使用new，要么都带[]，要么都不带，因为只有一个析构函数，因此所有的构造函数都必须与它兼容。不过，可以在一个构造函数中使用new来初始化指针，而在另一个构造函数中将指针初始化为NULL,这是因为delete(无论是否有[])可以用于NULL。</li>
<li>应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。</li>
<li>复制构造函数应分配足够的空间来存储复制的数据，并复制数据，而不仅仅是数据的地址。另外，还应该更新所有受影响的静态类成员。</li>
<li>应当定义一个赋值操作符，通过深度复制将一个对象复制给另一个对象。</li>
</ul>
<p><strong>返回const类型，则说明返回值为右值，不可当左值</strong></p>
<h4 id="布局new操作符"><a href="#布局new操作符" class="headerlink" title="布局new操作符"></a>布局new操作符</h4><p>布局new操作符让您能够在分配内存时指定内存位置。但在该内存上分配的对象需要显示调用析构函数进行析构。</p>
<ul>
<li>程序员必须负责管理布局new操作符从中使用的缓冲区内存单元。要使用不同的内存单元，程序员需要提供二个位于缓冲区的不同地址，并确保这二个内存单元不重叠(如果对同一个地址使用布局new，则会使后new的对象覆盖前一个对象数据)。</li>
<li><p>如果使用布局new操作符来为对象分配内存，必须确保其析构函数被调用。原因在于delete可与常规new操作符配合使用，但不能与布局new操作符配合使用。为了确保析构函数被调用，显式地为使用布局new操作符创建的对象调用析构函数。正常情况下将自动调用析构函数，这是需要显式调用析构函数的少数几种情况之一。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ClassName classNameValue;</div><div class="line"><span class="comment">//或使用指针pClassNameValue-&gt;~ClassName;进行显式调用析构函数。</span></div><div class="line">classNameValue.~ClassName();</div></pre></td></tr></table></figure>
</li>
<li><p>对于使用布局new操作符创建的对象，应以与创建顺序相反的顺序进行析构。原因在于，晚创建的对象可能依赖于早创建的对象。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Queue</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">struct</span> Node</div><div class="line">  &#123;</div><div class="line">	<span class="comment">//tode</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++新特性：在类声明中嵌套结构或类声明，通过将Node声明放在Queue类中，可以使其作用域为整个类。也就是说，Node是这样一种类型：可以使用它来声明类成员，也可以将它作为类方法中的类型名称，但只能在类中使用。如果声明在类的私有部分，则只能在这个类使用被声明的类型，如果声明是在公有部分，则可以从类的外部通过作用域解析操作符使用被声明的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Queue</div><div class="line">&#123;</div><div class="line">	Queue();</div><div class="line">&#125;</div><div class="line">Queue::Queue():refValue(value1),constValue(refValue)</div><div class="line">&#123;</div><div class="line">	<span class="comment">//tode</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对需要在分配内存时就要初始化的成员(const成员，引用变量成员,基类部分数据)，则必须使用成员初始化列表初始化。</p>
<p><strong>从概念上说，调用构造函数时，对象将在括号中的代码执行之前被创建。因此调用Queue()构造函数将导致程序首先给成员变量分配内存。然后，程序流程进入到括号中，使用常规的赋值方式将值存储到内存中。因此，对于const成员变量和引用成员变量，必须在执行到构造函数体之前，即创建对象时进行初始化。C++提供了一种特殊的句法来完成上述工作，它叫作成员初始化列表。成员初始化列表由逗号分隔的初始化列表组成(前面带冒号)。它位于参数列表的右括号之后，函数体左括号之前。</strong></p>
<p>初值可以是常量或构造函数的参数列表中的参数。只有构造函数可以使用这种初始化列表句法。使用成员初始化列表的效率更高(因为在构造函数之前，其const成员，引用成员，基类部分就已经完成初始化，在构造函数中只是进行赋值操作)。</p>
<p>数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关。</p>
<p>成员初始化列表中使用的括号方式也可以用于常规的初始化中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> games = <span class="number">163</span>;</div><div class="line"><span class="keyword">double</span> talk = <span class="number">2.7</span>;</div><div class="line"><span class="comment">//可改写为</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">games</span><span class="params">(<span class="number">163</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">talk</span><span class="params">(<span class="number">2.7</span>)</span></span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="C++" scheme="http://LySnake.github.io/tags/c/"/>
    
      <category term="C++ Primer Plus" scheme="http://LySnake.github.io/tags/c-primer-plus/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus学习笔记(1)</title>
    <link href="http://LySnake.github.io/archives/technology/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1).html"/>
    <id>http://LySnake.github.io/archives/technology/C++ Primer Plus学习笔记(1).html</id>
    <published>2017-05-21T10:47:33.000Z</published>
    <updated>2018-02-24T13:22:41.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0.预备知识"></a>0.预备知识</h3><p>C++是C语言的超集，这意味着任何有效的C程序都是有效的C++程序。</p>
<p>最初，Stroustrup实现C++时，使用了一个C++到C的编译器程序，而不是开发直接的C++到目标代码的编译器。前者叫做cfront（表示C前端，C fron end），它将C++源代码翻译成C源代码，然后使用一个标准C编译器对其进行编译。这种方法简化了向C的领域引入C++的过程，其它实现也采用这种方法将C++引入到其它平台。随着C++的日渐普及，越来越多的实现转向创建C++编译器，直接将C++源代码生成目标代码。</p>
<h3 id="8-函数控幽"><a href="#8-函数控幽" class="headerlink" title="8.函数控幽"></a>8.函数控幽</h3><p><strong>名称修饰</strong>：对原始名称进行的表面看来无意义的修饰（或矫正，因人而异）将对参数数目和类型进行编码。添加的一组符号随函数特征标而异，而修饰时使用的约定随编译器而异。比如，正常的c函数声明void fn(int);在*.o文件中，链接器查看到的符号表差不多就是_fn，并没有带有参数类型标识，但C++因为有重载，重写，同一个函数名可能存在于多个类中或一个类中存在相同函数名但参数表不一样，此时目标文件*.obj中连接器查看到的符号表是带参数类型和顺序的，如_fn_i。</p>
<p>TIP：<strong>C++标准允许每个编译器设计人员以他认为合适的方式实现名称修饰，因此由不同编译器创建的二进制模块（对应目标文件）很可能无法正确地链接。也就是说，这二个编译器将为同一个函数生成不同的修饰名称。名称的不同将使链接器无法将一个编译器生的函数调用与另一个编译器生成的函数定义匹配。在链接编译模块时，请确保所有文件或库都是由同一个编译器生成的。</strong></p>
<p><strong>函数模板</strong>：是通用的函数描述，也就是说，它们使用通用类型来定义函数，其中的通用类型可用具体的类型（如int或float）替换，通过将类型作为参数传递给模板，可使编译器生成对应类型的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;   <span class="comment">//也可使用 template &lt;typename T&gt;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//todo.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键字template和class是必需的，除非可以使用关键字typename代替class，typename关键字使得参数T表示类型这一点更为明显；不过，有大量的代码库是使用关键字class开发的。在这种上下文中这二个关键字是等同的。另外使用尖括号。模板并不创建任何函数，而只是告诉编译器如何定义函数。</p>
<p>并非所有的模板参数都是必须是模板参数类型。使用模板的好处是，它使生成多个函数定义更简单、更可靠。</p>
<p>如果有多个原型，则编译器在选择原型时，非模板版本将优先于显式具体化和模板版本，而具体化将优先于使用模板生成的版本。</p>
<p>在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例。</p>
<p><strong>编译器选择使用哪个函数版本</strong>：</p>
<ol>
<li>创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。</li>
<li>使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐匿转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将参数转换为double类型，从而是与double形参匹配，而模板可以为float生成一个实例。</li>
<li>确定是否有最佳的可行函数。如果有，则使用它，否则访函数调用出错。</li>
</ol>
<h3 id="9-内存模型和名称空间"><a href="#9-内存模型和名称空间" class="headerlink" title="9.内存模型和名称空间"></a>9.内存模型和名称空间</h3><p>如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找;但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录（或其它目录，这取决于编译器）。如果没有在那里找到头文件，则将在标准位置查找。因此在包含自己的头文件时，应使用引号而不是尖括号。</p>
<p><strong>作用域</strong>：描述了名称在文件（翻译单元）的多大范围内可见。例如，函数中定义的变量可在该函数中使用，但不能在其它函数中使用;而在文件中的函数定义之前定义的变量则可在所有函数中使用。</p>
<p><strong>链接性</strong>：描述了名称如何在不同单元（源文件）间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量没有链接性，因此它们不能共享。</p>
<p>堆栈的默认长度取决于实现，但编译器通常提供改变堆栈长度的选项。</p>
<p>如果变量被关键字register修饰而存储在寄存器中，则没有内存地址，因此不能将地址操作符用于寄存器变量。</p>
<p>如果没有初始化静态变量，编译器就将它设置为0.在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0.</p>
<p><strong>关键字valatile</strong>：表明即使程序代码没有对内存单元进行修改，其值也可能发生改变。例如，可以将一个指针指向某个硬件位置，其中包含了来自串行端口的时间或信息，在这种情况下，硬件可能修改其中的内容。该关键字的作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值二次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这二次使用之间不会变化，如果不将变量声明为volatile，则编译器将进行这种优化，将变量声明为volatile，相当于告诉编译器，不要进行这种优化。</p>
<p><strong>关键字mutable</strong>：指出即使结构（或类）变量为const，其某个成员也可以被修改(修饰某个成员)。</p>
<p><strong>const</strong>:在C++中(但不是在C中)，const限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。也就是说，C++看来，全局const就像使用了static说明符一样.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> state = <span class="number">50</span>;   <span class="comment">//内部链接性，常数变量</span></div></pre></td></tr></table></figure></p>
<p><strong>extern</strong>：程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> state = <span class="number">50</span>;  <span class="comment">//external linkge</span></div></pre></td></tr></table></figure>
<p><strong>布局new操作符</strong>：指定要使用的位置地址，程序员可能使用这种特性来设置其内存管理规程或处理需要通过特定地址进行访问的硬件。但不可delete(delete只能用于这样的指针：指向常规new操作符分配的堆内存。)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> (pointName) typeName;   <span class="comment">//向地址为pointName申请一个类型为typeName的空间地址给p1;</span></div><div class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> (pointName) typeName;   <span class="comment">//向地址为pointName申请一个类型为typeName的空间地址给p2,如此便覆盖了p1所指向的空间。</span></div></pre></td></tr></table></figure>
<h4 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h4><p><strong>声明区域</strong>：是可以在其中进行声明的区域。例如，可以在函数外面声明全局变量，对于这种变量，其声明区域为其声明所在的文件，对于在函数中声明的变量，其声明区域为其声明所在的代码块。</p>
<p><strong>潜在作用域</strong>：变量的潜在作用域从声明开始，到其声明作用域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。</p>
<p><strong>作用域</strong>：变量对程序而言可见的区域。变量并不是在潜在作用域内都可见，比如子代码块定义的变量隐藏现象。</p>
<p><strong>名称空间</strong>：通过定义一种新的声明来创建命名的名称空间。这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间中相同名称发生冲突，同时允许程序的其它部分使用该名称空间中的声明的东西。</p>
<p>名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//名称空间中的声明和定义规则同全局声明和定义规则相同。</span></div><div class="line"></div><div class="line"><span class="comment">//在*.h中的声明</span></div><div class="line"><span class="keyword">namespace</span> Jace</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">float</span> f;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</div><div class="line">struck Well&#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在*.cpp中的定义</span></div><div class="line"><span class="keyword">namespace</span> Jace</div><div class="line">&#123;</div><div class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span> ;</div><div class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">      <span class="comment">//todo.</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>全局名称空间</strong>：它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于于全局名称空间中，引用全局变量可以为::valueName。</p>
<p><strong>using声明</strong>：使特定的标识符在当前作用域可用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">//仅使用std::cout时可直接使用cout而不带作用域解析操作符，但std中的其它名称不可以。</span></div></pre></td></tr></table></figure>
<p><strong>using编译指令</strong>：使整个名称空间中的名称在当前作用域可用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//则std名称空间中所有名称可在当前作用域中直接使用而不用带有作用域解析操作符。</span></div></pre></td></tr></table></figure>
<p>使用using声明时，就好像声明了相应的名称一样。如果某个名称已经在函数中声明了，则不能用using声明导入相同的名称。然而，使用using编译指令时，将进行名称解析，就像在包含using声明和名称空间本身的最小声明区域中声明了名称一样。如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。</p>
<p>假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，则这二个名称会发生冲突，从而出错。如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。</p>
<p>在名称空间中可以嵌套使用using声明和using编译指令来生成新的名称空间。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">namespace</span> elements</div><div class="line">&#123;</div><div class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> <span class="comment">//或</span></div><div class="line"> <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>名称空间别名</strong>：using myNewName = myth::elements::fire;</p>
<p><strong>未命名的名称空间</strong>：就像后面跟着using编译指令一样，也就是说，在该名称空间中声明的名称的潜在作用域为：从声明点到该点声明区域末尾，从这个方面看，它们与全局变量相似。不过由于这种名称空间没有名称，因此不能显式地使用using声明或using编译指令来使它在其它位置都可用。具体地说，不能在当前的名称空间所属文件之外的其它文件中，使用该名称空间中的名称，因此这种方法可以替代链接性为内部的静态变量。实际上，C++标准不建议在名称空间和全局作用域中使用关键字static。</p>
<p><strong>名称空间指导原则</strong>：</p>
<ul>
<li>使用在已命名的名称空间中的变量，而不是使用外部全局变量。</li>
<li>使用在已命名的名称空间中的变量，而不是使用静态全局变量。</li>
<li>如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++当前提倡将标准函数库放在名称空间为std中，这种做法扩展到了来自C语言中的函数。</li>
<li>仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。</li>
<li>不要在头文件中使用using编译指令。首先这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include之后。</li>
<li>导入名称时，首选使用作用域解析操作符或using声明的方法。</li>
<li><strong>对于using声明，首选将其域设置为局部而不是全局</strong>。</li>
</ul>
<p><strong>老式头文件（如iostream.h)没有使用名称空间，但新头文件iostream使用了std名称空间。</strong></p>
<h3 id="10-对象和类"><a href="#10-对象和类" class="headerlink" title="10.对象和类"></a>10.对象和类</h3><p><strong>构造函数</strong>：专门用于构造新对象、将值赋给它们的数据成员。</p>
<ol>
<li>没有返回值，但没有被声明为void类型。实际上，构造函数没有声明类型。</li>
<li>当构造函数可使用一个参数时，接受一个参数的赋值句法来将对象初始化为一个值。如：ClassName obj = value;</li>
<li>如果没有定义任何构造函数，当构造函数被需要时，编译器会生成一个啥也不作的默认构造函数(比如生成对象数组时要使用构造函数)。若类定义了构造函数后，程序员就必须为它提供默认构造函数。</li>
<li>使用构造函数初始化对象。 </li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ClassName a = ClassName(value1, value2);   <span class="comment">//使用带参构造函数初始化对象a或临时对象(先初始化临时对象，再赋值给a对象，临时对象释放调用析构函数)，C++标准允许编译器使用两种方式来执行，第一种是直接初始化对象a,无临时对象，另一种是初始化临时对象，再赋值给对象a，然后临时变量调用析构函数释放。</span></div><div class="line"></div><div class="line"><span class="function">ClassName <span class="title">a</span><span class="params">()</span></span>;                             <span class="comment">//使用无参构造函数初始化对象a，没有临时对象产生。</span></div></pre></td></tr></table></figure>
<p><strong>析构函数</strong>：对象过期时，程序将自动调用一个特殊的成员函数，完成清理工作。</p>
<ol>
<li>析构函数没有返回值类型，没有参数，其名称为类名称前加上~，且每个类只能有一个析构函数。</li>
<li>如果创建的是静态存储对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时自动被调用。如果对象是通过new创建的，则它将驻留在堆栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动调用。</li>
<li>自动变量放在堆栈中，优先清理后定义的变量，因此最后创建的对象将最先被删除，最先创建的对象将最后被删除。</li>
</ol>
<p><strong>const成员函数</strong>：如果定义了一个ClassName类型的对象a,且修饰成const，那么对象a的成员变量不能改变，但如果调用其成员方法，不能确保方法不修改其成员变量。因些对于这些方法，使用const关键字，保证函数不会修改调用对象。声明和定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span><span class="keyword">const</span></span>;                <span class="comment">//类中声明</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> ClassName::fn(<span class="keyword">int</span>, <span class="keyword">float</span>)<span class="keyword">const</span>&#123;&#125;;   <span class="comment">//定义</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">const</span> Stock &amp; <span class="title">top</span><span class="params">(<span class="keyword">const</span> Stock &amp;s)</span><span class="keyword">const</span></span>;  <span class="comment">//括号中的const表明，该函数不会修改被显式地访问的对象，而括号后的const表明，该函数不会修改被隐式地访问的对象。由于该函数返回了二个const对象之一的引用，因些返回值类型也应为const引用。</span></div></pre></td></tr></table></figure>
<p><strong>this</strong>:this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）。</p>
<p>毕竟类的目标之一是使用户定义的类型与内置类型尽可能的相似，类的构造函数负责确保调用对象成员的构造函数。名为成员初始化列表的特性可提高构造函数设计的效率(因为对于基类部分与成员为类成员的部分，先于该类被初始化，然后再执行该类的构造函数对基本类型进行<code>赋值而非初始化</code>，如果类成员在构造函数中被赋值，则该成员类对象先在构造函数之前使用默认构造函数，在该类构造函数中被赋值)。</p>
<p><strong>类作用域</strong>：在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类之外是不可知的。</p>
<p><strong>作用域为整个类的常量</strong>：</p>
<ol>
<li><strong>在类中声明一个枚举</strong>：在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称。用这种方式声明枚举并不会创建类数据成员，也就是说，所有对象中都不包含枚举。另外，枚举常量只是一个符号名称，在作用域整个类的代码中遇到它时，编译器将用实际值来替换它。</li>
<li><strong>使用static关键字创建一个常量</strong>：该常量与静态变量存储在全局区，而不是存储在对象中。作用域为类作用域，存储在全局区，被这个类的所有对象共享。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="C++" scheme="http://LySnake.github.io/tags/c/"/>
    
      <category term="C++ Primer Plus" scheme="http://LySnake.github.io/tags/c-primer-plus/"/>
    
  </entry>
  
  <entry>
    <title>电脑小白系列之电脑常见错误诊断</title>
    <link href="http://LySnake.github.io/archives/technology/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD%E7%B3%BB%E5%88%97%E4%B9%8B%E7%94%B5%E8%84%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E8%AF%8A%E6%96%AD.html"/>
    <id>http://LySnake.github.io/archives/technology/电脑小白系列之电脑常见错误诊断.html</id>
    <published>2017-05-21T10:45:03.000Z</published>
    <updated>2018-02-24T13:23:49.958Z</updated>
    
    <summary type="html">
    
      先挖下坑
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
  </entry>
  
  <entry>
    <title>电脑小白之操作系统安装</title>
    <link href="http://LySnake.github.io/archives/technology/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD%E7%B3%BB%E5%88%97%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html"/>
    <id>http://LySnake.github.io/archives/technology/电脑小白系列之操作系统安装.html</id>
    <published>2017-05-05T17:34:38.000Z</published>
    <updated>2018-02-24T13:23:25.724Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍windows系统安装，以此让小白放心安装其它系统，比如手机Android、iOS，以及PC上的linux系统。<br><a id="more"></a></p>
<p>###操作系统的本质###<br>其实，说白了，操作系统也是一个软件，作为一个软件，你可以放心地在机器(PC、手机等)上卸载与安装，只是因为操作系统本身要管理计算机资源(软件、硬件)，其它软件或用户都要借助操作系统才能操作机器，所以操作系统的”卸载与安装”比其它软件更麻烦些，如果失败，机器会无法正常运行，也有可能因为操作失误，造成数据丢失，但这一切都不会影响电脑本身硬件，所以安装系统失败可以再交安装，因此在安装系统中最重要的就是小心误操作引起的数据丢失。另外，在手机上传说有自己安装系统，因为影响引导系统的软件从而导致无法再安装系统从而成为“砖块机”，不过这种情况目前也只是听过。</p>
<p>###PC安装windows方式###</p>
<p>####U盘PE系统安装####<br>这种方式安装windows系统，有个优点就是失败了，你还可以借助U盘PE系统进入PC，可以从PC的硬盘中再得到其它文件(包括安装使用的系统文件)，可以再次安装，对新手来说安装起来放心些。所以在这种U盘PE安装方式中，你可以多下载几个系统文件(支持<em>.ios或</em>.ghost),避免因某一系统文件安装失败而导致PC无法开机且难以更换另一系统文件。制件U盘PE系统，有很多软件，比较常见的有<a href="http://www.laomaotao.org/" target="_blank" rel="external">老毛桃</a>和【大白菜】(大白菜还是算了吧，网上有个一样内容的盗版网站，太难分辨了，假网站的系统文件如果自带电脑病毒，杀软也可能无力。这假网站还是百度加V的，所以百度有多差呢？)</p>
<p><a href="http://www.laomaotao.org/jiaocheng/92/upqdzz.html" target="_blank" rel="external">老毛桃制作U盘PE系统</a></p>
<p><a href="http://www.laomaotao.org/jiaocheng/92/upzwin7.html" target="_blank" rel="external">老毛桃安装windows 7系统</a></p>
<p>####U盘iso文件安装####<br>微软官方都是以光盘出售windows操作系统的，ghost文件都是网友自己二次制作或都说是备份系统文件，所以网上还有光盘copy下来的iso文件可供使用，但是这种文件默认是写在光盘上的，所以U盘iso安装其实就是把iso文件写入U盘中，以U盘冒充光盘，让计算机以读光盘的方式读U盘，从而操作官方的安装方式，最常见的系统文件都是iso文件，所以这种方式支持安装windows和linux等，只是写入U盘时对ULtraISO操作选择不同的引导选项。这种方式写入U盘，会导致U盘成为一个只有iso且不能再存文件的U盘，除非格式化(格式化如果失败，只能使用更强的格式化方式，比如linux下的dd命令)。</p>
<p><a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="external">UltraISO</a></p>
<p><a href="http://blog.csdn.net/baigoocn/article/details/47406473" target="_blank" rel="external">UltraISO制作U盘iso安装系统</a></p>
<p>####硬盘本地安装####<br>下载的iso文件(使用<a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="external">UltraISO</a>或<a href="https://daemon-tools.softonic.com.br/" target="_blank" rel="external">DAEMON Tools Lite</a>装载或解压，但别使用rar或7z，可能会有错误导致安装失败)或*.rar类文件，装载或解压后，在一级子目录下会有setup.exe类似的可执行软件，运行后会进入安装界面。这种方式简单，不要使用U盘，只要系统文件就好，但其实安装windows系统有时会因为系统文件缺失某些驱动，而导致安装失败，而此此时有可能处于安装到一半，导致原来的系统已破坏而不能开机。所以这种方式，推荐是在有安装经验的情况下再使用。</p>
<p>###系统安装注意事项###<br>综上，安装操作系统不会影响电脑硬件，正常情况只是导致破坏原有的操作和系统导致不能正常开机，你可以重新安装系统以恢复计算机。目前只是听过手机有操作失误导致破坏引导软件，引起不能再交安装系统而成为“砖机”，但这种情况还是很少出现。那，在安装系统的时候，最怕出现的是什么呢？</p>
<ul>
<li>对系统分区不了解，原本安装windows系统，只要安装在原来的C分区中，但在安装系统时，当时的C分区已经不显示C分区了，误操作安装系统到另一分区，导致把一分区格式化装了操作系统。</li>
<li>ghost有一种版本，似乎是针对电脑城全新安装系统用的，安装系统默认会对硬盘重新分区，导致硬盘数据全部丢失。</li>
<li>安装系统，默认会把安装系统的分区格式化，所以这个分区的用户数据要分备份，在安装windows中，C盘就是我们要安装的分区，要先备份C盘中的个人文件，比如常见的桌面上的文件、以及默认下载的文件目录等。</li>
</ul>
<p><strong>所以，安装系统最重要的就是要备份好自己的文件，数据无价</strong></p>
<p>###针对小白的虚拟机安装系统练习###<br>使用<a href="http://www.vmware.com/cn.html" target="_blank" rel="external">VMware</a>或<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">VirtualBox</a>虚拟软件，在windows系统上，进行安装虚拟系统，可以试着了解下安装系统会有什么操作、大概过程是什么，这种方式安装对现有系统很安装，要安装的虚拟系统与现在使用中的系统是完全分离的，不会影响现有分区与数据，仅会写入一个比较大的文件，但这个方式对于很老的电脑来说，可能会很卡。</p>
<p><a href="http://blog.xuite.net/yh96301/blog/30283132-VirtualBox+%E5%AE%89%E8%A3%9D+Windows+7+%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" target="_blank" rel="external">VirtualBox安装win7教程</a></p>
<p>###计算机多系统安装###<br>了解下<a href="http://cn.linux.vbird.org/linux_basic/0130designlinux_2.php#partition_mbr" target="_blank" rel="external">多系统引导</a>，可以实现在一个实体机中，同时安装windows、iOS、linux系多个系统，可以每次开机选择自己要进入的系统，实现windows日常使用，linux、iOS办公，当然，这个也可以装虚拟机。原理简单的说就是开机启动后，主板BOIS会读硬盘固定位置数据（引导程序代码），BOIS把CPU控制执行权交给引导程序，引导程序再从硬盘分区上找到安装了系统的的分区再把CPU控制权给操作系统，因此可以有多个分区分别装有不同的系统，让这引导程序引导进行选择运行哪个系统。</p>
<p><a href="http://msdn.itellyou.cn/" target="_blank" rel="external">正版windows系统文件下载</a></p>
<p><a href="http://cn.linux.vbird.org/linux_basic/0130designlinux_2.php#partition_table" target="_blank" rel="external">硬盘分区与引导程序</a></p>
<p><a href="http://neosmart.net/EasyRE/" target="_blank" rel="external">EasyBCD修复引导程序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍windows系统安装，以此让小白放心安装其它系统，比如手机Android、iOS，以及PC上的linux系统。&lt;br&gt;
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="电脑小白" scheme="http://LySnake.github.io/tags/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD/"/>
    
  </entry>
  
  <entry>
    <title>电脑小白系列之电脑硬件了解</title>
    <link href="http://LySnake.github.io/archives/technology/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD%E7%B3%BB%E5%88%97%E4%B9%8B%E7%94%B5%E8%84%91%E7%A1%AC%E4%BB%B6%E4%BA%86%E8%A7%A3.html"/>
    <id>http://LySnake.github.io/archives/technology/电脑小白系列之电脑硬件了解.html</id>
    <published>2017-02-19T09:46:46.000Z</published>
    <updated>2018-02-24T13:23:41.082Z</updated>
    
    <content type="html"><![CDATA[<p>本方主要讲下常用电脑中的硬件与相关功能，旨在了帮助小白了解计算机硬件。<br><a id="more"></a></p>
<h2 id="冯·诺伊曼结构"><a href="#冯·诺伊曼结构" class="headerlink" title="冯·诺伊曼结构"></a>冯·诺伊曼结构</h2><p>如今的计算机，都是以1945年6月30日冯·诺伊曼提出的基本结构：计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成。每个组成部分可能存在于一台计算机中不同硬件位置上。</p>
<blockquote>
<p><em>运算器、控制器（CPU）</em>：这二个基本部件，在工程实现上都存在于中央控制处理器CPU中，有任何操作请求，一定都会到CPU中请求处理。在实际用户操作中，所有用户操作，都会抽象成一系列的数学运算、逻辑运算，也都要交于CPU处理，所以CPU决定了计算机最高处理性能，在个人组装机中，优先选择的都是CPU，其次再选择其它硬件设备。</p>
<p><em>存储器</em>：存储器类别很多，在小白的眼里，只要记得内存、硬盘（移动硬盘）、U盘、固态硬盘(SSD)这几样就好了。按主流硬件读取速度来说，内存&gt;固态&gt;U盘&gt;硬盘，特殊一点的是内存是一个断电就会丢失存储数据的一个临时存储设备，充当CPU与硬盘（机械硬盘和固态硬盘）之间的高速缓存。个人电脑中所有数据都要从内存中读取进CPU再进行处理，但对于计算机来说，不一定要有内存计算机才能运行。</p>
<p><em>*输入设备</em>：输入设备常见的有键盘、鼠标、麦、触摸板、手写板，接收用户操作(转换成数据)给计算机进行处理。</p>
<p><em>*输出设备</em>：输出设备常见的有显示器、耳机，输出计算机处理后的数据，提供给用户进行交互操作。</p>
</blockquote>
<h2 id="电脑中常见硬件"><a href="#电脑中常见硬件" class="headerlink" title="电脑中常见硬件"></a>电脑中常见硬件</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>在个人计算中，中高端CPU都是使用Intel公司产品，中低端CPU都是使用AMD公司产品，目前组装个人电脑都是以i5往上走，i3很少使用了，在15年上市了新的Skylake系列，支持读取性能更高的内存条、更省电。个人电脑更像是一个集权的国家，CPU代表着中央政府，所有处理都要交于CPU处理、分发执行。另外，当前CPU也负责显示方面的计算,也就是说CPU内还有一个GPU，就是我们常说的集显，但因为GPU常计算小数类型的值，CPU主要是整数类型和逻辑值，另外也因为显示渲染在个人PC中越来越重要，产热也高，所以GPU可以单独有一个硬件，那就是显卡。这种问题常见于笔记本中，在买笔记本时，常说独显更好，是因为独立显卡有自己的内存条，且高端显卡的内存已经是第五代的DDR5了，有独显后，显卡和CPU都有各自的存储，并且，独显有自己更强更专一的渲染，不会占用CPU使用内存导致内存不足，也不会占用CPU的计算而延迟用户操作的响应。</p>
<h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>主板通常认为是载体就好了，类似于自行车的三角架一样，其它部件都要在其上搭载。通常CPU决定了计算机的计算性能，通过CPU引出的针角查看哪些主板能使用，另外，主板上也存在其它的芯片，用于辅助CPU进行控制用的，还自带声卡、网卡等，所以主板还负责网络接收与发送，数字信息转成音频信息等。不论是CPU、内存条、电源、显卡、硬盘、独立声卡、光驱等，都要与主板联接进行信息传输。电脑开关、USB接口、显示器接口、网线接口、耳机接口等都在主板上面。如果是台式电脑，所有的这些硬件接口都是规范化的，并且也是防呆设计(指接口设计避免用户插错，只有用蛮力才有可能插错)，不用担心插错问题。</p>
<h3 id="独立-显卡"><a href="#独立-显卡" class="headerlink" title="(独立)显卡"></a>(独立)显卡</h3><p>显卡负责图像的渲染，显示器显示的内容都是从显卡中获得。显卡插在主板上，对外可接显示器的信号线，显卡有自己独立的内存，就是我们说的显存，好的显卡已经使用第五代DDR5的内存，对于晃卡而言，并不是显存越大越好，显存大但速度慢一样是渣显卡，这也是电脑城骗术之一。但电脑是可以不用显卡的，可以使用集成显卡，也就是使用CPU内的GPU，不过这个就看CPU的性能与用户自己的需求了，玩大型游戏还是要独立显卡，如lol、使命等，日常看视频、QQ游戏等，集成显卡就好。</p>
<h3 id="内存条"><a href="#内存条" class="headerlink" title="内存条"></a>内存条</h3><p>前面提到过，内存是<code>一个断电就会丢失存储数据的一个临时存储设备，充当CPU与硬盘（机械硬盘和固态硬盘）之间的高速缓存</code>,目前老电脑都是4G内存，主流已经开始8G内存了，现如今手机都开始8G内存了。内存在计算机体系系统中，充当CPU与硬盘之间的高速缓存，对于计算机来说，内存越大越好，如果可以，操作系统会根据用户常用软件、文件等，尽可能把内存全部使用完。当前内存的速度在第三代内存DDR3的1600MHZ左右，新的Skylake系列支持第四代内存DDR4的2133MHZ。</p>
<h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>目前市场的机械硬盘都是1T，500G的机械硬盘开始减少，另外，还有固态硬盘(SSD)，读写速度是机械硬盘的好几倍，常见的还只是128G和256G，它们都是一种相对永久的存储设备，所有文件、软件都保存在硬盘中。现在，CPU和内存的性能都在快速提升，而机械硬盘受限于机械结构，读写速度提升相对过慢，已成为计算机体系的一个瓶颈，目前苹果电脑都配有固态硬盘，开机流畅响应快速，如果你也想有这样的电脑体验，请安装固态硬盘，把windows操作系统安装在固态硬盘中，常用软件也安装在固态硬盘中，如果还有机械硬盘，把不常用文件使用机械硬盘存储。另外，读写快速的固态硬盘，也只是能更快速地把文件从固态硬盘上读写到内存中，以此来加快开机速度和响应速度，但并不能改变CPU的执行速度和内存的读写速度，但确实会有更好的用户体验。</p>
<h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><p>显示器把显卡(集显或独显)处理过的显示数据通过旧的VGA接口或更高传输速率的HDMI接口传输到显示器进行显示，现在主流显示器有19寸、24寸甚至更大的，类型也很多样。如果细看电视机或显示器，是能看到很微小的点阵的，这个类似于图片或视频的1080 <em> 1920这种，表示有乘积个像素点，每个像素点使用RGB(红绿蓝)三色组成万千色，常见的每一色1个字节(8个bit即8位的2进制，如果一张图1080 </em> 1920 像素点，图片大小大概是1080 <em>  1920 </em> 3 / 1024 KB)，按色彩程度不同，共有256种，三色组合就有256 <em> 256 </em> 256种色彩，还有使用RGBA作为像素点数据的，只是多了一位A(透明度)。</p>
<h3 id="键盘、鼠标"><a href="#键盘、鼠标" class="headerlink" title="键盘、鼠标"></a>键盘、鼠标</h3><p>鼠标没有什么说的，都是光电鼠标，也有一些人体工程学鼠标，如果是玩游戏，鼠标还是要大一些的好用些，精度掌控更高。但是相对键盘而言就有很多讲头了。笔记本电脑和常见的100元以下的键盘，都是薄膜键盘，价格便宜，但是手感差，基本上也没有什么人体工程学上的设计，高端点的键盘，基本上都是机械键盘，手感多样，更适合打字、游戏等偏向，而且也更耐用(据说专业打字的也可以用50年这样的年限)，另外，机械键盘具有很高的自定义化，可以自己组装些背光灯、换键冒、换轴等，所以如果是只坏了几个键，也是可以自己行购买配件维修的。根据按键轴的不同，键盘会有不同的按键反馈，比如对于常打字的来说，青轴机械键盘每一次按键，都会有二次触感反馈，而且所需力道少，另外就是还有一个声音反馈。但机械键盘也有缺点，就是碰水就坏，主要生产轴的公司也就那么几家，国内的轴厂都太次了，容易坏轴，另一个就是价格比较高，cherry轴最低也要将近400元。那有其它一些键盘，水很深。不论是鼠标还是键盘，都是使用USB接口，老旧的有PS/2接口。</p>
<h3 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h3><p>电脑电源连接家庭用电，转化输出给CPU、主板、显卡、硬盘等供电，电脑正常运行与高速运行，它的耗电是不一样的，所以好的电源应能提供最高电量，如果电脑在高速运行中电源不能提供充足的电能，那可能会无由头的停机且不好查找问题。在某些装机教程中，作者会建议读者不要购买某宝或电脑城里已经组好的整机，因为你看到的电脑配置，主要配件确实是对应的配件，可是对于大多数的我们来说，卖家更老道，他们可以使用二手CPU、显卡，虽然它们是正品，又或者次品点的内存条，而买家都只是会看一般的参数，常见的就是下个鲁大师软件查看配置，这根本无法了解到卖家作了什么，而且一台电脑，可动手的地方很多，虽然主要配件最多是次品，部分配件因为不起眼，真的就有可能会成为电脑的短板。其中之一就是电源，一般买家没有谁看电源，而电源品牌也很混杂，就算一般买家查看了这点，你也就是看个功率，好像很强的样子，可是，关注过材料吗？铭牌参数具体的意义吗？电脑的参考功率，其中有很多文章，它的实际意义是说，各种组合最高是350W或500W，但其中还有转化率的问题，还有就是，每一种组合也有它的最大功能，不论是组合的还是最终的功能，都不能超。因为电源给CPU、主板、显卡、硬盘供电，也差不多这样分成组，CPU组不能超过多少，显卡供电不能超过多少，主板不能超过多少，各组之合不能超过电脑额定功率*转化率。所以对于一个500W的电源确不一定比350W的电源更适合你的电脑。另一方面，材料问题，线问题，接口问题，因此在某宝或电脑城购买已配好的电脑，不好花点时间自己组得更放心。</p>
<h2 id="引申链接"><a href="#引申链接" class="headerlink" title="引申链接"></a>引申链接</h2><p><a href="http://linux.vbird.org/linux_basic/0130designlinux.php#hardware" target="_blank" rel="external">&lt;鸟哥的linux私房菜&gt;中关于硬件的形象化描述</a><br><a href="http://linux.vbird.org/linux_basic/0510osloader.php#startup" target="_blank" rel="external">&lt;鸟哥的linux私房菜&gt;之开机流程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本方主要讲下常用电脑中的硬件与相关功能，旨在了帮助小白了解计算机硬件。&lt;br&gt;
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="电脑小白" scheme="http://LySnake.github.io/tags/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD/"/>
    
  </entry>
  
  <entry>
    <title>电脑小白系列之电脑日常管理</title>
    <link href="http://LySnake.github.io/archives/technology/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD%E7%B3%BB%E5%88%97%E4%B9%8B%E7%94%B5%E8%84%91%E6%97%A5%E5%B8%B8%E7%AE%A1%E7%90%86.html"/>
    <id>http://LySnake.github.io/archives/technology/电脑小白系列之电脑日常管理.html</id>
    <published>2017-02-09T13:03:48.000Z</published>
    <updated>2018-02-24T13:23:44.164Z</updated>
    
    <content type="html"><![CDATA[<p>在生活中经常会碰到电脑乱成一团，软件都是百度系，各种小广告软件，重复软件，一台电脑同时存在360、百度、腾讯、金山多家杀软，有这些特点的人大多是文科生为主，次之还有老一代人。对此，本文主要说些电脑文件管理、软件管理等常见的小白问题。<br><a id="more"></a></p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>打开<code>我的电脑</code>，可以看到C盘D盘等。一般的桌面上的所有文件也是存储于C盘用户目录下。计算机对于文件管理，是以树型结构进行管理的，每个盘符可以看做一个树根，其下的每个文件夹都可以看做是子树或形象点说是树枝，对于经常查看文件管理器的人来说，这已经是老生常谈，但我要说的是针对常用软件安装目录与个人文件保存问题。</p>
<blockquote>
<p><code>C盘</code>是安装windows系统的系统盘，基本都是大多数软件的默认安装盘，一般常见的安装系统C盘空间大小是50G，只要C盘还留有足够空间，系统并不提示C盘空间不足，那都是没关系的。操作系统windows大多数软件、文件、配置都保存在C盘中，比如office软件，系统自带的工具软件。但是现在的网络环境，很多软件都安装在C盘，个人下载也是默认在C盘，长时间使用C盘的软件，也会给C盘带来缓存文件，这样就会给C盘带来很多文件，当然，只要C盘有空间，这都是没关系的，只是个人下载文件、桌面文件都在C盘，如果电脑出现问题，需要重装系统解决，那么C盘将会清空并重新写盘，日常下载的文件、桌面文件都会清空且永久找不回。</p>
<p><code>其它盘</code>对widows来说，基本相同，除非是系统隐藏分区。安装windows系统，正常情况下都是只对C盘操作，其它盘文件都不作更改。因此，在日常管理上，个人重要文件尽量放在其它盘;其它软件，如视频软件、迅雷下载软件等，对其下载目录也最好是其它盘，且目录名可分辨。这样，自己下载的文件、个人编写的文件不会因为C盘的变动而被删除。</p>
<p><code>个人管理方案：</code>即然C盘是系统使用，那只有某些主要的软件才安装在C盘(输入法、杀毒、微软官方软件等)，其它软件全都安装在D盘的<code>Program Files (x86)</code>目录下，且保证每个软件都有一个单独的文件夹，对于下载文件、个人文件，都可存放与E盘或F盘，另外给每个盘符起个别名。各盘符大小，视个人情况而定。另外，还要说一点，对于丢失会带来重要影响的个人文件，最好是使用云盘备份（工程上都会有备份盘，甚至是异地备份盘），因为硬盘是PC机里最容易坏的硬件，同样的，如果文件过于私密，最好使用点加密手段。</p>
</blockquote>
<h2 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h2><p>鉴于国内的软件环境，尤其是百度系列，我们会发现，对于不常使用电脑的老年人、只用电脑看韩剧的软妹了，电脑中会出现过多无用或重复的软件。这里就说下软件使用问题，并自荐下<a href="https://lysnake.github.io/archives/technology/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90.html">个人常用软件列表</a>。</p>
<h3 id="杀毒软件"><a href="#杀毒软件" class="headerlink" title="杀毒软件"></a>杀毒软件</h3><p>其实吧，现在操作系统自身的防御能力已经很强了，不再经常看到电脑中毒了，虽然没有不存在BUG的软件(系统),但能找出BUG的人，都不是缺钱的主。现在如果说还有中毒的人，那真的是要找自己的原因，因为那都是自己进不该进的网站误下可执行的软件(病毒)。在windows下，对于小白来说，能遇见执行的病毒，都是exe为扩展名的可执行文件，所以如果上网下载的文件是exe文件，那么小白应该警惕，不要执行它，除非你知道会带来什么。但是，在生活中，小白都是金山、360、电脑管家、百度杀毒二个或多个重复杀毒功能的软件，大多情况下，其实他们并没有用，尤其是电脑管家和百度杀毒，反而会带来卡慢，百度杀毒更加是自身就是病毒。如果要安装，建议仅安装360或金山，自从win7开始，我就没怎么用杀毒软件了，但是金山和360杀毒其它管理功能还是很不错的，比如开机加速、强制删除文件等。</p>
<h3 id="重复软件"><a href="#重复软件" class="headerlink" title="重复软件"></a>重复软件</h3><p>前面提到杀毒软件功能重复，在小白的电脑中，同时存在360浏览器、橙子浏览器、chrome、firefox,这里也同样是重复功能的软件，占用硬盘空间并且有可能占用内存，导致操作响应过慢，个人推荐chrome或firefox，最新版的chrome和firefox能更好的支持网页渲染，看到更多网页特效，也能有更好的加载速度，更有强大的插件功能。明显的，每种功能的软件，正常情况下只要一个就好。对于已知无用的软件，占用了硬盘空间，如果开机自启，还会影响开机速度和占用内存，造成电脑卡慢，这个时候应该使用windows自带的软件管理工具或360、金山杀毒的软件管理工具，对无用软件进行卸载清除。</p>
<h3 id="软件黑名单"><a href="#软件黑名单" class="headerlink" title="软件黑名单"></a>软件黑名单</h3><p><strong>百度系</strong>是常见的软件黑名单，安装一个百度系软件，默认推荐安装其它软件，这就是为什么小白电脑里那么多不知用处的软件的原因，如果可以，尽量少用百度搜索，因为百度推荐、百度认证很有问题，并且搜索精准度并不高，在安装系统时使用的PE系统大白菜，百度认证认证的一个所谓的官网，居然是个高仿假网站，以此安装的系统，完全可能自带病毒、广告。16年的莆田系医院、血友病吧问题，有理由直接把百度直接拉入黑名单，目前已知百度好用的产品，也就只有百度云盘了。另外，如果你还是使用百度，建议你不要在网页上登录百度，因为你登录后，你在百度上搜索或其它百度网页操作的信息会被百度收集，然后进行所谓精准广告投放，而广告本身也存在很大的不可靠性，另外就是，你在网上所有的个人操作也是属于个人隐私，百度今天收集的信息，可能低价出售、安全原因泄漏等。不使用百度搜索了，大家可以使用bing搜索、google搜索，在<a href="https://lysnake.github.io/archives/technology/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90.html">个人常用软件列表</a>中提供了使用方式。</p>
<p><strong>不常见、非官网下载</strong>的软件，也会有默认安装好几个其它软件或带来很多广告，也有可能是病毒的载体，如果不是很清楚执行的后果，最好是不要下载并执行。</p>
<h2 id="电脑优化"><a href="#电脑优化" class="headerlink" title="电脑优化"></a>电脑优化</h2><p>个人电脑中，如果已经不存在多余的软件、软件安装不会使C盘出现空间警告、文件保存结构清晰，我们还可以开始进行其它电脑优化来进一步改善个人电脑环境。这个时候，我们就可以使用360杀毒或金山毒霸，进行开机启动项优化，选择自己开机一定会使用的功能软件，让其开机自启动，其它软件取消开机启动，这样能加快开机速度，减少开机后内存使用。同样也可以用360或金山扫盘、清除无用文件、查杀病毒、删除某些情况下无法删除的文件等。</p>
<p>像<a href="https://lysnake.github.io/archives/technology/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90.html">个人常用软件列表</a>提到过的软件一样，安装自己常用的软件，配置自己最习惯的软件环境，比如chrome插件、翻墙、wox快速启动软件、everything快速搜索本地文件、开机自启动、开机自动联网等。</p>
<h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><p><strong>硬盘碎片整理</strong>:网上很多人说硬盘读取过慢是因为分区使用久后，产生了很多文件碎片，导致硬盘寻道时间增长，这个说法是有道理的，但这个说法只适合机械硬盘，固态硬盘不适用。另外一点就是，碎片整理的概念已经很久了，而且硬盘读取速度一直都是计算机性能瓶颈，所以现在的硬盘和操作系统，在软件算法上会有相关优化，尽量减少碎片的产生，所以对于目前来说，是没有必要进行碎片整理的，而且这个操作过程中如果关机等特殊情况，是会影响操作系统或其它分区无法正常使用，如无必要，不要考虑碎片整理。另外，早上固态硬盘，可以得到更好的性能体验。</p>
<p><strong>缓存清理</strong>：其实对于用户而言，缓存的存在本身是为了让软件有更好的体验的，比如看视频，对于已缓存的时段，是可以直接跳看的，而没有缓存的部分，选择后还要等待网络加载后才能观看，而其它软件的缓存其实基本都是一样的道理，都是为了不重复从网络上加载或重新生成而影响软件响应用户的操作用的。但存在另外一些软件文件，仅仅是软件生成出来备用的，正常情况下是使用不到的，这类文件相对很少但可以删除，比如软件的log文件，方便软件崩溃时，上送Log日志给官方维护修改使用。缓存文件相对分区大小来说，还是占用很少一部分，在不使分区空间不足的情况下，也不用考虑操作删除缓存。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在生活中经常会碰到电脑乱成一团，软件都是百度系，各种小广告软件，重复软件，一台电脑同时存在360、百度、腾讯、金山多家杀软，有这些特点的人大多是文科生为主，次之还有老一代人。对此，本文主要说些电脑文件管理、软件管理等常见的小白问题。&lt;br&gt;
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="电脑小白" scheme="http://LySnake.github.io/tags/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD/"/>
    
  </entry>
  
  <entry>
    <title>常用软件推荐</title>
    <link href="http://LySnake.github.io/archives/technology/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD%E7%B3%BB%E5%88%97%E4%B9%8B%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90.html"/>
    <id>http://LySnake.github.io/archives/technology/电脑小白系列之常用软件推荐.html</id>
    <published>2017-02-06T07:09:00.190Z</published>
    <updated>2017-09-18T15:23:46.152Z</updated>
    
    <content type="html"><![CDATA[<p>分享与记录个人常用软件，包括widows、linux、chrome系,同样，如果您有更好的软件，还请在评论区分享出来。<br><a id="more"></a></p>
<h2 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h2><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><a href="https://www.zhihu.com/question/28013848" target="_blank" rel="external">如何高效地使用搜索引擎？</a>：来自zhihu的问答。</p>
<p><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="external">Proxy SwitchyOmega</a>:来自<a href="https://github.com/XX-net/XX-Net" target="_blank" rel="external">XX-Net</a>,插件单独使chrome使用XX-Net搭建梯子，也可以不使用插件，使PC全局智能上梯子。</p>
<p><a href="https://chrome.google.com/webstore/detail/clickclean/ghgabhipcejejjmhhchfonmamedcbeod" target="_blank" rel="external">Click&amp;Clean</a>:管理工具，可管理chrome，也可以管理PC设备。</p>
<p><a href="https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj" target="_blank" rel="external">Save to Pocket</a>:pocket，可存网页到网上，支持iOS、安卓平台，支持zhihu等APP或网页分享到pocket APP。</p>
<p><a href="https://chrome.google.com/webstore/detail/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E5%8A%A9%E6%89%8B%EF%BC%9Abilibilicom-%E7%BB%BC%E5%90%88%E8%BE%85%E5%8A%A9%E6%89%A9%E5%B1%95/kpbnombpnpcffllnianjibmpadjolanh" target="_blank" rel="external">嗶哩嗶哩助手</a>:B站，看直播可自动化领取瓜子等。</p>
<p><a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm" target="_blank" rel="external">擴充功能uBlock Origin</a>:一款高效率的廣告攔截工具。</p>
<p><a href="https://chrome.google.com/webstore/detail/dream-afar-new-tab/henmfoppjjkcencpbjaigfahdjlgpegn" target="_blank" rel="external">遠方 New Tab</a>:打开一个新标签页，背景图都是实时更新的美图，与<a href="https://juejin.im/extension/?utm_source=extension&amp;utm_medium=zhihu&amp;utm_campaign=20595240" target="_blank" rel="external">掘金</a>冲突。</p>
<p><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="external">Octotree</a>:在<a href="www.github.com">github</a>上，打开一个项目，能在左侧以windows资源管理器一样以树状图显示项目文件结构。</p>
<p><a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad?hl=zh-CN" target="_blank" rel="external">WEB前端助手(FeHelper)</a>:前端会用到的小工具。</p>
<p><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="external">Tampermonkey</a>:很强大的插件，允许运行JS充当功能，相关JS文件可以去<a href="https://greasyfork.org/zh-CN" target="_blank" rel="external">Greasy Fork</a>下载，比如一些特殊网站的JS，免登录使用zhihu，购物党比价工具、下载youtube视频等。</p>
<p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=zh-CN" target="_blank" rel="external">Vimium</a>:游览网站像操作vim一样操作。</p>
<p><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" target="_blank" rel="external">google翻译</a>:翻译网页或选中字词或短语时翻译。</p>
<p><a href="https://juejin.im/extension/?utm_source=extension&amp;utm_medium=zhihu&amp;utm_campaign=20595240" target="_blank" rel="external">掘金</a>：在新标签页展示内容，为设计师、程序员、产品经理每日发现优质内容。与<a href="https://chrome.google.com/webstore/detail/dream-afar-new-tab/henmfoppjjkcencpbjaigfahdjlgpegn" target="_blank" rel="external">遠方 New Tab</a>冲突。</p>
<p><a href="https://chrome.google.com/webstore/detail/send-to-kindle-by-klipme/ipkfnchcgalnafehpglfbommidgmalan" target="_blank" rel="external">Send to Kindle</a>:一键发送网页文章到Kindle阅读器。</p>
<p><a href="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien" target="_blank" rel="external">Isometric Contributions</a>:让你在GitHub上的commit像盖楼一样的展示，很有趣，展示下Android大神Jake Wharton的commit情况。</p>
<p><a href="https://github.com/anasnakawa/chrome-github-avatars" target="_blank" rel="external">Avatars for Github</a>:顾名思义，默认我们在GitHub主页动态只能看到id的，而安装了这个插件就可以看到GitHub头像了.</p>
<p><a href="https://chrome.google.com/webstore/detail/%E7%9F%A5%E4%B9%8E%E5%A4%B4%E5%83%8F%E6%94%BE%E5%A4%A7%E5%99%A8/iodddkdbdgcmepjlfieigdigioepgibn?hl=zh-CN" target="_blank" rel="external">知乎头像放大器</a>:把用户头像放大，比直接打开链接还要大。</p>
<p><a href="https://www.zhihu.com/question/23228162" target="_blank" rel="external">chrome有哪些好用的插件</a></p>
<hr>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p><a href="https://www.zhihu.com/question/32129337" target="_blank" rel="external">如何优雅使用windows 10</a>:来自zhihu的问答。</p>
<p><a href="https://atom.io/" target="_blank" rel="external">Atom</a>：Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。</p>
<p><a href="http://www.scootersoftware.com/download.php" target="_blank" rel="external">BCompare</a>：跨平台的文件比较工具。</p>
<p><a href="http://download.pchome.net/system/treak/detail-4359.html" target="_blank" rel="external">EasyBCD</a>:修改PC上多个系统引导程序，选择默认系统引导。</p>
<p><a href="https://www.voidtools.com/downloads/" target="_blank" rel="external">Everything</a>:windows下文件搜索工具，比系统默认的文件检索快得多且支持正则表达式，但不支持文件内容检索，windows自带的检索工具可以设置成检索文件内容。</p>
<p><a href="http://pan.baidu.com/s/1eSJZ9cu" target="_blank" rel="external">SourceInsight</a>:多语言代码编辑工具，支持代码高亮，定义跳转，全局搜索，但对中文支持不太好。</p>
<p><a href="http://pan.baidu.com/s/1hsHnIb6" target="_blank" rel="external">UltraISO</a>:打开ISO文件工具。</p>
<p><a href="https://zh.dvdfab.cn/" target="_blank" rel="external">dvdfab</a>:好用的ISO文件工具。</p>
<p><a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ch=&amp;tn=baiduhome_pg&amp;bar=&amp;wd=VMware+%E4%B8%8B%E8%BD%BD&amp;rsv_spt=1&amp;oq=fireworks+%E4%B8%8B%E8%BD%BD&amp;rsv_pq=fe1db2c5000198ef&amp;rsv_t=0101HNZP1hokgvnDfCG5xUelLKmDrgNQ31p4elzWh%2FMLyL2eWO6YmVnLIVHSDnA1sy9O&amp;rqlang=cn&amp;rsv_enter=0&amp;inputT=3987" target="_blank" rel="external">VMware</a>:虚拟机软件，在win下的该软件里再安装其它操作系统，但现在windows 10已经有linux子系统了，现在一般可以不用选择这个方案。</p>
<p><a href="http://download.flvcd.com/" target="_blank" rel="external">硕鼠</a>:支持多个网站的在线视频下载。</p>
<p><a href="http://music.163.com/" target="_blank" rel="external">网易云音乐</a>:美观、友好、歌曲推荐算法强。</p>
<p><a href="http://foxmail.com.cn/" target="_blank" rel="external">FoxMail</a>:本地mail客户端。</p>
<p><a href="https://github.com/Wox-launcher/Wox/releases" target="_blank" rel="external">Wox</a>:功能如Mac下的Alfred，使用alt+space可以启用该程序，可以快速检索本地文件、程序并启用，不再频繁操作鼠标和查找文件(检索使用了Everything)。并有大量插件、自定义一些操作，也有默认常用操作，如：g github即为google检索github。</p>
<p><a href="http://www.listary.com/" target="_blank" rel="external">Listary</a>:如功能和Wox一样，但是匹配没有Wox好。来自<a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao的博客</a>。</p>
<p><a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">SourceTree</a>:git应用Gui程序，支持windows、iOS平台。</p>
<p><a href="http://www.xitongcheng.com/jiaocheng/win10_article_27723.html" target="_blank" rel="external">Ubuntu on Windows</a>:在windows 10下安装ubuntu子系统，即可不用虚拟机，也能有linux环境，可用于开发。但目前该系统还有很多坑要填，而且下载也是要win搭个梯子。</p>
<p><a href="http://www.vim.org/download.php" target="_blank" rel="external">Gvim</a>:win下的GUI VIM，如果不是一定要vim才能快速编辑或能熟练使用，还是不要在win下使用vim，相对不是那么友好。(比如常算之后多少个char，使用vim还是很快的)</p>
<p><a href="http://cn.ejie.me/" target="_blank" rel="external">Clover</a>:让windows系统的文件管理器像chrome一样，支持多标签页功能，目前还有不少BUG，但对于常打开多个窗口查找文件来说，还是十分方便。</p>
<p><a href="http://www.huyanbao.com" target="_blank" rel="external">护眼宝</a>：修改屏幕色彩，相传更护眼。有Android、iOS、MAC、windows版。</p>
<p><a href="https://www.teamviewer.com/zhcn/" target="_blank" rel="external">TeamViewer</a>:远程控制，内网穿透，VPN共享，跨平台.对个人免费。目前没有使用过，来自<a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao的博客</a>。</p>
<p><a href="https://anydesk.com/remote-desktop" target="_blank" rel="external">AnyDesk</a>:远程控制效果或许会超出你的想象，作为TeamViewer备用方案,来自<a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao的博客</a>。</p>
<p><a href="http://sunlogin.oray.com/zh_CN/" target="_blank" rel="external">向日葵</a>:官网信息(远程手机操作PC开机，控制)，来自<a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao的博客</a>。</p>
<p><a href="http://www.cockos.com/licecap/" target="_blank" rel="external">licecap</a>:Gif文件录制工具。</p>
<p><em>Powertool</em>:系统清理工具。</p>
<hr>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">zsh</a>:更友好的shell(漂亮的themes，更多的输入匹配)。</p>
<p><a href="https://github.com/DemonCloud/Aix-Vim" target="_blank" rel="external">vim</a>:linux下最常用的编辑器，代码高亮，跳转，IDE界面等，只是要配置成自己更适合的还要多去踩坑。</p>
<hr>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="云梯"><a href="#云梯" class="headerlink" title="云梯"></a>云梯</h3><p><a href="https://github.com/XX-net/XX-Net" target="_blank" rel="external">XX-Net</a>：免费使用google的AppID,每个ID有1G，每个google帐号最多12个AppID，网络速度不错，youtube也能看视频，优点是每天早上可更新流量，且支持chrome、firefox。</p>
<p><a href="https://github.com/getlantern/forum#%E8%93%9D%E7%81%AFlantern%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD" target="_blank" rel="external">蓝灯(Lantern)</a>:免费情况下每月800M，速度不错，优点搭建快速。</p>
<p><a href="https://github.com/softwaredownload/openwrt-fanqiang" target="_blank" rel="external">openwrt</a>:实现路由器自动云梯，且因内置linux系统，可定制化功能，比如外接硬盘当网盘、自动下载BT等。但路由器成本不低，适合居家使用，未曾试用过。</p>
<p><a href="https://uzer.me/" target="_blank" rel="external">UZER.ME</a>:云端软件，常见的如chrome、AI、PS等与办公想关。默认翻墙chrome可以进google、youtube。</p>
<p><a href="https://wsgzao.github.io/post/fq/" target="_blank" rel="external">更多梯子</a>:这里罗列的方案，大都末使用过。</p>
<h3 id="数据备份恢复"><a href="#数据备份恢复" class="headerlink" title="数据备份恢复"></a>数据备份恢复</h3><p>数据备份软件来自<a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao的博客</a>,没有使用过。</p>
<p><a href="http://www.onekeyrestore.cn/" target="_blank" rel="external">易数一键还原</a>:以DiskGenius为内核开发，安全易用靠谱,同时推荐ORM一键还原系统。</p>
<p><a href="http://www.diskgenius.cn/" target="_blank" rel="external">DiskGenius</a>:国内磁盘分区和数据恢复的佼佼者,Mod By MyCrack.</p>
<p><a href="http://www.0daydown.com/?s=EaseUS+Data+Recovery" target="_blank" rel="external">EaseUS Data Recovery Wizard</a>:原先是国产易我数据恢复，现在依旧犀利啊</p>
<h3 id="其它网友环境"><a href="#其它网友环境" class="headerlink" title="其它网友环境"></a>其它网友环境</h3><p><a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao推荐的软件</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享与记录个人常用软件，包括widows、linux、chrome系,同样，如果您有更好的软件，还请在评论区分享出来。&lt;br&gt;
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
  </entry>
  
  <entry>
    <title>Github Pages与Hexo框架博客的搭建</title>
    <link href="http://LySnake.github.io/archives/technology/Github%20Pages%E4%B8%8EHexo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA.html"/>
    <id>http://LySnake.github.io/archives/technology/Github Pages与Hexo框架博客的搭建.html</id>
    <published>2017-01-22T18:45:57.418Z</published>
    <updated>2017-02-02T05:10:19.747Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文的目的不是<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>与<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo框架</a>框架搭建个人博客的教学，毕竟官网教学更详细更全面，而是记录本人搭建过程中了解、学习并汇总的一些东西，附带链接陈列出来，主要供第一次搭建的朋友参考学习。<br><a id="more"></a></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="git与github"><a href="#git与github" class="headerlink" title="git与github"></a>git与github</h3><p>git:查看廖雪峰的<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000" target="_blank" rel="external">git简介</a>。<br>git工具是Linus继linux开源操作系统之后又一影响世界的项目，因与linux的关系，所以本身是命令行模式，对大多数人来说是不够友好的，在实际使用中可以使用windows或iOS平台上的桌面软件，虽然这样并不能使用git的全部功能。<a href="https://www.github.com/" target="_blank" rel="external">Github</a>就是使用git的通信协议，得力于开源精神而创建的一个平台，并且linux项目也在<a href="https://www.github.com/" target="_blank" rel="external">Github</a>上托管，我们可以使用桌面软件<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">Source Tree</a>管理我们在<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>上的博客项目。</p>
<p>学习成本：初期算半天吧，git重操作，前期学习<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的git教学</a>了解基本理念，之后以多用多学为主，不会咱可以google。</p>
<h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><p><a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>具体信息查看官网是最权威的，这里提出为何使用Github Pages搭建博客的原因：</p>
<ul>
<li>版本管理：<a href="www.github.com">github</a>是目前程序员最火的一个免费的版本管理平台，所谓版本管理，主要是针对文本文档的管理，解决多人、异地、长时间维护共同项目文档所带来的问题，并因为开源精神，所以Free(免费且自由)。</li>
<li>展示：<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>是给<a href="www.github.com">github</a>中用户或项目的一个展示项目，并免费提供300M空间，就项目而言，提供项目介绍与使用相关，对于个人而言可以作为博客，分享知识，也有利于他人了解自己。</li>
<li>全球优良的网络：这个平台是程序员为主的平台，有google、微软等众多一线科技公司在这发布开源项目，也有现今互联网基石linux在其平台进行管理，而且也是技术界大佬建立的公司，在全球都拥有很好的网络连接。</li>
<li>学习：<a href="www.github.com">github</a>上有很多开源的项目，因此也提供了很多开源的软件，比如<a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="external">wox</a>方便windows更好的打开应用。同样，<a href="www.github.com">github</a>也是程序员学习，创建开源项目的地方，可以与他人一同开发、维护开源项目，这其中必不可少的使用git版本管理工具。</li>
<li>其他领域：<a href="www.github.com">github</a>同样开始影响其他领域，可以一起创建项目翻译国外文档、写小说、写项目说明。学习并使用github或许能学习到不一样的知识。参考<a href="https://www.gitbook.com/" target="_blank" rel="external">gitbook</a></li>
<li>搭建学习成本：根据<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>创建<a href="www.github.com">github</a>帐号，Github Pages项目，不到一小时。</li>
</ul>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p><a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>中介绍使用Jekyll框架，因为勘察时感觉对于个人博客而言Jekyll的主题不够华丽，而后选择了<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo框架</a>。在使用上，需要安装Node.js，以命令行的形式使用，对于没有使用过命令行操作电脑的小伙伴还是有点不友好的。对于windows用户可以使用<a href="https://github.com/cmderdev/cmder" target="_blank" rel="external">cmder</a>代替CMD。win7以上可以使用powershell。对于什么是命令行，使用win + R组合键再输入cmd，看到的界面就是命令行界面，以输入字符的方式操作电脑。</p>
<p><strong>学习成本</strong>：参考<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="external">Hexo命令</a>,命令行常用操作也就只有一个网页，常用不到5个命令。但了解、熟悉并使用一定的自定义要看个人。全部搭建完花费4天时间。以后只要编写markdown文档和常用几个命令了。</p>
<h3 id="静态网站"><a href="#静态网站" class="headerlink" title="静态网站"></a>静态网站</h3><p><strong>个人在该博客中对静态、动态网站的理解</strong>：对于浏览器而言是没有多大的区别，相关的也就是使用中要与服务器发送或接收数据，对于服务器而言，静态网页差不多就是网络端存储了些网页相关的资源文件，如html、css、js、图片等，服务器主要响应文件请求与发送；而对于动态网站，我们可以参考QQ空间，每个人的空间基本结构是一样的，但是每个人每个时间点显示的信息都是不一样的，这是因为后台使用PHP、Python、Java等web服务器，在每个用户请求页面时通过与数据库交互，获取特定数据再生成特定资源文件(html、css等)发送到用户浏览器。</p>
<h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p><a href="http://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="external">Markdown</a>官方：</p>
<blockquote>
<p>Markdown 的目标是易于阅读, 创作和编辑文章. HTML 是一种 发布 格式; Markdown 是一种 创作 格式. 因此, Markdown 处理的都是纯文本。</p>
</blockquote>
<p>目前，已知在<a href="www.github.com">github</a>上的项目介绍文件，就是使用Markdown，并且在项目相关的issues等一些文字发布区域，也支持Markdown的编写与预览。其他网站也有推荐使用Markdown进行回答、评论、书写，比如<a href="http://www.jianshu.com/p/d62ca374c90f" target="_blank" rel="external">简书</a>，而我们搭建的博客，就是通过使用Markdown编写成源文件，通过<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo框架</a>与<a href="https://hexo.io/themes/" target="_blank" rel="external">相关主题</a>生成静态网页，再更新到<a href="www.github.com">github</a>个人博客项目库中。并且Markdown可以通过更多插件，提供更多功能，可以预见的是，Markdown将会越加火热。</p>
<p><strong>学习成本</strong>：半天，与git一样，初步了解后多写多练，不会或者忘记勤查文档。</p>
<h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><h3 id="Hexo本地工程目录"><a href="#Hexo本地工程目录" class="headerlink" title="Hexo本地工程目录"></a>Hexo本地工程目录</h3><p>参考<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="external">Hexo建站</a>,假设我们在HexoInit目录下使用<code>hexo init</code>命令来初始化Hexo工程，参考<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">Hexo配置</a>设置配置文件，在HexoInit目录下，我们可以看到:</p>
<ul>
<li>node_modules目录：该目录是npm下载的一些插件，不需直接管理，如有添加、删除应尽量使用npm命令。</li>
<li>public目录：当使用<code>hexo g</code>命令后，会生成静态站相关文件，先通过<code>hexo s</code>本地查看页面，以便修改，最后直接把该目录所有文件上传（commit）到<a href="www.github.com">github</a>个人博客项目，然后再访问。</li>
<li>scaffolds目录：该目录存放模板，模板文件是markdown文件<code>*.md</code>，初始化时已存在三个模板文件，分别对应三个<code>layout</code>。现假设我们有模板jottings.md,内容如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">layout: post</div><div class="line">title: &#123;&#123; title &#125;&#125;</div><div class="line">date: &#123;&#123; date &#125;&#125;</div><div class="line">update: &#123;&#123; updated &#125;&#125;</div><div class="line">comments: false</div><div class="line">categories:</div><div class="line">  - archives</div><div class="line">  - jottings</div><div class="line">tags:</div><div class="line">---</div></pre></td></tr></table></figure>
<p>当使用<code>hexo new jottings fileName</code>命令时，就会以jottings.md的内容生成一个fileName.md文件在source/_posts/目录下，相关配置参考<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="external">Front-matter</a>。</p>
<ul>
<li>source目录：存放使用markdown编写的源文件，当使用<code>hexo g</code>命令生成public目录文件时，Hexo和主题就会使用source目录中的*.md文件生成最后的静态网页文件，其下子目录分布与layout有关。</li>
<li>themes目录：存放配置主题，相关说明见<a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="external">Hexo主题说明</a>。</li>
<li>_config.yml文件：这是Hexo本地工程的配置文件，相关使用说明参考<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">Hexo配置</a></li>
<li>db.json文件：缓存文件，使用<code>hexo clean</code>会清除，使用<code>hexo g</code>时会生成。</li>
<li>package.json文件：该本地工程npm配置文件，记录了node_modules目录安装的插件，如果存在一份配置好的package.json文件，可以直接在HexoInit目录下使用<code>npm install</code>命令读取配置文件安装相关插件。</li>
</ul>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>node_modules目录内容可以根据package.json生成，public目录根据source目录生成，所以我们应备份source目录与_config.yml、package.json二个文件，另外，如果有定制化的scaffolds目录文件，也要备份，以便于今后重建工程时能快速搭建。</p>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>该博客使用的是<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="external">yelee主题</a>，<a href="https://hexo.io/themes/" target="_blank" rel="external">更多主题选择</a>,选择自己喜欢的主题，参考<a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="external">Hexo主题说明</a>配置，一般一个完善的主题会有使用帮助，具体配置，如<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="external">yelee使用说明</a>。在yelee使用说明中，可以查看主题完成显示相关，个性化相关的一些配置，也集成了一些第三方服务与评论系统。</p>
<h2 id="相关帮助连接"><a href="#相关帮助连接" class="headerlink" title="相关帮助连接"></a>相关帮助连接</h2><ul>
<li><a href="https://github.com/getlantern/forum#%E8%93%9D%E7%81%AFlantern%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD" target="_blank" rel="external">蓝灯番墙</a></li>
<li><a href="https://wsgzao.github.io/post/fq/" target="_blank" rel="external">更多番墙方案</a>:个人使用XX-NET</li>
<li><a href="www.github.com">github</a></li>
<li><a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的git教学</a></li>
<li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo官网</a></li>
<li><a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo主题</a></li>
<li><a href="http://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="external">Markdown官方教程</a></li>
<li><a href="https://github.com/cmderdev/cmder" target="_blank" rel="external">cmder</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="external">阮一峰博客-Github Pages搭建博客入门</a></li>
<li><a href="https://wsgzao.github.io/post/hexo-guide/" target="_blank" rel="external">使用GitHub和Hexo搭建免费静态Blog</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文的目的不是&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;与&lt;a href=&quot;https://hexo.io/zh-cn/docs/index.html&quot;&gt;Hexo框架&lt;/a&gt;框架搭建个人博客的教学，毕竟官网教学更详细更全面，而是记录本人搭建过程中了解、学习并汇总的一些东西，附带链接陈列出来，主要供第一次搭建的朋友参考学习。&lt;br&gt;
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="Github Pages" scheme="http://LySnake.github.io/tags/github-pages/"/>
    
      <category term="Hexo" scheme="http://LySnake.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
