<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LySnake个人博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://LySnake.github.io/"/>
  <updated>2017-06-26T13:49:11.671Z</updated>
  <id>http://LySnake.github.io/</id>
  
  <author>
    <name>LySnake</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ Primer Plus学习笔记(4)</title>
    <link href="http://LySnake.github.io/archives/technology/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4).html"/>
    <id>http://LySnake.github.io/archives/technology/C++ Primer Plus学习笔记(4).html</id>
    <published>2017-06-19T14:28:39.997Z</published>
    <updated>2017-06-26T13:49:11.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="14-C-中的代码重用"><a href="#14-C-中的代码重用" class="headerlink" title="14 C++中的代码重用"></a>14 C++中的代码重用</h2><h3 id="14-1-包含对象成员的类"><a href="#14-1-包含对象成员的类" class="headerlink" title="14.1 包含对象成员的类"></a>14.1 包含对象成员的类</h3><p><strong>has-a</strong>:本身是另一个类的对象的成员变量。这种方法称为包含、组合或层次化。另一种方法是通过私有或保护继承。获得接口是is-a关系的组成部分。而使用组合，类可以获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。</p>
<p><strong>多重继承</strong>：使得能够使用两个或更多的基类派生出来新的类，将基类的功能组合在一起。</p>
<p>模板特性意味着声明对象时，必须指定具体的数据类型。</p>
<p>对于继承的基类对象部分，构造函数在成员初始化列表中使用类名来调用特定的基类构造函数。对于成员对象，在成员初始化列表中使用成员名调用构造函数。C++要求在构建对象的其它部分之前，先构建继承对象的所有成员对象。因此，如果初始化列表未显式初始化成员对象，C++将使用成员对象类的默认构造函数。</p>
<h3 id="14-2-私有继承"><a href="#14-2-私有继承" class="headerlink" title="14.2 私有继承"></a>14.2 私有继承</h3><p>C++还有另一种实现has-a关系的途径–私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。</p>
<p>使用公有继承，基类的公有方法将成为派生类的公有方法。简而言之，派生类将继承基类的接口：这是is-a关系的一部分。使用私有继承，基类的公有方法将成为派生类的私有方法，简而言之，派生类不继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。</p>
<p>包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。</p>
<p>当在头文件使用class声明派生类时，如果没有使用public等关键字声明如何继承基类，则以默认以private方式继承。</p>
<p>使用多个基类的继承被称为多重继承（multiple inheritance,MI）.</p>
<p>对于继承基类的对象部分，使用初始化列表方法，使用基类的构造函数初始化基类的对象部分。</p>
<p>私有继承时，通过强制类型转换访问基类对象部分。</p>
<p>用类名显式地限定函数名不适合于友元函数，这是因为友元不属于类。不过，可以通过显式地转换为基类来调用正确的函数。在私有继承中，在不进行显式类型转换的情况下，不能将指向派生类的引用或指针赋给基类引用或指针(基类公有方法通过私有继承成为派生类的私有方法，不具有is-a关系)。另外，由于派生类使用的是多继承，编译器将无法确定应转换成哪个基类，如果两个基类都提供了相同的函数。</p>
<p>类声明中包含表示被包含类的显式命名对象，代码可以通过名称引用这些对象，而 使用继承将使关系更抽象。其次，继承会引起许多问题，尤其从多个基类继承时，可能必须处理许多问题，例如包含同名方法的独立的基类，或共享祖先的独立的基类。另外，包含能够包括多个同类的子对象。如果某个类需要3个string对象，可以使用包含声明3个独立的string成员。而继承则只能使用一个这样的对象(当对象都没有名称时，将难以区分)。</p>
<p>类包含保护成员(可以是数据成员，也可以成员函数)，则这样的成员在派生类中是可用的，但在继承层次结构外是不可用的。如果使用组合将这样的类包含在另一个类中，则后者将不是派生类，而是位于继承层次结构之外，因此不能访问保护成员。但通过继承得到的将是派生类，因此它能够访问保护成员。另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是公有的。(通常，应使用包含建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承)</p>
<h3 id="14-3-保护继承"><a href="#14-3-保护继承" class="headerlink" title="14.3 保护继承"></a>14.3 保护继承</h3><p>保护继承是私有继承的变体。保护继承在列出基类时使用关键字protected.</p>
<p>使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员。和私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的。当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别便呈现出来了。使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的公有方法在派生类中将变成私有方法；使用保护继承时，基类的公有方法在第二代中将变成受保护的，因此第三代派生类可以使用它们。</p>
<table>
<thead>
<tr>
<th style="text-align:center">特征</th>
<th style="text-align:center">公有继承</th>
<th style="text-align:center">保护继承</th>
<th style="text-align:center">私有继承</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">公有成员变成</td>
<td style="text-align:center">派生类的公有成员</td>
<td style="text-align:center">派生类的保护成员</td>
<td style="text-align:center">派生类的私有成员</td>
</tr>
<tr>
<td style="text-align:center">保护成员变成</td>
<td style="text-align:center">派生类的保护成员</td>
<td style="text-align:center">派生类的保护成员</td>
<td style="text-align:center">派生类的私有成员</td>
</tr>
<tr>
<td style="text-align:center">私有成员变成</td>
<td style="text-align:center">只能通过基类接口访问</td>
<td style="text-align:center">只能通过基类接口访问</td>
<td style="text-align:center">只能通过基类接口访问</td>
</tr>
<tr>
<td style="text-align:center">能否隐式向上转换</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是（但只能在派生类中）</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p><strong>将函数调用包装在另一个函数调用中，即使用一个using声明（就像名称空间那样）来指出派生类可以使用特定的基类成员(使用using声明基类成员函数的作用域)，即使采用的私有派生。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Student: <span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span> ,<span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;</div><div class="line">&#123;</div><div class="line">   pulibc:</div><div class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::min; </div><div class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::min;</div><div class="line">   <span class="comment">//something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>using声明只使用成员名—没有圆括号、函数牲标和返回类型。using声明只适用于继承，而不适用于包含。</p>
<h3 id="14-3-多重继承"><a href="#14-3-多重继承" class="headerlink" title="14.3 多重继承"></a>14.3 多重继承</h3><p>MI描述的是有多个直接基类的类。与单继承一样，公有MI表示的也是is-a关系。必须使用关键字public来限定每一个类。这是因为除非特别指出，否刚编译器将使用默认的私有派生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Worker&#123;&#125;;</div><div class="line"><span class="keyword">class</span> Singing :<span class="keyword">public</span> Worker&#123;&#125;;</div><div class="line"><span class="keyword">class</span> Waiter  :<span class="keyword">public</span> Worker&#123;&#125;;</div><div class="line"><span class="keyword">class</span> SSingingWaiter :<span class="keyword">public</span> Singing, <span class="keyword">public</span> Waiter&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//示例</span></div><div class="line">SingingWaiter ed;</div><div class="line"><span class="comment">//有歧义</span></div><div class="line">Worker * pw = &amp;ed;</div><div class="line"><span class="comment">//正确方式</span></div><div class="line">Worker *pw1 = (Waiter *)&amp;ed;</div><div class="line">Worker *pw2 = (Singing *)&amp;ed;</div></pre></td></tr></table></figure>
<p>通常这种赋值将反基类指针设置为派生对象中的基类的地址。但ed中包含两个Worker对象，有两个地址可供选择，所以应使用类型转换来指定对象。这将使得基类指针来引用不同的对象(多态性)复杂化。</p>
<p>当C++引入多重继承的同时，它引入了一种新技术—虚基类(virtual base class)，使MI成为可能。</p>
<p><strong>虚基类</strong>：虚基类使得从多个类(它们的基类相同)派生出的对象只继承一个基类对象。从本质上说，继承的Singing和Waiter对象共享一个Worker对象，而不是各自引入自己的Worker对象的拷贝。因为SingingWaiter现在只包含一个Worker对象。所以可以使用多态。</p>
<p>为什么不抛弃将基类声明为虚拟的这种方式，而使虚拟行为成为MI准则呢？第一，在一些情况下，可能需要基类的多个拷贝；第二，将基类作为虚拟的要求程序员完成额外的计算，为不需要的工具付出代价是不应该的；</p>
<p>使用虚基类时，需要对类构造函数采用一种新的方法。对于非虚基类，惟一可以出现在初始化列表中的构造函数是相临基类构造函数。但这些构造函数可能需要将信息传递给其基类。C++在基类是虚拟时，禁止信息通过中间类自动传递给基类，可以在初始化列表中使用基类的基类的构造函数，来完成祖父虚拟基类对象部分的初始化(非虚拟基类不可使用该方法)。</p>
<p>在祖先相同时，使用MI必须引入虚基类，并修改构造函数初始化列表的规则。另外，如果在编写这些类时没有考虑到MI，则还可能需要重新编写它们。</p>
<p>如果基类是虚基类，派生类将包含基类的一个子对象；如果基类不是虚基类，派生类将包含多个子对象。当虚 基类和非虚基类混合时，情况将如何呢？如：假设类B被用作类C和D的虚基类，同时被用作类X和Y的非虚基类，而类M是从C、D、X和Y派生而来的。在这种情况下，类M从虚拟派生祖先（即类C和D）那里共继承了一个B类子对象，并从每一个非虚拟派生祖先（即类X和类Y）分别继承了一个B类子对象。因此，它包含三个B类子对象。当类通过多条虚拟途径和非虚拟途径继承某个特定的基类时，该类将包含一个表示所有的虚拟途径的基类子对象和分别表示各条非虚拟途径的多个基类子对象。</p>
<p>使用虚基类将改变C++解析二义性的方式。使用非虚基类时，规则很简单。如果类从不同的类那里继承了两个或更多的同名成员，则使用该成员名时，如果没有用类名进行限定，将导致二义性。但如果使用的是虚基类，则这样做不一定会导致二义性。在这种情况下，如果某个名称优先于其它所有名称，则使用它时，即便不使用限定符也不会导致二义性。</p>
<p>从虚基类的一个或多个实例派生而来的类将只继承了一个基类对象。</p>
<ul>
<li>有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数，这对于间接非虚基类来说是非法的。</li>
<li>能过优先规则解决名称二义性。（派生类中的名称优先于直接或间接祖先类中的相同名称）</li>
</ul>
<h3 id="14-4-1-定义类模板"><a href="#14-4-1-定义类模板" class="headerlink" title="14.4.1 定义类模板"></a>14.4.1 定义类模板</h3><p>模板提供参数化类型，即能够将类型名作为参数传递给接收方来建立类或函数。使用模板成员函数替换原有类的类方法，每个函数头都将以相同的模板声明打头。</p>
<p>和模板函数一样，模板类以下面这样的代码开：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class</span> Stack</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Stack&lt;Type&gt;作限定符</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">void</span> Stack&lt;Type&gt;::count()&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>其中，Stack<classname>作为类型，如果在类声明中定义了方法（内联定义），则可以活力模板前缀和类限定符(Stack<type>)。</type></classname></p>
<p>模板的具体实现—例如用来处理string对象的堆栈类—被称为实例化或具体化。除非编译器实现了新的export关键字，否则将模板成员函数旋转在一个独立的实现文件中将无法运行。因为模板不是函数，它们不能编译。模板必须与特定的模板实例化请求一起使用。为此，最简单的方法是将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件。</p>
<p>注意，必须显式地提供所需的类型，这与常规的函数模板是不同的，因为编译器可以根据函数的参数类型来确定要生成哪种函数。</p>
<p>任县指针堆栈的方法之一是，让调用程序提供一个指针数组，基中每个指针都指向不同的字符串，反这些指针放在堆栈中是有意义的，因为每个指针都将指向不同的字符串。</p>
<p>模板常被用作窗口类，这是因为类型参数的概念非常适合于将相同的存储方案用于不同类型。</p>
<p><strong>表达式参数</strong>：指定特殊的类型而不是用作通用类型名，称为非类型或表达式参数。在实例化模板时，用作表达式的参数的值必须是常量表达式，因为在编译期，要对特定类型进行模板实例化，生成特定类型的类代码。</p>
<p><strong>模板类可用作基类，也可用作组件类，还可用作基他模板的类型参数，递归使用模板，使用多个类型参数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> Array</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T entry;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用于基类</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class</span> GrowArray: <span class="keyword">public</span>&lt;Tyep&gt; &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//用作组件类</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Tp&gt;</div><div class="line"><span class="keyword">class</span> Stack</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Array&lt;Tp&gt; ar;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用作基他模板的类开参数</span></div><div class="line">Array &lt;Stack&lt;<span class="keyword">int</span>&gt; &gt; asi;    <span class="comment">//必须使用至少一个空白字符将两个&gt;符号分开，以避免与&gt;&gt;操作符混淆。</span></div><div class="line"></div><div class="line"><span class="comment">//递归使用模板</span></div><div class="line">ArrayTP&lt; ArrayTP&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt;， <span class="number">10</span>&gt; twodee;</div><div class="line"></div><div class="line"><span class="comment">//使用多个类型参数</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</div><div class="line"><span class="keyword">class</span> Pair</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T1 a;</div><div class="line">    T2 b;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">T1 &amp;<span class="title">first</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">T2 &amp;<span class="title">second</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">T1 <span class="title">first</span><span class="params">()</span><span class="keyword">const</span></span>&#123;&#125;;</div><div class="line">    <span class="function">T2 <span class="title">second</span><span class="params">()</span><span class="keyword">const</span></span>&#123;&#125;;</div><div class="line">    Pair()&#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</div><div class="line">T1 &amp; Pair&lt;T1, T2&gt;::first()</div><div class="line">&#123;&#125;</div><div class="line"><span class="comment">//todo</span></div></pre></td></tr></table></figure>
<p><strong>默认类型模板参数</strong></p>
<p>类模板的另一项新特性是，可以为类型参数提供默认值，在以下代码中，如果省略T2的值，编译器将使用int。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2 = <span class="keyword">int</span>&gt; </div><div class="line"><span class="keyword">class</span> Topo&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>虽然可以为类模板类型参数提供默认值，但不能为函数模板参数提供默认值。不过可以为非类型参数提供默认值，这对于类模板和函数都是适用的。</p>
<h3 id="14-4-6-模板的具体化"><a href="#14-4-6-模板的具体化" class="headerlink" title="14.4.6 模板的具体化"></a>14.4.6 模板的具体化</h3><p>类模板与函数模板很相似，因为可以有隐式实例化、显式实例化和显式具体化，它们统称为具体化。模板以通用类型的方式描述类，而具体化是使用具体的类型生成类声明。</p>
<p><strong>隐式实例化</strong>：它们声明一个或多个对象，所需的类型，而编译器使用通用模板提供的处方生成具体的类定义。编译器在需要对象前，不会生成类的隐式实例化，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArrayTP&lt;<span class="keyword">double</span>, <span class="number">30</span>&gt; *pt;   		<span class="comment">//没有生成对象，则不会隐式实例化。</span></div><div class="line">pt = <span class="keyword">new</span> ArrayTP&lt;<span class="keyword">double</span>, <span class="number">30</span>&gt;;   <span class="comment">//隐式实例化。</span></div></pre></td></tr></table></figure>
<p><strong>显式实例化</strong>：当使用关键字template并指出所需类型来声明类时，编译器将生成类声明的显式实例化。声明必须位于模板定义所在的名称空间中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在这种情况下，虽然没有创建或提及类对象，编译器也将通过通过模板生成类声明和定义。</span></div><div class="line"><span class="keyword">template</span> <span class="keyword">class</span> ArrayTP&lt;<span class="built_in">string</span>, <span class="number">100</span>&gt;;</div></pre></td></tr></table></figure>
<p><strong>显式具体化</strong>：是特定类型(用于替换模板中的通用类型)的定义，有时候可能需要在为特殊类型实例化时，对模板进行修改，使基行为不同。在这种情况下，可以创建显式具体化。当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化版本。具体化类模板定义的格式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> ClassName&lt;specialized-type-name&gt;&#123;...&#125;;</div><div class="line"><span class="comment">//使用新表示法提供一个专供char*类型使用的SortedArray模板，可以使用与下面类似的代码</span></div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> SortedArray&lt;<span class="keyword">char</span>*&gt;&#123;...&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>部分具体化</strong>：C++还允许部分具体化，即部分限制模板的通用。如：部分具体化可以给类型参数之一指定具体的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通用模板</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt; <span class="keyword">class</span> Pair&#123;&#125;;</div><div class="line"><span class="comment">//部分具体化模板</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1&gt; <span class="keyword">class</span> Pair&lt;T1, <span class="keyword">int</span>&gt;&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>关键字template后面的&lt;&gt;声明的是没有被具体化的类型参数。 因此，上述第二个声明将T2具体化为int，但T1保持不变。注意，如果指定所有的类型，则&lt;&gt;内将为空，这将导致显式具体化。</p>
<p>如果有多个模板可供选择，则编译器将使用具体化程度最高的模板。</p>
<h3 id="14-4-7-成员模板"><a href="#14-4-7-成员模板" class="headerlink" title="14.4.7 成员模板"></a>14.4.7 成员模板</h3><p>C++模板支持的另一个新特性是：模板可用作结构、 类或模板类的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Beta</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt; </div><div class="line">    <span class="keyword">class</span> Hold</div><div class="line">	&#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		V val;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Hold(V v = <span class="number">0</span>):V(v)&#123;&#125;;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Beta(T t,<span class="keyword">int</span> i):q(t), n(i)&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Hold模板类是在私有部分声明的，因此只能在Beta类中访问它。</p>
<h3 id="14-4-8-将模板用作参数"><a href="#14-4-8-将模板用作参数" class="headerlink" title="14.4.8 将模板用作参数"></a>14.4.8 将模板用作参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>　<span class="meta-string">"stacktp.h"</span></span></div><div class="line"><span class="comment">//模板参数</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Thing&gt;</div><div class="line"><span class="keyword">class</span> Crab</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Thing&lt;<span class="keyword">int</span>&gt; s1;</div><div class="line">    Thing&lt;<span class="keyword">double</span>&gt; s2;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Crab();</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> x)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  Crab&lt;Stack&gt; nebula;</div><div class="line">  <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Crab模板的成员s1、s2，使用模板参数声明的Thing模板去实例化成员，当使用时模板参数为Stack，则使用Stack去实例化s1、s2。</p>
<h3 id="14-4-9-模板类和友元"><a href="#14-4-9-模板类和友元" class="headerlink" title="14.4.9 模板类和友元"></a>14.4.9 模板类和友元</h3><p>模板类声明也可以有码元，模板的友元分3类：</p>
<ul>
<li>非模板友元</li>
<li>约束模板友元，即友元的类型取决于类被实例化时的类型。</li>
<li>非约束模板码元，即友元的所有具体化都是类的每一个具体化的友元。</li>
</ul>
<p><strong>非模板友元</strong>：为具体模板实例化编写不同的友元。如果友元不带模板类型参数，则所有模板实例化共用一个友元函数，如果友元带模板类型参数，则为不同类型的模板实例化编写相应的友元。</p>
<p><strong>模板类的约束模板友元函数</strong>：约束模板友元函数是在类外面声明的模板的具体化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;</div><div class="line">CLASS HasFriendT</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>: </div><div class="line">    TT item;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ct;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    HasFriendT(<span class="keyword">const</span> TT &amp;i):item(i)&#123;ct++;&#125;</div><div class="line">    ~HasFriendT()&#123;ct--;&#125;</div><div class="line"></div><div class="line">    <span class="comment">//声明中的&lt;&gt;指出这是模板具体化。</span></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> counts&lt;TT&gt;();</div><div class="line">    <span class="comment">//对于report，&lt;&gt;可以为空，这是因为可以从函数参数推断出模板类型参数。</span></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> report&lt;&gt; (HasFriendT&lt;TT&gt; &amp;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//模板类外声明的模板函数友元</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">int</span> HasFriendT&lt;T&gt;::ct = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; hf.item &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//声明中的&lt;&gt;指出这是模板具体化。</span></div><div class="line">    counts&lt;<span class="keyword">int</span>&gt;();</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>模板类的非约束模板友元函数</strong>：通过在类内部声明模板，可以创建非约束码元函数，即每个函数具体化都是每个类具体化的码元。对于非约束友元，友元模板类型参数与模板类型参数是不同的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> ManyFriend</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T item;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ManyFriend (<span class="keyword">const</span> T &amp;i):item(i) &#123;&#125;</div><div class="line">     </div><div class="line">    <span class="comment">//模板类内声明的模板函数友元，定义与类成员模板函数一起定义</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt; </div><div class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">(C &amp; c, D &amp; d)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">(C &amp; c, D &amp; d)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; c.item &lt;&lt; <span class="string">","</span> &lt;&lt; d.item &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//todo</span></div><div class="line">    show2(hfdb, hfi2);</div><div class="line">    <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="14-5-总结"><a href="#14-5-总结" class="headerlink" title="14.5 总结"></a>14.5 总结</h3><p>使用私有继承时，基类的公有成员和保护成员将成为派生类的私有成员；使用保护继承时，基类的公有成员和保护成员将成为派生类的保护成员。无论使用哪种继承，基类的公有接口都将成为派生类的内部接口。这有时候被称为继承实现，但不继承接口，因为派生类对象不能显式地使用基类的接口。因此，不能将派生对象看作是一种基类的对象。由于这个原因，在不进行显式类型转换的情况下，基类指针或引用将不能指向派生类对象。</p>
<p>还可以通过开发包含对象成员的类来重用类代码。这种方法被称为包含、 层次化或组合，它建立的也是has-a关系。与私有继承和保护继承相比，包含更容易实现和使用，所以通常优先采用这种方式。不过，私有继承和保护继承与包含有一些不同的功能。例如，继承允许派生类访问基类的保护成员；还允许派生类重新定义从基类那里继承的虚函数。因为包含不是继承，所以通过包含来重用类代码时， 不能使用这些功能。 另一方面，如果需要使用某个类的几个对象，则用包含更适合。</p>
<p>可以提供显式具体化—覆盖模板定义的具体类声明。方法是以template&lt;&gt;打头，然后是模板类名称，再加上尖括号（其中包含要具体化的类型）。</p>
]]></content>
    
    <summary type="html">
    
      个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="C++" scheme="http://LySnake.github.io/tags/c/"/>
    
      <category term="C++ Primer Plus" scheme="http://LySnake.github.io/tags/c-primer-plus/"/>
    
      <category term="cocos2d-x" scheme="http://LySnake.github.io/tags/cocos2d-x/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus学习笔记(3)</title>
    <link href="http://LySnake.github.io/archives/technology/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3).html"/>
    <id>http://LySnake.github.io/archives/technology/C++ Primer Plus学习笔记(3).html</id>
    <published>2017-06-11T09:15:03.000Z</published>
    <updated>2017-06-13T15:21:14.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="13-类继承"><a href="#13-类继承" class="headerlink" title="13. 类继承"></a>13. 类继承</h2><h3 id="13-1派生一个类"><a href="#13-1派生一个类" class="headerlink" title="13.1派生一个类"></a>13.1派生一个类</h3><p>从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。</p>
<ul>
<li>派生类对象存储了基类的数据成员（派生类继承了基类的实现）。</li>
<li>派生类对象可以使用基类的方法（派生类继承了基类的接口）。</li>
<li>派生类需要自己的构造函数，构造函数必须给新成员和继承的成员提供数据。</li>
<li>派生类可以根据需要添加额外的数据成员和成员函数。</li>
</ul>
<h3 id="13-1-2-构造函数：访问权限的考虑"><a href="#13-1-2-构造函数：访问权限的考虑" class="headerlink" title="13.1.2 构造函数：访问权限的考虑"></a>13.1.2 构造函数：访问权限的考虑</h3><p>派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。例如，派生类的构造函数不能直接设置继承的成员数据，而必须使用基类的公有方法或保护方法来访问私有的基类成员。具体地说，派生类构造函数必须使用基类的构造函数。</p>
<p>创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员初始化列表句法来完成这种工作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassName::ClassName(<span class="keyword">int</span> a, <span class="keyword">int</span> b):BaseClass(a, b)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中BaseClass是成员初始化列表。它是可执行的代码，它调用BaseClass构造函数。</p>
<p>基类必须首先被创建，如果不调用基类构造函数，程序将使用默认的基类构造函数，除非要使用默认构造函数，否则应显式调用正确的基类构造函数。</p>
<p>有关派生类构造函数的要点：</p>
<ul>
<li>基类对象首先被创建。</li>
<li>派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数。</li>
<li>派生类构造函数应初始化派生类新增的数据成员。释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。（TIP:创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。基类构造函数负责初始化继承数据成员派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表句法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。）</li>
</ul>
<h3 id="13-2-派生类和基类之间的特殊关系"><a href="#13-2-派生类和基类之间的特殊关系" class="headerlink" title="13.2 派生类和基类之间的特殊关系"></a>13.2 派生类和基类之间的特殊关系</h3><p>基类指针和引用可以在不进行显式类型转换的情况下指向或引用派生类对象.</p>
<p>C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是例外。不过这种例外是只单向的，不可以将基类对象和地址赋给派生类引用和指针。如果允许基类引用隐式地引用派生类对象，则可以使用基类引用为派生类对象调用基类的方法。因为派生类继承了基类的方法，所以这样做不会出现问题。如果可以将基类对象赋给派生类对象，派生类引用能够为基对象调用派生类方法，这样做将出现问题。</p>
<h3 id="13-3-继承–is-a关系"><a href="#13-3-继承–is-a关系" class="headerlink" title="13.3 继承–is-a关系"></a>13.3 继承–is-a关系</h3><p>C++有3种继承方式：公有继承、保护继承和私有继承。公有继承是最常用的方式，它建立一种is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。</p>
<ul>
<li>公有继承不建立has-a关系。has-a关系最容易的建模方式是，将一个对象作为另一个类的数据成员。</li>
<li>公有继承不建立is-like-a关系，也就是说，它不采用明喻。继承可以在基类的基础上添加属性，但不能删除基类的属性。</li>
<li>公有继承不建立is-implemented-as-a关系。</li>
<li>公有继承不建立uses-a关系。如PC对象派生出Printer对象是没有意义的，不过可以使用友元函数或友元类处理Printer与PC类之间的关系。</li>
</ul>
<h3 id="13-4-多态公有继承"><a href="#13-4-多态公有继承" class="headerlink" title="13.4 多态公有继承"></a>13.4 多态公有继承</h3><p>同一个方法在派生类和基类中的行为是不同的，换句话说，方法的行为应取决于调用该方法的对象，这种较复杂的行为称为多态–具有多种形态，就是指同一个方法的行为将随上下文而异。有二种重要的机制可用于实现多态公有继承：</p>
<ul>
<li>在派生类中重新定义基类的方法。</li>
<li>使用虚方法(推荐作法)。</li>
</ul>
<p>如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针指向的对象类型来选择方法。</p>
<p>经常在基类中将派生类会重新定义的方法声明为虚方法。方法在基类中被声明为虚拟的后，它在派生类中将自动成为虚方法。不过，在派生类声明中使用关键字virtual来指出哪些函数是虚函数也不失为一个好办法。（如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚拟的。这样，程序将根据对象类型而不是引用或指针类型来选择方法版本。关键字virtual只用于类声明的方法原型中，而没有用于实现中。）</p>
<p>派生类并不能直接访问基类的私有数据，而必须使用基类的公有方法才能访问这些数据。</p>
<p>非构造函数不能使用成员初始化列表句法，但派生类方法可以调用公有的基类方法。在派生类方法中，标准的技术是使用作用域解析操作符来调用基类方法，如BaseClass::func()。(同样包含隐式参数this)</p>
<p>使用delete释放由new分配的对象说明了为何基类应包含一个虚拟析构函数，虽然有时好像并不需要析构函数。如果析构函数不是虚拟的，则将只调用对应于指针类型的析构函数。如果析构函数是虚拟的，将调用相应的对象类型的析构函数。因此，如果指针指向的是派生类对象，将调用派生类的析构函数，然后自动调用基类的析构函数。因此，使用虚拟析构函数可以确保正确的析构函数序列被调用。</p>
<h3 id="13-4-2-静态联编和动态联编"><a href="#13-4-2-静态联编和动态联编" class="headerlink" title="13.4.2 静态联编和动态联编"></a>13.4.2 静态联编和动态联编</h3><p>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编。在C语言中，这非常简单，因为每一个函数名都对应一个不同的函数。在C++中，由于函数重载的缘故，这项任务更复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。然而，C/C++编译器可以在编译过程完成这种联编。在编译过程中进行联编被称为静态联编，又称为早期联编。不过，虚函数使这项工作变得更困难，使用哪一个函数是不能在编译时确定的，因为编译器不知道用户将选择哪种类型的对象。所以编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编，又称为晚期联编，编译器对非虚方法使用静态联编，对虚方法使用动态联编。</p>
<h3 id="13-4-3指针和引用类型兼容性"><a href="#13-4-3指针和引用类型兼容性" class="headerlink" title="13.4.3指针和引用类型兼容性"></a>13.4.3指针和引用类型兼容性</h3><p>在C++中，动态联编与指针和引用调用的方法相关，从某种程度上说，这是由继承控制的，公有继承建立is-a关系的一种方法是如何处理指向对象的指针和引用。通常，C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型，不过指向基类的引用或指针可以引用派生类对象，而不必进行显式类型转换。将派生类引用或指针转换为基类引用或指针被称为向上强制转换，这使公有继承不需要进行显式类型转换。该规则是is-a关系的一部分。将基类指针或引用转换为派生类指针或引用–称为向下强制转换。如果不使用显式类型转换，则向下强制转换是不允许的。原因是is-a关系通常是不可逆的。派生类可以新增数据成员，因此使用这些数据成员的类函数不能应用于基类。</p>
<h4 id="动态联编和静态联编对比"><a href="#动态联编和静态联编对比" class="headerlink" title="动态联编和静态联编对比"></a>动态联编和静态联编对比</h4><p><strong>效率</strong>：为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销。</p>
<p><strong>概念模型</strong>：在设计类时，可能包含一些不在派生类重新定义的成员函数。对于这些函数不设置为虚函数有二方面的好处：首先效率更高，基次指出不要重新定义该函数。这表明，仅将那些预期将被重新定义的方法声明为虚拟的。</p>
<p><strong>虚函数的工作原理</strong>：C++规定了虚函数的行为，但将实现方法留给了编译器作者。通常，编译器处理虚函数的方法是，给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table,vtbl)。虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含了一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中，注意，无论类中包含的虚函数是1个还是10个，都只需要在对象中添加1个地址成员，只是表的大小不同而已。（虚函数表记录的函数并不记录参数特征标（非重载而是重写））</p>
<p>使用虚函数时，在内存和执行速度方面有一定的成本，包括：</p>
<ul>
<li>每个对象都将增大，增大量为存储地址的空间。</li>
<li>每个类，编译器都创建一个虚函数地址表。</li>
<li>每个函数调用都需要执行一步额外的操作，即到表中查找地址。</li>
</ul>
<h3 id="13-4-5-有关虚函数注意事项"><a href="#13-4-5-有关虚函数注意事项" class="headerlink" title="13.4.5 有关虚函数注意事项"></a>13.4.5 有关虚函数注意事项</h3><p>虚函数要点：</p>
<ul>
<li>在基类的声明中使用关键字virtual可使该方法在基类以及所有的派生类中是虚拟的。</li>
<li>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样的基类指针或引用可以指向派生类</li>
<li>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚拟的。</li>
</ul>
<p>对于虚方法，还需要了解其它的一些知识：</p>
<ul>
<li>构造函数<blockquote>
<p>构造函数不能是虚函数，派生类不继承基类的构造函数，所以将类构造函数声明为虚拟的没有什么意义。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>析构函数</p>
<blockquote>
<p>析构函数应当是虚函数，除非类不用做基类。如果析构函数是虚拟的，则当基类指针或引用使用的派生类被析构时，将先调用派生类构造函数，再自动调用基类的析构函数，如果不是虚拟的，将是直接调用基类的析构函数。顺便说一句，给类定义一个虚拟析构函数并非错误，即使这个类不用做基类；这只是一个效率方面的问题。通常应给基类一个虚拟析构函数，即使它并不需要析构函数。</p>
</blockquote>
</li>
<li><p>友元</p>
<blockquote>
<p>友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。如果由于这个原因引起了设计问题，可以通过让友元函数使用虚拟成员函数来解决。</p>
</blockquote>
</li>
<li><p>没有重新定义</p>
<blockquote>
<p>如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>虚拟函数重新定义不会生成函数的二个重载版本，而是隐藏了基类的所有同名虚函数版本。简而言之，重新定义继承的方法并不是重载。如果在派生类中重新定义函数，将不是使用相同的函数特征标基类声明，而隐藏同名的基类方法，不管参数特征标如何。因此引出了二条经验规则：</p>
<ol>
<li>如果重新定义继承的虚方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。</li>
</ol>
<p>2.如果基类声明被重载了，则应在派生类中重新定义所有基类版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BaseClass</div><div class="line">&#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">     <span class="comment">//三个被重载的虚函数声明</span></div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span>)</span></span>;</div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span>)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> ClassName:<span class="keyword">public</span> BaseClass</div><div class="line">&#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="comment">//三个基类同名的虚函数都要重新定义，避免覆盖基类其它同名的虚函数 </span></div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span>)</span></span>;</div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span>)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<h3 id="13-5-访问控制：protected"><a href="#13-5-访问控制：protected" class="headerlink" title="13.5 访问控制：protected"></a>13.5 访问控制：protected</h3><p>关键字protected与private相似，在类外只能用公有类成员函数来访问protected部分中的类成员。private和protected之间的区别只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。而对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。（最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据）</p>
<p><strong>单设计模式</strong>：希望有且只有一个类的实例返回给调用程序时，就可以使用单设计模式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> TheOnlyInstance</div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">static</span> TheOnlyInstance *<span class="title">GetTheOnlyInstance</span><span class="params">()</span></span>;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        <span class="comment">//无公有构造函数，可以防止实例被创建。只能通过公有静态方法来访问。</span></div><div class="line">        TheOnlyInstance()&#123;&#125;;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">//other data</span></div><div class="line">&#125;</div><div class="line">TheOnlyInstance &amp;TheOnlyInstance::GetTheOnlyInstance()</div><div class="line">&#123;</div><div class="line">    <span class="comment">//静态局部变量只在第一次执行时初始化，生命期为整个函数，作用域为定义到该函数结尾</span></div><div class="line">    <span class="keyword">static</span> TheOnlyInstance objTheOnlyInstance;</div><div class="line">    <span class="keyword">return</span> objTheOnlyInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="13-6-抽象基类"><a href="#13-6-抽象基类" class="headerlink" title="13.6 抽象基类　"></a>13.6 抽象基类　</h3><p>C++通过使用纯虚函数提供未实现的函数。纯虚函数声明的结尾处为=0。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BaseClass</div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">double</span> x,y;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">virtual</span> ~BaseClass();</div><div class="line">        <span class="comment">//纯虚函数</span></div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span><span class="params">()</span><span class="keyword">const</span></span>=<span class="number">0</span>;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当类声明中包含纯虚函数时，则不能创建该类的对象。这里的理念是，包含纯虚函数的类只能作基类。要成为真正的抽象基类(abstract base class,ABC),必须至少包含一个纯虚函数。原型中的=0使虚函数成为纯虚函数。总之，在原型中使用=0指出类是一个抽象基类，在类中可以不定义该函数。ABC描述的是至少使用一个纯虚函数的接口，从ABC派生出的类将根据派生类的具体特征，使用常规虚函数来实现这种接口。</p>
<p>设计ABC之前，首先应开发一个模型–指出编程问题所需的类以及它们之间相互关系。一种学院派思想认为，如果要设计类继承层次，则只能将那些不会被用作基类的类设计为具体的类。</p>
<p><strong>ABC要求具体派生类覆盖其纯虚函数–迫使派生类遵循ABC所设置的接口规则。这种模型在基于组件的编程模式中很常见，在这种情况下，使用ABC使组件设计人员能够制定“接口约定”，这样确保了从ABC派生的所有组件都至少支持ABC指定的功能。</strong></p>
<h3 id="13-7-继承和动态内存分配"><a href="#13-7-继承和动态内存分配" class="headerlink" title="13.7 继承和动态内存分配"></a>13.7 继承和动态内存分配</h3><p>当声明中的构造函数使用new操作符时，需要使用特殊方法：析构函数、复制构造函数和重载赋值操作符。</p>
<p>当派生类构造函数不使用new操作符或静态成员变量时：</p>
<ul>
<li>如果没有定义析构函数，编译器将定义一个不执行任何操作的默认构造函数。实际上，派生类的默认构造函数总是要进行一些操作：执行自身的代码后调用基类析构函数。</li>
<li>成员复制将根据数据类型采用相应的复制方式，但复制类成员或继承的类组件时，则是使用该类的复制构造函数完成的。所以派生类的默认复制构造函数使用显示的基类复制构造函数来复制派生类对象的基类数据部分。</li>
<li>类的默认赋值操作符将自动使用基类的赋值操作符来对基类组件进行赋值。</li>
</ul>
<p>当派生类构造函数使用new操作符或静态成员变量时，必须为派生类定义显式析构函数、复制构造函数和赋值操作符：</p>
<ul>
<li>派生类析构函数自动调用基类的析构函数，因此其自身的职责是对派生类构造函数执行工作的进行清理。</li>
<li>派生类的复制构造函数只能访问派生类新增的成员，因此它必须调用基类的复制构造函数来处理共享的基类数据部分。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassName::ClassName(<span class="keyword">const</span> ClassName &amp;rs):BaseClass(rs)</div><div class="line">&#123;</div><div class="line">     <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>成员初始化列表将一个派生类引用传递给基类构造函数。没有参数类型为派生类的引用的基类构造函数，也不需要这样的构造函数。因为复制构造函数派生类有一个以派生类为引用的参数，而基类引用可以指向派生类型。因此基类复制构造函数将使用参数为派生类的基类数据部分来构造新对象的基类部分。</p>
</blockquote>
<ul>
<li>由于派生类使用了动态内存分配，所以它也需要一个显式赋值操作符。作为派生类的方法，它只能直接访问派生类的数据。然而派生类的显式赋值操作符必须负责所有继承的派生类对象的赋值，可以通过显式调用基类赋值操作符来完成。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ClassName&amp; ClassName::<span class="keyword">operator</span>=(<span class="keyword">const</span> ClassName &amp;rs):BaseClass(rs)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span>(<span class="keyword">this</span> == rs)</div><div class="line">         <span class="keyword">return</span> rs;</div><div class="line">     <span class="comment">//显式调用基类的赋值操作符 </span></div><div class="line">     BaseClass::<span class="keyword">operator</span>=(rs);</div><div class="line">     <span class="comment">//todo</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>总之，当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数以及赋值操作符都必须使用相应的基类方法来处理基类的元素。这种要求是通过三种不同的方式来满足的。对于析构函数，这是自动完成的；对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做将自动调用基类的默认构造函数。对于赋值操作符，这是通过使用作用域解析操作符显式地调用基类的赋值操作符来完成。</p>
<p>因为友元不是成员函数，所以不能使用作用域解析操作符来指出要使用哪个函数。这个问题解决方法是使用强制类型转换，以便匹配原型时能够选择正确的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> ClassName &amp; hs)</div><div class="line">&#123;</div><div class="line">    os&lt;&lt;(<span class="keyword">const</span> ClassName &amp;)hs;</div><div class="line">    <span class="comment">//todo;</span></div><div class="line">    <span class="keyword">return</span> hs;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="13-8-类设计回顾"><a href="#13-8-类设计回顾" class="headerlink" title="13.8 类设计回顾"></a>13.8 类设计回顾</h3><ul>
<li>默认构造函数 </li>
</ul>
<p>默认构造函数要么没有参数，要么所有参数都有默认值，如果没有定义任何构造函数，编译器将定义默认构造函数，让您能够创建对象。自动生成的默认构造函数的另一个功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数。另外，如果派生类构造函数的成员初始化列表中没有显式地调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。如果定义了某种构造函数，编译器将不会定义默认构造函数。在这种情况下，如果需要默认构造函数，则必须自己提供。提供构造函数的动机之一是确保对象总能被正确地初始化。另外，如果类包含指针成员，则必须初始化这些成员。因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值。</p>
<ul>
<li>复制构造函数</li>
</ul>
<p>复制构造函数接受其所属类的对象作为参数。在以下情况，将使用复制构造函数：</p>
<ol>
<li>将新的对象初始化为一个同类对象。</li>
<li>按值将对象传递给函数。</li>
<li>函数按值返回对象。</li>
<li>编译器生成临时对象。  //obj1 = obj2 + obj3 + obj4; </li>
</ol>
<p>如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。也就是说，新对象的 每个成员都被初始化为原始对象相应的成员的值。</p>
<p>在某些情况下，成员初始化是不合适的。如：使用new初始化的成员指针通常要求执行深复制，或者类可能包含需要修改的静态变量。</p>
<ul>
<li>赋值操作符</li>
</ul>
<p>默认的赋值操作符用于处理同类对象之间的赋值。不要将赋值与初始化混淆了。如果语句创建新的对象，则使用复制构造函数；如果语句修改已有对象的值，则是赋值。编译器不会生成将一种赋值给另一种类型的赋值操作符。如果希望能够将一种对象赋值给另一个对象，则方法之一是显式定义相应的赋值操作符。</p>
<ul>
<li>构造函数</li>
</ul>
<p>构造函数不同于其他类方法，因为它创建新的对象，而其它类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。继承意味着派生类对象可以使用基类的方法，然而，构造函数在完成其工作之前，对象并不存在。</p>
<ul>
<li>析构函数 </li>
</ul>
<p>一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。</p>
<ul>
<li>隐式转换和转换</li>
</ul>
<p><strong>隐式转换</strong>：使用一个参数就可以调用的构造函数定义从参数类型到类类型的转换。带一个参数的构造函数原型中使用explicit将禁止进行隐式转换，但仍允许显式转换。</p>
<p><strong>转换</strong>：转换函数可以是没有参数的类成员，也可以是返回类型被声明为目标类型的为成员函数。即使没有声明返回类型，函数也应返回所需的转换值。</p>
<ul>
<li>按值传递对象与传递引用</li>
</ul>
<p>按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数。按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。</p>
<ul>
<li>返回对象和返回引用</li>
</ul>
<p>应返回引用而不是返回对象的原因在于，返回对象涉及到生成返回对象的临时拷贝，这是调用函数的程序可以使用的拷贝。因此返回对象的时间成本包括调用复制构造函数来生成拷贝所需的时间和调用析构函数删除拷贝所需的时间。返回引用可节省时间和内存。直接返回对象与按值传递对象相似：它们都生成临时拷贝。同样，返回引用与按引用传递对象相似：调用和被调用的函数对同一个对象进行操作。</p>
<ul>
<li>使用const </li>
</ul>
<p>可用const来确保方法不修改参数（修饰参数），确保方法不修改调用它的对象（修饰方法代码块）。确保引用或指针返回的值不能用于修改对象的数据，使之成为左值。</p>
<p>如果函数将参数声明为指向const的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改。</p>
<h4 id="13-8-3-公有继承的考虑因素"><a href="#13-8-3-公有继承的考虑因素" class="headerlink" title="13.8.3 公有继承的考虑因素"></a>13.8.3 公有继承的考虑因素</h4><p><strong>is-a关系</strong>：在某些情况下，最好的方法可能是创建包含纯虚函数的抽象数据类，并从它派生出其它类。</p>
<p><strong>为什么不能被继承</strong>：构造函数是不能被继承的，也就是说，创建派生类对象时，必须调用派生类的构造函数。不过，派生类构造函数通常使用成员初始化列表句法来调用基类构造函数，以创建派生对象的基类部分。如果派生类构造函数没有使用成员初始化列表句法显式调用基类构造函数，将使用基类的默认构造函数。在继承链中，每个类都要可以使用初始化列表将信息传递回相近的基类。析构函数也是不能继承的。不过，在释放对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数。如果基类有默认析构函数，编译器将为派生类生成默认析构函数。通常，对于基类，其析构函数应设置为虚拟的。</p>
<p><strong>赋值操作符</strong>：派生类继承的方法的特征标与基类完全相同，但赋值操作符的特征标随类而异，这是因为它包含一个类型为其所属类的的参数。如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值操作符。这个操作符的默认或隐式版本将采用成员赋值，即将原对象的相应成员赋给目标对象的每个成员。不过，如果对象属于基类，编译器将使用基类同仁操作符来处理派生对象中基类部分的同仁。如果显式地为基类提供赋值操作符，将使用该操作符。与此相似，如果成员是另一个类的对象，则对于该成员，将使用基所属类的赋值操作符。如果类构造函数使用new来初始化指针，则需要提供一个显式赋值操作符。如果派生类使用了new，则必须提供显式赋值操作符。</p>
<p>如果派生类包含了这样的构造函数，即对将基类对象转换为派生类对象进行了定义，则可以将基类对象赋给派生对象。如果派生类定义了用于将基类对象赋给派生对象的同仁操作符，则也可以这样做。如果上述二个条件都不满足，则不能这样做，除非使用显式强制类型转换。</p>
<p><strong>私有成员与保护成员</strong>：对派生类而言，保护成员类似于公有成员；但对于外部而言，保护成员与私有成员类似。派生类可以直接访问基类的保护成员，但只能通过基类的成员函数来访问私有成员。因此，将基类成员设置为私有的可以提高安全性，而将它们设置为保护成员则可简化代码的编写工作，并提高访问速度。</p>
<p><strong>虚方法</strong>：如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚拟的，这样可以启用晚期联编；如果不希望重新定义方法，则不必将其声明为虚拟的，这样虽然无法禁止他人重新定义方法，但表达了这样的意思。</p>
<p><strong>析构函数</strong>：基类的析构函数应当是虚拟的，这样，当通过指向对象的基类指针或引用来删除派生对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数， 而不仅仅是调用基类的析构函数。</p>
<p><strong>友元函数</strong>：通过强制类型转换将派生类型引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数。</p>
<p><strong>有关使用基类方法的说明</strong>：</p>
<ul>
<li>派生类元旦自使用继承而来的基类方法，如果派生类没有重新定义该方法。</li>
<li>派生类的析构函数自动调用基类的析构函数。</li>
<li>派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数。</li>
<li>派生类构造函数显式地调用成员初以化列表中指定的基类构造函数。</li>
<li>派生类方法可以使用作用域解析操作符来调用仅有的和受保护的基类方法。</li>
<li>派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。</li>
</ul>
<p><strong>new和delete是对象的静态成员函数</strong></p>
<p>派生类继承基类的数据成员和大部分方法，但不继承类开的构造函数、析构函数和同仁操作符。派生类可以直接访问基类的公有成员和保护成员，并能够通过基类的仅有方法和保护方法访问基类的私有成员。可以在派生类中新增数据成员和方法，还可以将派生类用作基类，来做进一步的开发。每个派生类都必须有自己的构造函数。程序创建派生类对象时，将首先调用基类的构造函数，然后调用派生类的构造函数；程序删除对象时，将首先调用派生类的析构函数，再调用基类的析构函数。</p>
<p>ABC：只定义接口，而不涉及实现，ABC必须至少包含一个纯虚方法，可以在声明中的分号前面加上=0来声明纯虚方法。不一定非得定义纯虚方法。对于包含纯虚成员的类，不能使用它来创建对象。纯虚方法用于定义派生类的通用接口。</p>
]]></content>
    
    <summary type="html">
    
      个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="C++" scheme="http://LySnake.github.io/tags/c/"/>
    
      <category term="C++ Primer Plus" scheme="http://LySnake.github.io/tags/c-primer-plus/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus学习笔记(2)</title>
    <link href="http://LySnake.github.io/archives/technology/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2).html"/>
    <id>http://LySnake.github.io/archives/technology/C++ Primer Plus学习笔记(2).html</id>
    <published>2017-06-04T15:16:05.036Z</published>
    <updated>2017-06-13T13:26:10.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-使用类"><a href="#11-使用类" class="headerlink" title="11.使用类"></a>11.使用类</h2><p><strong>操作符重载</strong>是一种形式的C++多态，操作符重载将重载的概念扩展到操作符上，允许赋予C++操作符多种含义。要重载操作符，需使用被称为操作符函数的特殊函数形式。操作符函数的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ClassName total, coding, fixing;</div><div class="line"><span class="comment">//可以像使用成员方法一样使用操作符重载</span></div><div class="line">total = coding.<span class="keyword">operator</span>+(fixing);</div><div class="line"><span class="comment">//以可以使用操作符表示法：</span></div><div class="line">total = coding + fixing;</div><div class="line"></div><div class="line"><span class="comment">//注意，在操作符表示法中，操作符左侧的对象（这里为coding）是调用对象，操作符右边（这里是fixing)是作为参数被传递的对象。</span></div></pre></td></tr></table></figure>
<p>其中，op是将要重载的操作符。例如，operator +()重载+操作符，operator -()重载-操作符。op必须是有效的C++操作符，不能虚构一个新的符号。</p>
<h3 id="11-2-2操作符重载的限制"><a href="#11-2-2操作符重载的限制" class="headerlink" title="11.2.2操作符重载的限制"></a>11.2.2操作符重载的限制</h3><ul>
<li>重载后的操作符必须至少有一个操作数是用户定义，这将防止用户为标准类型重载操作符。因此不能将减法操作符重载为计算两个double值的和，而不是它们的差。</li>
<li>使用操作符时不能违反操作符原来的句法规则。例如，不能将求模操作符(%)重载成使用一个操作数(%x;），同样也不能修改操作符的优先级。因此，如果将加号操作符重载成将两个类相加，则新的操作符与原来的加号具有相同的优先级。</li>
<li>不能定义新的操作符。</li>
<li>不能重载下面的操作符<blockquote>
<ul>
<li>sizeof—sizeof操作符。(sizeof操作符是编译时运算)</li>
<li>.—成员操作符。</li>
<li>.*—成员指针操作符。</li>
<li>::—作用域解析操作符。</li>
<li>?:—条件操作符。</li>
<li>typeid—一个RTTI操作符。</li>
<li>const_cast—强制类型转换操作符。</li>
<li>dynamic_cast—强制类型转换操作符。</li>
<li>reinterpret_cast—强制类型转换操作符。</li>
<li>static_cast—强制类型转换操作符。</li>
</ul>
</blockquote>
</li>
<li>大多操作符都可以通过成员或非成员函数进行重载，但下面的操作符只能通过成员函数进行重载：<blockquote>
<ul>
<li>=—赋值操作符。</li>
<li>()—函数调用操作符。</li>
<li>[]—下标操作符。</li>
<li>-&gt;—通过指针访问的类成员的操作符。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="11-3友元简介"><a href="#11-3友元简介" class="headerlink" title="11.3友元简介"></a>11.3友元简介</h3><p>友元有3钟：</p>
<ul>
<li>友元函数。</li>
<li>友元类。</li>
<li>友元成员函数。</li>
</ul>
<p>通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显示参数(非this传入)。对于非成员重载操作符函数来说，操作符表达式左边的操作数对应于操作符函数的第一个参数，操作符表达式右边的操作数对应于操作符函数的第二个参数。</p>
<p>创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">friend</span> TypeName <span class="keyword">operator</span>* (<span class="keyword">double</span> m, <span class="keyword">const</span> className &amp;T);</div></pre></td></tr></table></figure></p>
<ul>
<li>显然operator*()函数是在类声明中声明的，但它不是成员函数，因此不能使用成员操作符来调用。</li>
<li>虽然operator*()函数不是成员函数，但它与函数的访问权限相同。</li>
</ul>
<p>第二步是编写函数定义。因为它不是成员函数，所以不要使用className::限定符。加外不要在定义中使用关键字friend。简而言之，友元函数是非成员函数，其访问权限与成员函数相同。</p>
<p>ostream类对该操作符进行了重载，将其转换为一个输出工具，前面讲过，cout是一个ostream对象，它是智能的。能够识别所有的C++基本类型。这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的operator&lt;&lt;()定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过返回ostream的引用实现链式调用</span></div><div class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> className &amp;t)</div><div class="line">&#123;</div><div class="line">	os&lt;&lt; t.intValue &lt;&lt; t.floatValue &lt;&lt; t.stringValue ;</div><div class="line">	<span class="keyword">return</span> os;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非成员版本的重载操作符函数所需的形参数目与操作符使用的操作数数目相同，而成员版本所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象(this)。</p>
<h3 id="11-6类的自动转换和强制类型转换"><a href="#11-6类的自动转换和强制类型转换" class="headerlink" title="11.6类的自动转换和强制类型转换"></a>11.6类的自动转换和强制类型转换</h3><p>C++的目标之一就是把类实现为与基本类型一致，所以也存在隐式转换问题。</p>
<p>对于类ClassName，如果存在一个参数的构造函数，那么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 存在ClassName::ClassName(TypeName)构造函数</span></div><div class="line">ClassName classValue ;</div><div class="line"><span class="comment">//相当于==&gt;classValue = ClassName::ClassName(TypeNameValue);通过构造函数以参数构造了一个对象。形成隐式转换。   </span></div><div class="line">classValue = TypeNameValue;</div></pre></td></tr></table></figure>
<p>最新的C++实现新增了一个关键字(explicit)，用来关闭这种自动特性。也就是说，可以这样声明构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//告知编译器禁止使用隐式转换，但仍然允许显式转换，即显式强制类型转换</span></div><div class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ClassName</span><span class="params">(TypeName value)</span></span>;    </div><div class="line"><span class="comment">//强制类型转换      </span></div><div class="line">ClassNameValue = ClassName(TypeNameValue);</div></pre></td></tr></table></figure></p>
<p>只接受一个参数的构造函数定义了从参数到类类型的转换。如果使用关键字explicit限定了这种构造函数，则它只能用于显示转换，否则也可以用于隐式转换。</p>
<p>当没有使用explicit限定只能用于强制转换，则在以下情况发生隐式转换：</p>
<ul>
<li>将ClassName对象初始化为TypeName值时。    //ClassNameValue = ClassName(TypeNameValue);</li>
<li>将TypeName值赋给ClassName对象时。       //classValue = TypeNameValue;</li>
<li>将TypeName值传递给接受ClassName参数的函数时。   </li>
<li>返回值被声明为ClassName类型的函数试图返回一个TypeName类型值时。</li>
</ul>
<p>函数原型提供的参数匹配过程，允许使用ClassName(TypeName)构造函数来转换其他数值类型。比如TypeName是float类型，当把int类型当做实参时，int先转换为float，再转换成TypeName给形参.</p>
<h3 id="11-6-2转换函数"><a href="#11-6-2转换函数" class="headerlink" title="11.6.2转换函数"></a>11.6.2转换函数</h3><p>构造函数只用于从某种类型到类类型的转换。要进行相反的转换必须使用特殊的C++操作符—转换函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//TypeName为int、float、double等</span></div><div class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>转换函数必须是类方法。</li>
<li>转换函数不能指定返回类型，但要有返回值。(typeName已经指定类型，无需过多注明)</li>
<li>转换函数不能有参数。(类的对象即是参数对象)</li>
</ul>
<p>TypeName(这里为double）指出了要转换成的类型，因此不需要指定返回类型。转换函数是类方法意味着：它需要通过类对象来调用，从而告知函数要转换的值。因此，函数不需要参数。虽然没有返回类型，这二个函数也将返回所需的值。</p>
<p>提供执行自动、隐式转换的函数所存在的问题是：在用户希望转换时，转换函数也可能进行转换。原则来说，最好使用显示转换，而避免隐式转换。关键字explicit不能用于转换函数，但只需用一个功能相同的非转换函数替换访转换函数即可，但仅在被显式地调用时，该函数才会执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ClassName::<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">//todo</span></div><div class="line">	<span class="keyword">return</span> intValue;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//改写为</span></div><div class="line">ClassName::ClassName2int()&#123;&#125;;</div></pre></td></tr></table></figure>
<p>C++提供了下面的类型转换：</p>
<ul>
<li>只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。例如，将int值赋给ClassName对象时，接受int参数的ClassName类构造函数将自动被调用。不过，在构造函数声明中使用explicit可防止隐式转换，而只允许显式转换。</li>
<li>被称为转换函数的特殊类成员操作符函数，用于将类对象转换为其他类型。转换函数是类成员，没有返回类型、没有参数类型、名为operator typeName()，其中，typeName是对象将被转换成的类型。<strong>将类对象赋给typeName变量或将其强制转换为TypeName类型时，该转换函数将自动被调用</strong>。</li>
</ul>
<p>全局对象，因为全局对象将在程序的main()函数被调用之前创建。程序员可以创建一个类，其默认构造函数将调用所有的bootstrap函数。实现在main()函数调用之前，执行全局类对象的构造函数来初始化一些数据。</p>
<p>C++允许指定在基本类型之间进行转换的方式。首先，任何接受唯一一个参数的构造函数都可被用作转换函数，将类型与该参数相同的值转换为类。如果将类型与该参数相同的值赋给对象，则C++将自动调用该构造函数。要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换。转换函数必须是成员函数。将类对象转换为TypeName类型的转换函数的原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意，转换函数没有返回类型、没有参数(必须是成员函数，this)，但必须返回转换后的值（虽然没有声明返回类型）</span></div><div class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<h2 id="12-类和动态内存分配"><a href="#12-类和动态内存分配" class="headerlink" title="12.类和动态内存分配"></a>12.类和动态内存分配</h2><p>类中定义static成员变量，则该变量存储在全局数据区，所有类对象共有，且作用域为类作用域。不能在类的声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存，可以使用这种格式来创建对象，从而分配和初始化内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型，并使用了作用域操作符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在类声明之外使用单独的语句来进行初始化</span></div><div class="line">staitc <span class="keyword">int</span> ClassName::ClassNameValue  iValue = <span class="number">110</span>;</div></pre></td></tr></table></figure>
<p>如果使用new[]来分配内存，则应使用delete[]来释放内存。并且在类中，所有的构造函数统一使用new或new[]，析构函数中使用delete或delete[]。delete可以释放NULL地址。</p>
<p>自动存储对象被删除的顺序与创建的顺序相反。</p>
<p>当使用一个对象来初始化另一个对象时，编译器将自动生成构造函数(称为复制构造函数，因为它创建对象的一个副本)。自动生成的构造函数不知道需要更新静态变量和深copy成员变量指向new出来的空间。</p>
<h3 id="12-1-2-隐式成员函数"><a href="#12-1-2-隐式成员函数" class="headerlink" title="12.1.2 隐式成员函数"></a>12.1.2 隐式成员函数</h3><p>隐式成员函数：</p>
<ul>
<li>默认构造函数，如果没有定义构造函数。</li>
<li>复制构造函数，如果没有定义。</li>
<li>赋值操作符，如果没有定义。</li>
<li>默认析构函数，如果没有定义。</li>
<li>地址操作符，如果没有定义。</li>
</ul>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>如果没有提供任何构造函数，C++将创建默认构造函数。如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象时显式地对它进行初始化，或需要创建对象数组时，则必须显式地定义默认构造函数。</p>
<h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><p>复制构造函数用于将一个对象复制到新创建的对象中。<strong>也就是说，它用于初始化过程中，而不是常规的赋值过程，执行于构造对象时，是一个构造函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ClassName</div><div class="line">&#123;</div><div class="line">	ClassName(ClassName&amp;);   <span class="comment">//复制构造函数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>何时调用复制构造函数</strong></p>
<p>新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有的对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> StringBad</div><div class="line">&#123;</div><div class="line">    StringBad(StringBad&amp;);</div><div class="line">&#125;; </div><div class="line">StringBad motto;</div><div class="line">StringBad metoo = motto;</div><div class="line">StringBad also = StringBad(motto);</div></pre></td></tr></table></figure></p>
<p>这二种声明可能会使用复制构造函数直接创建metoo和also对象，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给metoo和also。</p>
<p>具体的说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。记住，按值传递意味着创建原始变量的一个副本。编译器生成临时对象，也将使用复制构造函数。例如，将3个Vector对象相加时，编译器可能生成临时的Vector对象来保存中间结果。何时生成临时对象随编译器而异，但无论是哪种编译器，当按值传递和返回时，都将调用复制构造函数。</p>
<p><strong>复制构造函数的功能</strong></p>
<p>默认的复制构造函数依次复制非静态成员（成员复制也称为浅复制），复制的是成员变量的值。</p>
<h4 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h4><p>C++允许类对象赋值，这是通过自动为类重载赋值操作符实现的。</p>
<p><strong>何时使用赋值操作符</strong></p>
<ul>
<li>将已有对象赋给另一个对象时，将使用重载的赋值操作符。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> StringBad</div><div class="line">&#123;</div><div class="line">	<span class="keyword">operator</span>=(<span class="keyword">const</span> StringBad&amp;);  <span class="comment">//注意自我复制带来的先delete再new的情况。</span></div><div class="line">&#125; </div><div class="line">StringBad metoo = motto;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不过，实现时也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时对象的值复制到新对象中，这就是说，初始化总是会调用复制构造函数，而使用=操作符时也有可能调用复制构造函数。</p>
<p><strong>赋值操作符的功能</strong>：与复制构造函数相似，赋值操作符的隐式实现也对成员进行依次复制，如成员本身就是类对象，则程序将使用为这个类定义的赋值操作符来复制该成员，但静态数据成员不受影响。</p>
<p><strong>重载时，C++将区分常量与非常量函数的特征标，因此可以提供另一个仅供const String对象使用的operator[] ()版本。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现对String类对象使用[]操作符取index下标的值</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)<span class="keyword">const</span>;</div></pre></td></tr></table></figure>
<h3 id="12-1-4-在构造函数中使用new时应注意的事项"><a href="#12-1-4-在构造函数中使用new时应注意的事项" class="headerlink" title="12.1.4 在构造函数中使用new时应注意的事项"></a>12.1.4 在构造函数中使用new时应注意的事项</h3><p>因为<strong>隐式成员函数</strong>的存在，使用new时应当这样做：</p>
<ul>
<li>如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete.</li>
<li>new和delete必须相互兼容。new对应于delete，new[]对应于delete[]。</li>
<li>如果有多个构造函数，则必须以相同的方式使用new，要么都带[]，要么都不带，因为只有一个析构函数，因此所有的构造函数都必须与它兼容。不过，可以在一个构造函数中使用new来初始化指针，而在另一个构造函数中将指针初始化为NULL,这是因为delete(无论是否有[])可以用于NULL。</li>
<li>应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。</li>
<li>复制构造函数应分配足够的空间来存储复制的数据，并复制数据，而不仅仅是数据的地址。另外，还应该更新所有受影响的静态类成员。</li>
<li>应当定义一个赋值操作符，通过深度复制将一个对象复制给另一个对象。</li>
</ul>
<p><strong>返回const类型，则说明返回值为右值，不可当左值</strong></p>
<p>###　布局new操作符 ###</p>
<p>布局new操作符让您能够在分配内存时指定内存位置。但在该内存上分配的对象需要显示调用析构函数进行析构。</p>
<ul>
<li>程序员必须负责管理布局new操作符从中使用的缓冲区内存单元。要使用不同的内存单元，程序员需要提供二个位于缓冲区的不同地址，并确保这二个内在单元不重叠(如果对同一个地址使用布局new，则会使后new的对象覆盖前一个对象数据)。</li>
<li><p>如果使用布局new操作符来为对象分配内存，必须确保其析构函数被调用。原因在于delete可与常规new操作符配合使用，但不能与布局new操作符配合使用。为了确保析构函数被调用，显式地为使用布局new操作符创建的对象调用析构函数。正常情况下将自动调用析构函数，这是需要显式调用析构函数的少数几种情况之一。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ClassName classNameValue;</div><div class="line"><span class="comment">//或使用指针pClassNameValue-&gt;~ClassName;进行显式调用析构函数。</span></div><div class="line">classNameValue.~ClassName();</div></pre></td></tr></table></figure>
</li>
<li><p>对于使用布局new操作符创建的对象，应以与创建顺序相反的顺序进行析构。原因在于，晚创建的对象可能依赖于早创建的对象。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Queue</div><div class="line">&#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">struct</span> Node</div><div class="line">		&#123;</div><div class="line">			<span class="comment">//tode</span></div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++新特性：在类声明中嵌套结构或类声明，通过将Node声明放在Queue类中，可以使其作用域为整个类。也就是说，Node是这样一种类型：可以使用它来声明类成员，也可以将它作为类方法中的类型名称，但只能在类中使用。如果声明在类的私有部分进行的，则只能在这个类使用被声明的类型，如果声明是在公有部分进行的，则可以从类的外部通过作用域解析操作符使用被声明的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Queue</div><div class="line">&#123;</div><div class="line">	Queue();</div><div class="line">&#125;</div><div class="line">Queue::Queue():refValue(value1),constValue(refValue)</div><div class="line">&#123;</div><div class="line">	<span class="comment">//tode</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对需要在分配内存时就要初始化的成员(const成员，引用变量成员,基类构造)，则必须使用成员初始化列表初始化。</p>
<p>从概念上说，调用构造函数时，对象将在括号中的代码执行之前被创建。因此调用Queue()构造函数将导致程序首先给成员变量分配内存。然后，程序流程进入到括号中，使用常规的赋值方式将值存储到内存中。因此，对于const成员变量和引用成员变量，必须在执行到构造函数体之前，即创建对象时进行初始化。C++提供了一种特殊的句法来完成上述工作，它叫作成员初始化列表。成员初始化列表由逗号分隔的初始化列表组成(前面带冒号)。它位于参数列表的右括号之后，函数体左括号之前。</p>
<p>初值可以是常量或构造函数的参数列表中的参数。只有构造函数可以使用这种初始化列表句法。使用成员初始化列表的效率更高。</p>
<p>数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关。</p>
<p>成员初始化列表中使用的括号方式也可以用于常规的初始化中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> games = <span class="number">163</span>;</div><div class="line"><span class="keyword">double</span> talk = <span class="number">2.7</span>;</div><div class="line"><span class="comment">//可改写为</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">games</span><span class="params">(<span class="number">163</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">talk</span><span class="params">(<span class="number">2.7</span>)</span></span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="C++" scheme="http://LySnake.github.io/tags/c/"/>
    
      <category term="C++ Primer Plus" scheme="http://LySnake.github.io/tags/c-primer-plus/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus学习笔记(1)</title>
    <link href="http://LySnake.github.io/archives/technology/C++%20Primer%20Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1).html"/>
    <id>http://LySnake.github.io/archives/technology/C++ Primer Plus学习笔记(1).html</id>
    <published>2017-05-21T10:47:33.000Z</published>
    <updated>2017-06-07T15:33:38.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0.预备知识"></a>0.预备知识</h3><p>C++是C语言的超集，这意味着任何有效的C程序都是有效的C++程序。</p>
<p>最初，Stroustrup实现C++时，使用了一个C++到C的编译器程序，而不是开发直接的C++到目标代码的编译器。前者叫做cfront（表示C前端，C fron end），它将C++源代码翻译成C源代码，然后使用一个标准C编译器对其进行编译。这种方法简化了向C的领域引入C++的过程，其它实现 也采用这种方法将C++引入到其它平台。随着C++的日渐普及，越来越多的实现转向创建C++编译器，直接将C++源代码生成目标代码。</p>
<h3 id="8-函数控幽"><a href="#8-函数控幽" class="headerlink" title="8.函数控幽"></a>8.函数控幽</h3><p><strong>名称修饰</strong>：对原始名称进行的表面看来无意义的修饰（或矫正，因人而异）将对参数数目和类型进行编码。添加的一组符号随函数特征标而异，而修饰时使用的约定随编译器而异。比如，正常的c函数声明void fn(int);在*.o文件中，链接器查看到的符号表差不多就是_fn，并没有带有参数类型标识，但C++因为有重载，重写，同一个函数名可能存在于多个类中或一个类中存在相同函数名但参数表不一样，此时目标文件*.obj中连接器查看到的符号表是带参数类型和顺序的，如_fn_i。</p>
<p>TIP：<strong>C++标准允许每个编译器设计人员以他认为合适 的方式实现名称修饰，因此由不同编译器创建的二进制模块（对名胜代码文件）很可能无法正确地链接。也就是说，这二个编译器将为同一个当函数生成不同的修饰名称。名称的不同将使链接器无法将一个编译器生的函数调用与另一个编译器生成的函数定义匹配。在链接编译模块时，请确保所有文件或库都是由同一个编译器生成的。</strong></p>
<p><strong>函数模板</strong>：是通用的函数描述，也就是说，它们使用通用类型来定义函数，其中的通用类型可用具体的类型（如int或float）替换，通过将类型作为参数传递给模板，可使编译器生成对应类型的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;   <span class="comment">//也可使用 template &lt;typename T&gt;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp;, T)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//todo.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键字template和class是必需的，除非可以使用关键字typename代替class，typename关键字使得参数T表示类型这一点更换为明显；不过，有大量的代码库是使用关键字class开发的。在这种上下文中这二个关键字是等同的。另外使用尖括号。模板并不创建任何函数，而只是告诉编译器如何定义函数。</p>
<p>并非所有的模板参数都是必须是模板参数类型。使用模板的好处是，它使生成多个函数定义更简单、更可靠。</p>
<p>如果有多个原型，则编译器在选择原型时，非模板版本将优先于显式具体化和模板版本，而具体化将优先于使用模板生成的版本。</p>
<p>在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例。</p>
<p><strong>编译器选择使用哪个函数版本</strong>：</p>
<ol>
<li>创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。</li>
<li>使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐匿转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用 可以将访参数转换为double类型，从而是与double形参匹配，而模板可以为float生成一个实例。</li>
<li>确定是否有最佳的可行函数。如果有，则使用它，否则访函数调用出错。</li>
</ol>
<h3 id="9-内存模型和名称空间"><a href="#9-内存模型和名称空间" class="headerlink" title="9.内存模型和名称空间"></a>9.内存模型和名称空间</h3><p>如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找;但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录（或其它目录，这取决于编译器）。如果没有在那里找到头文件，则将在标准位置查找。因此在包含自己的头文件时，应使用引号而不是尖括号。</p>
<p><strong>作用域</strong>：描述了名称在文件（翻译单元）的多大范围内可见。例如，函数中定义的变量可在该函数中使用，但不能在其它函数中使用;而在文件中的函数定义之前定义的变量则可在所有函数中使用。</p>
<p><strong>链接性</strong>：描述了名称如何在不同单元（源文件）间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量没有链接性，因为它们不能共享。</p>
<p>堆栈的默认长度取决于实现，但编译器通常提供改变堆栈长度的选项。</p>
<p>如果变量被关键字register修饰而存储在寄存器中，则没有内存地址，因此不能将地址操作符用于寄存器变量。</p>
<p>如果没有初始化静态变量，编译器就将反它设置为0.在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0.</p>
<p><strong>关键字valatile</strong>：表明即使程序代码没有对内在单元进行修改，其值也可能发生改变。例如，可以将一个指针指向某个硬件位置，其中包含了来串行端口的时间或信息，在这种情况下，硬件可能修改其中的内容。该关键字的作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值二次，面是将这个值缓存到寄存器中。这种优化假设变量的值在这二次使用之间不会变化，如果不将变量声明为volatile，则编译器将进行这种优化，将变量声明为volatile，相当于告诉编译器，不要进行这种优化。</p>
<p><strong>关键字mutable</strong>：指出即使结构（或类）变量为const，其某个成员也可以被修改(修饰某个成员)。</p>
<p><strong>const</strong>:在C++中(但不是在C中)，const限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。也就是说，C++看来，全局const就像使用了static说明符一样.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> state = <span class="number">50</span>;   <span class="comment">//内部链接性，常数变量</span></div></pre></td></tr></table></figure></p>
<p><strong>extern</strong>：程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> state = <span class="number">50</span>;  <span class="comment">//external linkge</span></div></pre></td></tr></table></figure>
<p><strong>布局new操作符</strong>：指定要使用的位置地址，程序员可能使用这种特性来设置其内在管理规程或处理需要通过特定地址进行访问的硬件。但不可delete(delete只能用于这样的指针：指向常规new操作符分配的堆内存。)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> (pointName) typeName;   <span class="comment">//向地址为pointName申请一个类型为typeName的空间地址给p1;</span></div></pre></td></tr></table></figure>
<h4 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h4><p><strong>声明区域</strong>：是可以在其中进行声明的区域。例如，可以在函数外面声明全局变量，对于这种变量，其声明区域为其声明所在的文件，对于在函数中声明的变量，其声明区域为其声明所在的代码块。</p>
<p><strong>潜在作用域</strong>：变量的潜在作用域从声明开始，到其声明作用域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。</p>
<p><strong>作用域</strong>：变量对程序而言可见的区域。变量并不是在潜在作用域内都可见，比如子代码块定义的变量隐藏现象。</p>
<p><strong>名称空间</strong>：通过定义一种新的声明来创建命名的名称空间。这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间中相同名称发生冲突，同时允许程序的其它部分使用该名称空间中的声明的东西。</p>
<p>名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//名称空间中的声明和定义规则同全局声明和定义规则相同。</span></div><div class="line"></div><div class="line"><span class="comment">//在*.h中的声明</span></div><div class="line"><span class="keyword">namespace</span> Jace</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">float</span> f;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</div><div class="line">struck Well&#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在*.cpp中的定义</span></div><div class="line"><span class="keyword">namespace</span> Jace</div><div class="line">&#123;</div><div class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span> ;</div><div class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">      <span class="comment">//todo.</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>全局名称空间</strong>：它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于于全局名称空间中，引用全局变量可以为::valueName。</p>
<p><strong>using声明</strong>：使特定的标识符在当前作用域可用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">//仅使用std::cout时可直接使用cout而不带作用域解析操作符，但std中的其它名称不可以。</span></div></pre></td></tr></table></figure>
<p><strong>using编译指令</strong>：使整个名称空间中的名称在当前作用域可用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">//则std名称空间中所有名称可在当前作用域中直接使用而不用带有作用域解析操作符。</span></div></pre></td></tr></table></figure>
<p>使用using声明时，就好像声明了相应的名称一样。如果某个名称已经在函数中声明了，则不能用using声明导入相同的名称。然而，使用using编译指令时，将进行名称解析，就像在包含using声明和名称空间本身的最小声明区域中声明了名称一样。如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。</p>
<p>假设名称空间和声明区域定义了相同的名称。如果试图使用using声明将名称空间的名称导入该声明区域，则这二个名称会发生冲突，从而出错。如果使用using编译指令将该名称空间的名称导入该声明区域，则局部版本将隐藏名称空间版本。</p>
<p>在名称空间中可以嵌套使用using声明和using编译指令来生成新的名称空间。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">namespace</span> elements</div><div class="line">&#123;</div><div class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> <span class="comment">//或</span></div><div class="line"> <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>名称空间别名</strong>：using myNewName = myth::elements::fire;</p>
<p><strong>未命名的名称空间</strong>：就像后面跟着using编译指令一样，也就是说，在该名称空间中声明的名称的潜在作用域为：从声明点到该点声明区域末尾，从这个方面看，它们与全局变量相似。不过由于这种名称空间没有名称，因此不能显式地使用using声明或using编译指令来使它在其它位置都可用。具体地说，不能在当前的名称空间所属文件之外的其它文件中，使用该名称空间中的名称，因此这种方法可以替代链接性为内部的静态变量。实际上，C++标准不乱在名称空间和全局作用域中使用关键字static。</p>
<p><strong>名称空间指导原则</strong>：</p>
<ul>
<li>使用在已命名的名称空间中的变量，而不是使用外部全局变量。</li>
<li>使用在已命名的名称空间中的变量，而不是使用静态全局变量。</li>
<li>如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++当前提倡将标准函数库放在名称空间为std中，这种做法扩展到了来自C语言中的函数。</li>
<li>仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。</li>
<li>不要在头文件中使用using编译指令。首先这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include之后。</li>
<li>导入名称时，首选使用作用域解析操作符或using声明的方法。</li>
<li><strong>对于using声明，首选将其域设置为局部而不是全局</strong>。</li>
</ul>
<p><strong>老式头文件（如iostream.h)没有使用名称空间，但新头文件iostream使用了std名称空间。</strong></p>
<h3 id="10-对象和类"><a href="#10-对象和类" class="headerlink" title="10.对象和类"></a>10.对象和类</h3><p><strong>构造函数</strong>：专门用于构造新对象、将值赋给它们的数据成员。</p>
<ol>
<li>没有返回值，但没有被声明为void类型。实际上，构造函数没有声明类型。</li>
<li>当构造函数可使用一个参数时，接受一个参数的赋值句法来将对象初始化为一个值。如：ClassName obj = value;</li>
<li>如果没有定义任何构造函数，那编译器会生成一个啥也不作的默认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造函数。</li>
<li>使用构造函数初始化对象。 </li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ClassName a = ClassName(value1, value2);   <span class="comment">//使用带参构造函数初始化对象a或临时对象(对于初始化临时对象，再赋值给a对象，临时对象释放调用析构函数)，C++标准允许编译器使用两种方式来执行，第一种是直接初始化对象a,无临时对象，另一种是初始化临时对象，再赋值给对象a，然后临时变量调用析构函数释放。</span></div><div class="line"></div><div class="line"><span class="function">ClassName <span class="title">a</span><span class="params">()</span></span>;               <span class="comment">//使用无参构造函数初始化对象a，没有临时对象产生。</span></div></pre></td></tr></table></figure>
<p><strong>析构函数</strong>：对象过期时，程序将自动调用一个特殊的成员函数，完成清理工作。</p>
<ol>
<li>析构函数没有返回值类型，没有参数，其名称为类名称前加上~，且每个类只能有一个析构函数。</li>
<li>如果创建的是静态存储对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时自动被调用。如果对象是通过new创建的，则它将驻留在堆栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动调用。</li>
<li>自动变量放在堆栈中，优先清理后定义的变量，因此最后创建的对象将最先被删除，最先创建的对象将最后被删除。</li>
</ol>
<p><strong>const成员函数</strong>：如果定义了一个ClassName类型的对象a,且修饰成const，那么对象a的成员变量不能改变，但如果调用其成员方法，不能确保方法不修改其成员变量。因些对于这些方法，使用const关键字，保证函数不会修改调用对象。声明和定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span><span class="keyword">const</span></span>;                <span class="comment">//类中声明</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> ClassName::fn(<span class="keyword">int</span>, <span class="keyword">float</span>)<span class="keyword">const</span>&#123;&#125;;   <span class="comment">//定义</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">const</span> Stock &amp; <span class="title">top</span><span class="params">(<span class="keyword">const</span> Stock &amp;s)</span><span class="keyword">const</span></span>;  <span class="comment">//括号中的const表明，该函数不会修改被显式地访问的对象，而括号后的const表明，该函数不会修改被隐式地访问的对象。由于该函数返回了二个const对象之一的引用，因些返回值类型也应为const引用。</span></div></pre></td></tr></table></figure>
<p><strong>this</strong>:this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）。</p>
<p>毕竟类的目标之一是使用户定义的类型与内置类型尽可能的相似，类的构造函数负责确保调用对象成员的构造函数。名为成员初始化列表的特性可提高构造函数设计的效率。</p>
<p><strong>类作用域</strong>：在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类之外是不可知的。</p>
<p><strong>作用域为整个类的常量</strong>：</p>
<ol>
<li><strong>在类中声明一个枚举</strong>：在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称。用这种方式声明枚举并不会创建类数据成员，也就是说，所有对象中都不包含枚举。另外，枚举常量只是一个符号名称，在作用域整个类的代码中遇到它时，编译器将用实际值来替换它。</li>
<li><strong>使用static关键字</strong>：创建一个常量，该常量与其它静态变量存储在全局区，而不是存储在对象中。作用域为类作用域，存储在全局区，被这个类的所有对象共享。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      个人根据已有的C基础，学习《C++ Primer Plus》的学习笔记
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="C++" scheme="http://LySnake.github.io/tags/c/"/>
    
      <category term="C++ Primer Plus" scheme="http://LySnake.github.io/tags/c-primer-plus/"/>
    
  </entry>
  
  <entry>
    <title>电脑小白系列之电脑常见错误诊断</title>
    <link href="http://LySnake.github.io/archives/technology/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD%E7%B3%BB%E5%88%97%E4%B9%8B%E7%94%B5%E8%84%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E8%AF%8A%E6%96%AD.html"/>
    <id>http://LySnake.github.io/archives/technology/电脑小白系列之电脑常见错误诊断.html</id>
    <published>2017-05-21T10:45:03.000Z</published>
    <updated>2017-06-19T14:30:13.800Z</updated>
    
    <summary type="html">
    
      先挖下坑
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
  </entry>
  
  <entry>
    <title>电脑小白之操作系统安装</title>
    <link href="http://LySnake.github.io/archives/technology/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD%E7%B3%BB%E5%88%97%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.html"/>
    <id>http://LySnake.github.io/archives/technology/电脑小白系列之操作系统安装.html</id>
    <published>2017-05-05T17:34:38.000Z</published>
    <updated>2017-05-10T14:39:41.228Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍windows系统安装，以此让小白放心安装其它系统，比如手机Android、iOS，以及PC上的linux系统。<br><a id="more"></a></p>
<p>###操作系统的本质###<br>其实，说白了，操作系统也是一个软件，作为一个软件，你可以放心地在机器(PC、手机等)上卸载与安装，只是因为操作系统本身要管理计算机资源(软件、硬件)，其它软件或用户都要借助操作系统才能操作机器，所以操作系统的”卸载与安装”比其它软件更麻烦些，如果失败，机器会无法正常运行，也有可能因为操作失误，造成数据丢失，但这一切都不会影响电脑本身硬件，所以安装系统失败可以再交安装，因此在安装系统中最重要的就是小心误操作引起的数据丢失。另外，在手机上传说有自己安装系统，因为影响引导系统的软件从而导致无法再安装系统从而成为“砖块机”，不过这种情况目前也只是听过。</p>
<p>###PC安装windows方式###</p>
<p>####U盘PE系统安装####<br>这种方式安装windows系统，有个优点就是失败了，你还可以借助U盘PE系统进入PC，可以从PC的硬盘中再得到其它文件(包括安装使用的系统文件)，可以再次安装，对新手来说安装起来放心些。所以在这种U盘PE安装方式中，你可以多下载几个系统文件(支持<em>.ios或</em>.ghost),避免因某一系统文件安装失败而导致PC无法开机且难以更换另一系统文件。制件U盘PE系统，有很多软件，比较常见的有<a href="http://www.laomaotao.org/" target="_blank" rel="external">老毛桃</a>和【大白菜】(大白菜还是算了吧，网上有个一样内容的盗版网站，太难分辨了，假网站的系统文件如果自带电脑病毒，杀软也可能无力。这假网站还是百度加V的，所以百度有多差呢？)</p>
<p><a href="http://www.laomaotao.org/jiaocheng/92/upqdzz.html" target="_blank" rel="external">老毛桃制作U盘PE系统</a></p>
<p><a href="http://www.laomaotao.org/jiaocheng/92/upzwin7.html" target="_blank" rel="external">老毛桃安装windows 7系统</a></p>
<p>####U盘iso文件安装####<br>微软官方都是以光盘出售windows操作系统的，ghost文件都是网友自己二次制作或都说是备份系统文件，所以网上还有光盘copy下来的iso文件可供使用，但是这种文件默认是写在光盘上的，所以U盘iso安装其实就是把iso文件写入U盘中，以U盘冒充光盘，让计算机以读光盘的方式读U盘，从而操作官方的安装方式，最常见的系统文件都是iso文件，所以这种方式支持安装windows和linux等，只是写入U盘时对ULtraISO操作选择不同的引导选项。这种方式写入U盘，会导致U盘成为一个只有iso且不能再存文件的U盘，除非格式化(格式化如果失败，只能使用更强的格式化方式，比如linux下的dd命令)。</p>
<p><a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="external">UltraISO</a></p>
<p><a href="http://blog.csdn.net/baigoocn/article/details/47406473" target="_blank" rel="external">UltraISO制作U盘iso安装系统</a></p>
<p>####硬盘本地安装####<br>下载的iso文件(使用<a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="external">UltraISO</a>或<a href="https://daemon-tools.softonic.com.br/" target="_blank" rel="external">DAEMON Tools Lite</a>装载或解压，但别使用rar或7z，可能会有错误导致安装失败)或*.rar类文件，装载或解压后，在一级子目录下会有setup.exe类似的可执行软件，运行后会进入安装界面。这种方式简单，不要使用U盘，只要系统文件就好，但其实安装windows系统有时会因为系统文件缺失某些驱动，而导致安装失败，而此此时有可能处于安装到一半，导致原来的系统已破坏而不能开机。所以这种方式，推荐是在有安装经验的情况下再使用。</p>
<p>###系统安装注意事项###<br>综上，安装操作系统不会影响电脑硬件，正常情况只是导致破坏原有的操作和系统导致不能正常开机，你可以重新安装系统以恢复计算机。目前只是听过手机有操作失误导致破坏引导软件，引起不能再交安装系统而成为“砖机”，但这种情况还是很少出现。那，在安装系统的时候，最怕出现的是什么呢？</p>
<ul>
<li>对系统分区不了解，原本安装windows系统，只要安装在原来的C分区中，但在安装系统时，当时的C分区已经不显示C分区了，误操作安装系统到另一分区，导致把一分区格式化装了操作系统。</li>
<li>ghost有一种版本，似乎是针对电脑城全新安装系统用的，安装系统默认会对硬盘重新分区，导致硬盘数据全部丢失。</li>
<li>安装系统，默认会把安装系统的分区格式化，所以这个分区的用户数据要分备份，在安装windows中，C盘就是我们要安装的分区，要先备份C盘中的个人文件，比如常见的桌面上的文件、以及默认下载的文件目录等。</li>
</ul>
<p><strong>所以，安装系统最重要的就是要备份好自己的文件，数据无价</strong></p>
<p>###针对小白的虚拟机安装系统练习###<br>使用<a href="http://www.vmware.com/cn.html" target="_blank" rel="external">VMware</a>或<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">VirtualBox</a>虚拟软件，在windows系统上，进行安装虚拟系统，可以试着了解下安装系统会有什么操作、大概过程是什么，这种方式安装对现有系统很安装，要安装的虚拟系统与现在使用中的系统是完全分离的，不会影响现有分区与数据，仅会写入一个比较大的文件，但这个方式对于很老的电脑来说，可能会很卡。</p>
<p><a href="http://blog.xuite.net/yh96301/blog/30283132-VirtualBox+%E5%AE%89%E8%A3%9D+Windows+7+%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" target="_blank" rel="external">VirtualBox安装win7教程</a></p>
<p>###计算机多系统安装###<br>了解下<a href="http://cn.linux.vbird.org/linux_basic/0130designlinux_2.php#partition_mbr" target="_blank" rel="external">多系统引导</a>，可以实现在一个实体机中，同时安装windows、iOS、linux系多个系统，可以每次开机选择自己要进入的系统，实现windows日常使用，linux、iOS办公，当然，这个也可以装虚拟机。原理简单的说就是开机启动后，主板BOIS会读硬盘固定位置数据（引导程序代码），BOIS把CPU控制执行权交给引导程序，引导程序再从硬盘分区上找到安装了系统的的分区再把CPU控制权给操作系统，因此可以有多个分区分别装有不同的系统，让这引导程序引导进行选择运行哪个系统。</p>
<p><a href="http://msdn.itellyou.cn/" target="_blank" rel="external">正版windows系统文件下载</a></p>
<p><a href="http://cn.linux.vbird.org/linux_basic/0130designlinux_2.php#partition_table" target="_blank" rel="external">硬盘分区与引导程序</a></p>
<p><a href="http://neosmart.net/EasyRE/" target="_blank" rel="external">EasyBCD修复引导程序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍windows系统安装，以此让小白放心安装其它系统，比如手机Android、iOS，以及PC上的linux系统。&lt;br&gt;
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="电脑小白" scheme="http://LySnake.github.io/tags/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD/"/>
    
  </entry>
  
  <entry>
    <title>电脑小白系列之电脑硬件了解</title>
    <link href="http://LySnake.github.io/archives/technology/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD%E7%B3%BB%E5%88%97%E4%B9%8B%E7%94%B5%E8%84%91%E7%A1%AC%E4%BB%B6%E4%BA%86%E8%A7%A3.html"/>
    <id>http://LySnake.github.io/archives/technology/电脑小白系列之电脑硬件了解.html</id>
    <published>2017-02-19T09:46:46.000Z</published>
    <updated>2017-03-19T23:11:38.520Z</updated>
    
    <content type="html"><![CDATA[<p>本方主要讲下常用电脑中的硬件与相关功能，旨在了帮助小白了解计算机硬件。<br><a id="more"></a></p>
<h2 id="冯·诺伊曼结构"><a href="#冯·诺伊曼结构" class="headerlink" title="冯·诺伊曼结构"></a>冯·诺伊曼结构</h2><p>如今的计算机，都是以1945年6月30日冯·诺伊曼提出的基本结构：计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成。每个组成部分可能存在于一台计算机中不同硬件位置上。</p>
<blockquote>
<p><em>运算器、控制器（CPU）</em>：这二个基本部件，在工程实现上都存在于中央控制处理器CPU中，有任何操作请求，一定都会到CPU中请求处理。在实际用户操作中，所有用户操作，都会抽象成一系列的数学运算、逻辑运算，也都要交于CPU处理，所以CPU决定了计算机最高处理性能，在个人组装机中，优先选择的都是CPU，其次再选择其它硬件设备。</p>
<p><em>存储器</em>：存储器类别很多，在小白的眼里，只要记得内存、硬盘（移动硬盘）、U盘、固态硬盘(SSD)这几样就好了。按主流硬件读取速度来说，内存&gt;固态&gt;U盘&gt;硬盘，特殊一点的是内存是一个断电就会丢失存储数据的一个临时存储设备，充当CPU与硬盘（机械硬盘和固态硬盘）之间的高速缓存。个人电脑中所有数据都要从内存中读取进CPU再进行处理，但对于计算机来说，不一定要有内存计算机才能运行。</p>
<p><em>*输入设备</em>：输入设备常见的有键盘、鼠标、麦、触摸板、手写板，接收用户操作(转换成数据)给计算机进行处理。</p>
<p><em>*输出设备</em>：输出设备常见的有显示器、耳机，输出计算机处理后的数据，提供给用户进行交互操作。</p>
</blockquote>
<h2 id="电脑中常见硬件"><a href="#电脑中常见硬件" class="headerlink" title="电脑中常见硬件"></a>电脑中常见硬件</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>在个人计算中，中高端CPU都是使用Intel公司产品，中低端CPU都是使用AMD公司产品，目前组装个人电脑都是以i5往上走，i3很少使用了，在15年上市了新的Skylake系列，支持读取性能更高的内存条、更省电。个人电脑更像是一个集权的国家，CPU代表着中央政府，所有处理都要交于CPU处理、分发执行。另外，当前CPU也负责显示方面的计算,也就是说CPU内还有一个GPU，就是我们常说的集显，但因为GPU常计算小数类型的值，CPU主要是整数类型和逻辑值，另外也因为显示渲染在个人PC中越来越重要，产热也高，所以GPU可以单独有一个硬件，那就是显卡。这种问题常见于笔记本中，在买笔记本时，常说独显更好，是因为独立显卡有自己的内存条，且高端显卡的内存已经是第五代的DDR5了，有独显后，显卡和CPU都有各自的存储，并且，独显有自己更强更专一的渲染，不会占用CPU使用内存导致内存不足，也不会占用CPU的计算而延迟用户操作的响应。</p>
<h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>主板通常认为是载体就好了，类似于自行车的三角架一样，其它部件都要在其上搭载。通常CPU决定了计算机的计算性能，通过CPU引出的针角查看哪些主板能使用，另外，主板上也存在其它的芯片，用于辅助CPU进行控制用的，还自带声卡、网卡等，所以主板还负责网络接收与发送，数字信息转成音频信息等。不论是CPU、内存条、电源、显卡、硬盘、独立声卡、光驱等，都要与主板联接进行信息传输。电脑开关、USB接口、显示器接口、网线接口、耳机接口等都在主板上面。如果是台式电脑，所有的这些硬件接口都是规范化的，并且也是防呆设计(指接口设计避免用户插错，只有用蛮力才有可能插错)，不用担心插错问题。</p>
<h3 id="独立-显卡"><a href="#独立-显卡" class="headerlink" title="(独立)显卡"></a>(独立)显卡</h3><p>显卡负责图像的渲染，显示器显示的内容都是从显卡中获得。显卡插在主板上，对外可接显示器的信号线，显卡有自己独立的内存，就是我们说的显存，好的显卡已经使用第五代DDR5的内存，对于晃卡而言，并不是显存越大越好，显存大但速度慢一样是渣显卡，这也是电脑城骗术之一。但电脑是可以不用显卡的，可以使用集成显卡，也就是使用CPU内的GPU，不过这个就看CPU的性能与用户自己的需求了，玩大型游戏还是要独立显卡，如lol、使命等，日常看视频、QQ游戏等，集成显卡就好。</p>
<h3 id="内存条"><a href="#内存条" class="headerlink" title="内存条"></a>内存条</h3><p>前面提到过，内存是<code>一个断电就会丢失存储数据的一个临时存储设备，充当CPU与硬盘（机械硬盘和固态硬盘）之间的高速缓存</code>,目前老电脑都是4G内存，主流已经开始8G内存了，现如今手机都开始8G内存了。内存在计算机体系系统中，充当CPU与硬盘之间的高速缓存，对于计算机来说，内存越大越好，如果可以，操作系统会根据用户常用软件、文件等，尽可能把内存全部使用完。当前内存的速度在第三代内存DDR3的1600MHZ左右，新的Skylake系列支持第四代内存DDR4的2133MHZ。</p>
<h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>目前市场的机械硬盘都是1T，500G的机械硬盘开始减少，另外，还有固态硬盘(SSD)，读写速度是机械硬盘的好几倍，常见的还只是128G和256G，它们都是一种相对永久的存储设备，所有文件、软件都保存在硬盘中。现在，CPU和内存的性能都在快速提升，而机械硬盘受限于机械结构，读写速度提升相对过慢，已成为计算机体系的一个瓶颈，目前苹果电脑都配有固态硬盘，开机流畅响应快速，如果你也想有这样的电脑体验，请安装固态硬盘，把windows操作系统安装在固态硬盘中，常用软件也安装在固态硬盘中，如果还有机械硬盘，把不常用文件使用机械硬盘存储。另外，读写快速的固态硬盘，也只是能更快速地把文件从固态硬盘上读写到内存中，以此来加快开机速度和响应速度，但并不能改变CPU的执行速度和内存的读写速度，但确实会有更好的用户体验。</p>
<h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><p>显示器把显卡(集显或独显)处理过的显示数据通过旧的VGA接口或更高传输速率的HDMI接口传输到显示器进行显示，现在主流显示器有19寸、24寸甚至更大的，类型也很多样。如果细看电视机或显示器，是能看到很微小的点阵的，这个类似于图片或视频的1080 <em> 1920这种，表示有乘积个像素点，每个像素点使用RGB(红绿蓝)三色组成万千色，常见的每一色1个字节(8个bit即8位的2进制，如果一张图1080 </em> 1920 像素点，图片大小大概是1080 <em>  1920 </em> 3 / 1024 KB)，按色彩程度不同，共有256种，三色组合就有256 <em> 256 </em> 256种色彩，还有使用RGBA作为像素点数据的，只是多了一位A(透明度)。</p>
<h3 id="键盘、鼠标"><a href="#键盘、鼠标" class="headerlink" title="键盘、鼠标"></a>键盘、鼠标</h3><p>鼠标没有什么说的，都是光电鼠标，也有一些人体工程学鼠标，如果是玩游戏，鼠标还是要大一些的好用些，精度掌控更高。但是相对键盘而言就有很多讲头了。笔记本电脑和常见的100元以下的键盘，都是薄膜键盘，价格便宜，但是手感差，基本上也没有什么人体工程学上的设计，高端点的键盘，基本上都是机械键盘，手感多样，更适合打字、游戏等偏向，而且也更耐用(据说专业打字的也可以用50年这样的年限)，另外，机械键盘具有很高的自定义化，可以自己组装些背光灯、换键冒、换轴等，所以如果是只坏了几个键，也是可以自己行购买配件维修的。根据按键轴的不同，键盘会有不同的按键反馈，比如对于常打字的来说，青轴机械键盘每一次按键，都会有二次触感反馈，而且所需力道少，另外就是还有一个声音反馈。但机械键盘也有缺点，就是碰水就坏，主要生产轴的公司也就那么几家，国内的轴厂都太次了，容易坏轴，另一个就是价格比较高，cherry轴最低也要将近400元。那有其它一些键盘，水很深。不论是鼠标还是键盘，都是使用USB接口，老旧的有PS/2接口。</p>
<h3 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h3><p>电脑电源连接家庭用电，转化输出给CPU、主板、显卡、硬盘等供电，电脑正常运行与高速运行，它的耗电是不一样的，所以好的电源应能提供最高电量，如果电脑在高速运行中电源不能提供充足的电能，那可能会无由头的停机且不好查找问题。在某些装机教程中，作者会建议读者不要购买某宝或电脑城里已经组好的整机，因为你看到的电脑配置，主要配件确实是对应的配件，可是对于大多数的我们来说，卖家更老道，他们可以使用二手CPU、显卡，虽然它们是正品，又或者次品点的内存条，而买家都只是会看一般的参数，常见的就是下个鲁大师软件查看配置，这根本无法了解到卖家作了什么，而且一台电脑，可动手的地方很多，虽然主要配件最多是次品，部分配件因为不起眼，真的就有可能会成为电脑的短板。其中之一就是电源，一般买家没有谁看电源，而电源品牌也很混杂，就算一般买家查看了这点，你也就是看个功率，好像很强的样子，可是，关注过材料吗？铭牌参数具体的意义吗？电脑的参考功率，其中有很多文章，它的实际意义是说，各种组合最高是350W或500W，但其中还有转化率的问题，还有就是，每一种组合也有它的最大功能，不论是组合的还是最终的功能，都不能超。因为电源给CPU、主板、显卡、硬盘供电，也差不多这样分成组，CPU组不能超过多少，显卡供电不能超过多少，主板不能超过多少，各组之合不能超过电脑额定功率*转化率。所以对于一个500W的电源确不一定比350W的电源更适合你的电脑。另一方面，材料问题，线问题，接口问题，因此在某宝或电脑城购买已配好的电脑，不好花点时间自己组得更放心。</p>
<h2 id="引申链接"><a href="#引申链接" class="headerlink" title="引申链接"></a>引申链接</h2><p><a href="http://linux.vbird.org/linux_basic/0130designlinux.php#hardware" target="_blank" rel="external">&lt;鸟哥的linux私房菜&gt;中关于硬件的形象化描述</a><br><a href="http://linux.vbird.org/linux_basic/0510osloader.php#startup" target="_blank" rel="external">&lt;鸟哥的linux私房菜&gt;之开机流程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本方主要讲下常用电脑中的硬件与相关功能，旨在了帮助小白了解计算机硬件。&lt;br&gt;
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="电脑小白" scheme="http://LySnake.github.io/tags/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD/"/>
    
  </entry>
  
  <entry>
    <title>电脑小白系列之电脑日常管理</title>
    <link href="http://LySnake.github.io/archives/technology/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD%E7%B3%BB%E5%88%97%E4%B9%8B%E7%94%B5%E8%84%91%E6%97%A5%E5%B8%B8%E7%AE%A1%E7%90%86.html"/>
    <id>http://LySnake.github.io/archives/technology/电脑小白系列之电脑日常管理.html</id>
    <published>2017-02-09T13:03:48.000Z</published>
    <updated>2017-02-19T06:50:46.096Z</updated>
    
    <content type="html"><![CDATA[<p>在生活中经常会碰到电脑乱成一团，软件都是百度系，各种小广告软件，重复软件，一台电脑同时存在360、百度、腾讯、金山多家杀软，有这些特点的人大多是文科生为主，次之还有老一代人。对此，本文主要说些电脑文件管理、软件管理等常见的小白问题。<br><a id="more"></a></p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>打开<code>我的电脑</code>，可以看到C盘D盘等。一般的桌面上的所有文件也是存储于C盘用户目录下。计算机对于文件管理，是以树型结构进行管理的，每个盘符可以看做一个树根，其下的每个文件夹都可以看做是子树或形象点说是树枝，对于经常查看文件管理器的人来说，这已经是老生常谈，但我要说的是针对常用软件安装目录与个人文件保存问题。</p>
<blockquote>
<p><code>C盘</code>是安装windows系统的系统盘，基本都是大多数软件的默认安装盘，一般常见的安装系统C盘空间大小是50G，只要C盘还留有足够空间，系统并不提示C盘空间不足，那都是没关系的。操作系统windows大多数软件、文件、配置都保存在C盘中，比如office软件，系统自带的工具软件。但是现在的网络环境，很多软件都安装在C盘，个人下载也是默认在C盘，长时间使用C盘的软件，也会给C盘带来缓存文件，这样就会给C盘带来很多文件，当然，只要C盘有空间，这都是没关系的，只是个人下载文件、桌面文件都在C盘，如果电脑出现问题，需要重装系统解决，那么C盘将会清空并重新写盘，日常下载的文件、桌面文件都会清空且永久找不回。</p>
<p><code>其它盘</code>对widows来说，基本相同，除非是系统隐藏分区。安装windows系统，正常情况下都是只对C盘操作，其它盘文件都不作更改。因此，在日常管理上，个人重要文件尽量放在其它盘;其它软件，如视频软件、迅雷下载软件等，对其下载目录也最好是其它盘，且目录名可分辨。这样，自己下载的文件、个人编写的文件不会因为C盘的变动而被删除。</p>
<p><code>个人管理方案：</code>即然C盘是系统使用，那只有某些主要的软件才安装在C盘(输入法、杀毒、微软官方软件等)，其它软件全都安装在D盘的<code>Program Files (x86)</code>目录下，且保证每个软件都有一个单独的文件夹，对于下载文件、个人文件，都可存放与E盘或F盘，另外给每个盘符起个别名。各盘符大小，视个人情况而定。另外，还要说一点，对于丢失会带来重要影响的个人文件，最好是使用云盘备份（工程上都会有备份盘，甚至是异地备份盘），因为硬盘是PC机里最容易坏的硬件，同样的，如果文件过于私密，最好使用点加密手段。</p>
</blockquote>
<h2 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h2><p>鉴于国内的软件环境，尤其是百度系列，我们会发现，对于不常使用电脑的老年人、只用电脑看韩剧的软妹了，电脑中会出现过多无用或重复的软件。这里就说下软件使用问题，并自荐下<a href="https://lysnake.github.io/archives/technology/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90.html">个人常用软件列表</a>。</p>
<h3 id="杀毒软件"><a href="#杀毒软件" class="headerlink" title="杀毒软件"></a>杀毒软件</h3><p>其实吧，现在操作系统自身的防御能力已经很强了，不再经常看到电脑中毒了，虽然没有不存在BUG的软件(系统),但能找出BUG的人，都不是缺钱的主。现在如果说还有中毒的人，那真的是要找自己的原因，因为那都是自己进不该进的网站误下可执行的软件(病毒)。在windows下，对于小白来说，能遇见执行的病毒，都是exe为扩展名的可执行文件，所以如果上网下载的文件是exe文件，那么小白应该警惕，不要执行它，除非你知道会带来什么。但是，在生活中，小白都是金山、360、电脑管家、百度杀毒二个或多个重复杀毒功能的软件，大多情况下，其实他们并没有用，尤其是电脑管家和百度杀毒，反而会带来卡慢，百度杀毒更加是自身就是病毒。如果要安装，建议仅安装360或金山，自从win7开始，我就没怎么用杀毒软件了，但是金山和360杀毒其它管理功能还是很不错的，比如开机加速、强制删除文件等。</p>
<h3 id="重复软件"><a href="#重复软件" class="headerlink" title="重复软件"></a>重复软件</h3><p>前面提到杀毒软件功能重复，在小白的电脑中，同时存在360浏览器、橙子浏览器、chrome、firefox,这里也同样是重复功能的软件，占用硬盘空间并且有可能占用内存，导致操作响应过慢，个人推荐chrome或firefox，最新版的chrome和firefox能更好的支持网页渲染，看到更多网页特效，也能有更好的加载速度，更有强大的插件功能。明显的，每种功能的软件，正常情况下只要一个就好。对于已知无用的软件，占用了硬盘空间，如果开机自启，还会影响开机速度和占用内存，造成电脑卡慢，这个时候应该使用windows自带的软件管理工具或360、金山杀毒的软件管理工具，对无用软件进行卸载清除。</p>
<h3 id="软件黑名单"><a href="#软件黑名单" class="headerlink" title="软件黑名单"></a>软件黑名单</h3><p><strong>百度系</strong>是常见的软件黑名单，安装一个百度系软件，默认推荐安装其它软件，这就是为什么小白电脑里那么多不知用处的软件的原因，如果可以，尽量少用百度搜索，因为百度推荐、百度认证很有问题，并且搜索精准度并不高，在安装系统时使用的PE系统大白菜，百度认证认证的一个所谓的官网，居然是个高仿假网站，以此安装的系统，完全可能自带病毒、广告。16年的莆田系医院、血友病吧问题，有理由直接把百度直接拉入黑名单，目前已知百度好用的产品，也就只有百度云盘了。另外，如果你还是使用百度，建议你不要在网页上登录百度，因为你登录后，你在百度上搜索或其它百度网页操作的信息会被百度收集，然后进行所谓精准广告投放，而广告本身也存在很大的不可靠性，另外就是，你在网上所有的个人操作也是属于个人隐私，百度今天收集的信息，可能低价出售、安全原因泄漏等。不使用百度搜索了，大家可以使用bing搜索、google搜索，在<a href="https://lysnake.github.io/archives/technology/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90.html">个人常用软件列表</a>中提供了使用方式。</p>
<p><strong>不常见、非官网下载</strong>的软件，也会有默认安装好几个其它软件或带来很多广告，也有可能是病毒的载体，如果不是很清楚执行的后果，最好是不要下载并执行。</p>
<h2 id="电脑优化"><a href="#电脑优化" class="headerlink" title="电脑优化"></a>电脑优化</h2><p>个人电脑中，如果已经不存在多余的软件、软件安装不会使C盘出现空间警告、文件保存结构清晰，我们还可以开始进行其它电脑优化来进一步改善个人电脑环境。这个时候，我们就可以使用360杀毒或金山毒霸，进行开机启动项优化，选择自己开机一定会使用的功能软件，让其开机自启动，其它软件取消开机启动，这样能加快开机速度，减少开机后内存使用。同样也可以用360或金山扫盘、清除无用文件、查杀病毒、删除某些情况下无法删除的文件等。</p>
<p>像<a href="https://lysnake.github.io/archives/technology/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90.html">个人常用软件列表</a>提到过的软件一样，安装自己常用的软件，配置自己最习惯的软件环境，比如chrome插件、翻墙、wox快速启动软件、everything快速搜索本地文件、开机自启动、开机自动联网等。</p>
<h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><p><strong>硬盘碎片整理</strong>:网上很多人说硬盘读取过慢是因为分区使用久后，产生了很多文件碎片，导致硬盘寻道时间增长，这个说法是有道理的，但这个说法只适合机械硬盘，固态硬盘不适用。另外一点就是，碎片整理的概念已经很久了，而且硬盘读取速度一直都是计算机性能瓶颈，所以现在的硬盘和操作系统，在软件算法上会有相关优化，尽量减少碎片的产生，所以对于目前来说，是没有必要进行碎片整理的，而且这个操作过程中如果关机等特殊情况，是会影响操作系统或其它分区无法正常使用，如无必要，不要考虑碎片整理。另外，早上固态硬盘，可以得到更好的性能体验。</p>
<p><strong>缓存清理</strong>：其实对于用户而言，缓存的存在本身是为了让软件有更好的体验的，比如看视频，对于已缓存的时段，是可以直接跳看的，而没有缓存的部分，选择后还要等待网络加载后才能观看，而其它软件的缓存其实基本都是一样的道理，都是为了不重复从网络上加载或重新生成而影响软件响应用户的操作用的。但存在另外一些软件文件，仅仅是软件生成出来备用的，正常情况下是使用不到的，这类文件相对很少但可以删除，比如软件的log文件，方便软件崩溃时，上送Log日志给官方维护修改使用。缓存文件相对分区大小来说，还是占用很少一部分，在不使分区空间不足的情况下，也不用考虑操作删除缓存。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在生活中经常会碰到电脑乱成一团，软件都是百度系，各种小广告软件，重复软件，一台电脑同时存在360、百度、腾讯、金山多家杀软，有这些特点的人大多是文科生为主，次之还有老一代人。对此，本文主要说些电脑文件管理、软件管理等常见的小白问题。&lt;br&gt;
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="电脑小白" scheme="http://LySnake.github.io/tags/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD/"/>
    
  </entry>
  
  <entry>
    <title>常用软件推荐</title>
    <link href="http://LySnake.github.io/archives/technology/%E7%94%B5%E8%84%91%E5%B0%8F%E7%99%BD%E7%B3%BB%E5%88%97%E4%B9%8B%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90.html"/>
    <id>http://LySnake.github.io/archives/technology/电脑小白系列之常用软件推荐.html</id>
    <published>2017-02-06T07:09:00.190Z</published>
    <updated>2017-06-28T15:50:01.136Z</updated>
    
    <content type="html"><![CDATA[<p>分享与记录个人常用软件，包括widows、linux、chrome系,同样，如果您有更好的软件，还请在评论区分享出来。<br><a id="more"></a></p>
<h2 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h2><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><a href="https://www.zhihu.com/question/28013848" target="_blank" rel="external">如何高效地使用搜索引擎？</a>：来自zhihu的问答。</p>
<p><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="external">Proxy SwitchyOmega</a>:来自<a href="https://github.com/XX-net/XX-Net" target="_blank" rel="external">XX-Net</a>,插件单独使chrome使用XX-Net搭建梯子，也可以不使用插件，使PC全局智能上梯子。</p>
<p><a href="https://chrome.google.com/webstore/detail/clickclean/ghgabhipcejejjmhhchfonmamedcbeod" target="_blank" rel="external">Click&amp;Clean</a>:管理工具，可管理chrome，也可以管理PC设备。</p>
<p><a href="https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj" target="_blank" rel="external">Save to Pocket</a>:pocket，可存网页到网上，支持iOS、安卓平台，支持zhihu等APP或网页分享到pocket APP。</p>
<p><a href="https://chrome.google.com/webstore/detail/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E5%8A%A9%E6%89%8B%EF%BC%9Abilibilicom-%E7%BB%BC%E5%90%88%E8%BE%85%E5%8A%A9%E6%89%A9%E5%B1%95/kpbnombpnpcffllnianjibmpadjolanh" target="_blank" rel="external">嗶哩嗶哩助手</a>:B站，看直播可自动化领取瓜子等。</p>
<p><a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm" target="_blank" rel="external">擴充功能uBlock Origin</a>:一款高效率的廣告攔截工具。</p>
<p><a href="https://chrome.google.com/webstore/detail/dream-afar-new-tab/henmfoppjjkcencpbjaigfahdjlgpegn" target="_blank" rel="external">遠方 New Tab</a>:打开一个新标签页，背景图都是实时更新的美图，与<a href="https://juejin.im/extension/?utm_source=extension&amp;utm_medium=zhihu&amp;utm_campaign=20595240" target="_blank" rel="external">掘金</a>冲突。</p>
<p><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="external">Octotree</a>:在<a href="www.github.com">github</a>上，打开一个项目，能在左侧以windows资源管理器一样以树状图显示项目文件结构。</p>
<p><a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad?hl=zh-CN" target="_blank" rel="external">WEB前端助手(FeHelper)</a>:前端会用到的小工具。</p>
<p><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="external">Tampermonkey</a>:很强大的插件，允许运行JS充当功能，相关JS文件可以去<a href="https://greasyfork.org/zh-CN" target="_blank" rel="external">Greasy Fork</a>下载，比如一些特殊网站的JS，免登录使用zhihu，购物党比价工具、下载youtube视频等。</p>
<p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=zh-CN" target="_blank" rel="external">Vimium</a>:游览网站像操作vim一样操作。</p>
<p><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" target="_blank" rel="external">google翻译</a>:翻译网页或选中字词或短语时翻译。</p>
<p><a href="https://juejin.im/extension/?utm_source=extension&amp;utm_medium=zhihu&amp;utm_campaign=20595240" target="_blank" rel="external">掘金</a>：在新标签页展示内容，为设计师、程序员、产品经理每日发现优质内容。与<a href="https://chrome.google.com/webstore/detail/dream-afar-new-tab/henmfoppjjkcencpbjaigfahdjlgpegn" target="_blank" rel="external">遠方 New Tab</a>冲突。</p>
<p><a href="https://chrome.google.com/webstore/detail/send-to-kindle-by-klipme/ipkfnchcgalnafehpglfbommidgmalan" target="_blank" rel="external">Send to Kindle</a>:一键发送网页文章到Kindle阅读器。</p>
<p><a href="https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien" target="_blank" rel="external">Isometric Contributions</a>:让你在GitHub上的commit像盖楼一样的展示，很有趣，展示下Android大神Jake Wharton的commit情况。</p>
<p><a href="https://github.com/anasnakawa/chrome-github-avatars" target="_blank" rel="external">Avatars for Github</a>:顾名思义，默认我们在GitHub主页动态只能看到id的，而安装了这个插件就可以看到GitHub头像了.</p>
<p><a href="https://chrome.google.com/webstore/detail/%E7%9F%A5%E4%B9%8E%E5%A4%B4%E5%83%8F%E6%94%BE%E5%A4%A7%E5%99%A8/iodddkdbdgcmepjlfieigdigioepgibn?hl=zh-CN" target="_blank" rel="external">知乎头像放大器</a>:把用户头像放大，比直接打开链接还要大。</p>
<p><a href="https://www.zhihu.com/question/23228162" target="_blank" rel="external">chrome有哪些好用的插件</a></p>
<hr>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p><a href="https://www.zhihu.com/question/32129337" target="_blank" rel="external">如何优雅使用windows 10</a>:来自zhihu的问答。</p>
<p><a href="https://atom.io/" target="_blank" rel="external">Atom</a>：Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。</p>
<p><a href="http://www.scootersoftware.com/download.php" target="_blank" rel="external">BCompare</a>：跨平台的文件比较工具。</p>
<p><a href="http://download.pchome.net/system/treak/detail-4359.html" target="_blank" rel="external">EasyBCD</a>:修改PC上多个系统引导程序，选择默认系统引导。</p>
<p><a href="https://www.voidtools.com/downloads/" target="_blank" rel="external">Everything</a>:windows下文件搜索工具，比系统默认的文件检索快得多且支持正则表达式，但不支持文件内容检索，windows自带的检索工具可以设置成检索文件内容。</p>
<p><a href="http://pan.baidu.com/s/1eSJZ9cu" target="_blank" rel="external">SourceInsight</a>:多语言代码编辑工具，支持代码高亮，定义跳转，全局搜索，但对中文支持不太好。</p>
<p><a href="http://pan.baidu.com/s/1hsHnIb6" target="_blank" rel="external">UltraISO</a>:打开ISO文件工具。</p>
<p><a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ch=&amp;tn=baiduhome_pg&amp;bar=&amp;wd=VMware+%E4%B8%8B%E8%BD%BD&amp;rsv_spt=1&amp;oq=fireworks+%E4%B8%8B%E8%BD%BD&amp;rsv_pq=fe1db2c5000198ef&amp;rsv_t=0101HNZP1hokgvnDfCG5xUelLKmDrgNQ31p4elzWh%2FMLyL2eWO6YmVnLIVHSDnA1sy9O&amp;rqlang=cn&amp;rsv_enter=0&amp;inputT=3987" target="_blank" rel="external">VMware</a>:虚拟机软件，在win下的该软件里再安装其它操作系统，但现在windows 10已经有linux子系统了，现在一般可以不用选择这个方案。</p>
<p><a href="http://download.flvcd.com/" target="_blank" rel="external">硕鼠</a>:支持多个网站的在线视频下载。</p>
<p><a href="http://music.163.com/" target="_blank" rel="external">网易云音乐</a>:美观、友好、歌曲推荐算法强。</p>
<p><a href="http://foxmail.com.cn/" target="_blank" rel="external">FoxMail</a>:本地mail客户端。</p>
<p><a href="https://github.com/Wox-launcher/Wox/releases" target="_blank" rel="external">Wox</a>:功能如Mac下的Alfred，使用alt+space可以启用该程序，可以快速检索本地文件、程序并启用，不再频繁操作鼠标和查找文件(检索使用了Everything)。并有大量插件、自定义一些操作，也有默认常用操作，如：g github即为google检索github。</p>
<p><a href="http://www.listary.com/" target="_blank" rel="external">Listary</a>:如功能和Wox一样，但是匹配没有Wox好。来自<a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao的博客</a>。</p>
<p><a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">SourceTree</a>:git应用Gui程序，支持windows、iOS平台。</p>
<p><a href="http://www.xitongcheng.com/jiaocheng/win10_article_27723.html" target="_blank" rel="external">Ubuntu on Windows</a>:在windows 10下安装ubuntu子系统，即可不用虚拟机，也能有linux环境，可用于开发。但目前该系统还有很多坑要填，而且下载也是要win搭个梯子。</p>
<p><a href="http://www.vim.org/download.php" target="_blank" rel="external">Gvim</a>:win下的GUI VIM，如果不是一定要vim才能快速编辑或能熟练使用，还是不要在win下使用vim，相对不是那么友好。(比如常算之后多少个char，使用vim还是很快的)</p>
<p><a href="http://cn.ejie.me/" target="_blank" rel="external">Clover</a>:让windows系统的文件管理器像chrome一样，支持多标签页功能，目前还有不少BUG，但对于常打开多个窗口查找文件来说，还是十分方便。</p>
<p><a href="http://www.huyanbao.com" target="_blank" rel="external">护眼宝</a>：修改屏幕色彩，相传更护眼。有Android、iOS、MAC、windows版。</p>
<p><a href="https://www.teamviewer.com/zhcn/" target="_blank" rel="external">TeamViewer</a>:远程控制，内网穿透，VPN共享，跨平台.对个人免费。目前没有使用过，来自<a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao的博客</a>。</p>
<p><a href="https://anydesk.com/remote-desktop" target="_blank" rel="external">AnyDesk</a>:远程控制效果或许会超出你的想象，作为TeamViewer备用方案,来自<a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao的博客</a>。</p>
<p><a href="http://sunlogin.oray.com/zh_CN/" target="_blank" rel="external">向日葵</a>:官网信息(远程手机操作PC开机，控制)，来自<a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao的博客</a>。</p>
<p><a href="http://www.cockos.com/licecap/" target="_blank" rel="external">licecap</a>:Gif文件录制工具。</p>
<p><em>Powertool</em>:系统清理工具。</p>
<hr>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">zsh</a>:更友好的shell(漂亮的themes，更多的输入匹配)。</p>
<p><a href="https://github.com/DemonCloud/Aix-Vim" target="_blank" rel="external">vim</a>:linux下最常用的编辑器，代码高亮，跳转，IDE界面等，只是要配置成自己更适合的还要多去踩坑。</p>
<hr>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="云梯"><a href="#云梯" class="headerlink" title="云梯"></a>云梯</h3><p><a href="https://github.com/XX-net/XX-Net" target="_blank" rel="external">XX-Net</a>：免费使用google的AppID,每个ID有1G，每个google帐号最多12个AppID，网络速度不错，youtube也能看视频，优点是每天早上可更新流量，且支持chrome、firefox。</p>
<p><a href="https://github.com/getlantern/forum#%E8%93%9D%E7%81%AFlantern%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD" target="_blank" rel="external">蓝灯(Lantern)</a>:免费情况下每月800M，速度不错，优点搭建快速。</p>
<p><a href="https://github.com/softwaredownload/openwrt-fanqiang" target="_blank" rel="external">openwrt</a>:实现路由器自动云梯，且因内置linux系统，可定制化功能，比如外接硬盘当网盘、自动下载BT等。但路由器成本不低，适合居家使用，未曾试用过。</p>
<p><a href="https://uzer.me/" target="_blank" rel="external">UZER.ME</a>:云端软件，常见的如chrome、AI、PS等与办公想关。默认翻墙chrome可以进google、youtube。</p>
<p><a href="https://wsgzao.github.io/post/fq/" target="_blank" rel="external">更多梯子</a>:这里罗列的方案，大都末使用过。</p>
<h3 id="数据备份恢复"><a href="#数据备份恢复" class="headerlink" title="数据备份恢复"></a>数据备份恢复</h3><p>数据备份软件来自<a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao的博客</a>,没有使用过。</p>
<p><a href="http://www.onekeyrestore.cn/" target="_blank" rel="external">易数一键还原</a>:以DiskGenius为内核开发，安全易用靠谱,同时推荐ORM一键还原系统。</p>
<p><a href="http://www.diskgenius.cn/" target="_blank" rel="external">DiskGenius</a>:国内磁盘分区和数据恢复的佼佼者,Mod By MyCrack.</p>
<p><a href="http://www.0daydown.com/?s=EaseUS+Data+Recovery" target="_blank" rel="external">EaseUS Data Recovery Wizard</a>:原先是国产易我数据恢复，现在依旧犀利啊</p>
<h3 id="其它网友环境"><a href="#其它网友环境" class="headerlink" title="其它网友环境"></a>其它网友环境</h3><p><a href="https://wsgzao.github.io/post/windows/" target="_blank" rel="external">wsgzao推荐的软件</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享与记录个人常用软件，包括widows、linux、chrome系,同样，如果您有更好的软件，还请在评论区分享出来。&lt;br&gt;
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
  </entry>
  
  <entry>
    <title>Github Pages与Hexo框架博客的搭建</title>
    <link href="http://LySnake.github.io/archives/technology/Github%20Pages%E4%B8%8EHexo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA.html"/>
    <id>http://LySnake.github.io/archives/technology/Github Pages与Hexo框架博客的搭建.html</id>
    <published>2017-01-22T18:45:57.418Z</published>
    <updated>2017-02-02T05:10:19.747Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文的目的不是<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>与<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo框架</a>框架搭建个人博客的教学，毕竟官网教学更详细更全面，而是记录本人搭建过程中了解、学习并汇总的一些东西，附带链接陈列出来，主要供第一次搭建的朋友参考学习。<br><a id="more"></a></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="git与github"><a href="#git与github" class="headerlink" title="git与github"></a>git与github</h3><p>git:查看廖雪峰的<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000" target="_blank" rel="external">git简介</a>。<br>git工具是Linus继linux开源操作系统之后又一影响世界的项目，因与linux的关系，所以本身是命令行模式，对大多数人来说是不够友好的，在实际使用中可以使用windows或iOS平台上的桌面软件，虽然这样并不能使用git的全部功能。<a href="https://www.github.com/" target="_blank" rel="external">Github</a>就是使用git的通信协议，得力于开源精神而创建的一个平台，并且linux项目也在<a href="https://www.github.com/" target="_blank" rel="external">Github</a>上托管，我们可以使用桌面软件<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">Source Tree</a>管理我们在<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>上的博客项目。</p>
<p>学习成本：初期算半天吧，git重操作，前期学习<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的git教学</a>了解基本理念，之后以多用多学为主，不会咱可以google。</p>
<h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><p><a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>具体信息查看官网是最权威的，这里提出为何使用Github Pages搭建博客的原因：</p>
<ul>
<li>版本管理：<a href="www.github.com">github</a>是目前程序员最火的一个免费的版本管理平台，所谓版本管理，主要是针对文本文档的管理，解决多人、异地、长时间维护共同项目文档所带来的问题，并因为开源精神，所以Free(免费且自由)。</li>
<li>展示：<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>是给<a href="www.github.com">github</a>中用户或项目的一个展示项目，并免费提供300M空间，就项目而言，提供项目介绍与使用相关，对于个人而言可以作为博客，分享知识，也有利于他人了解自己。</li>
<li>全球优良的网络：这个平台是程序员为主的平台，有google、微软等众多一线科技公司在这发布开源项目，也有现今互联网基石linux在其平台进行管理，而且也是技术界大佬建立的公司，在全球都拥有很好的网络连接。</li>
<li>学习：<a href="www.github.com">github</a>上有很多开源的项目，因此也提供了很多开源的软件，比如<a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="external">wox</a>方便windows更好的打开应用。同样，<a href="www.github.com">github</a>也是程序员学习，创建开源项目的地方，可以与他人一同开发、维护开源项目，这其中必不可少的使用git版本管理工具。</li>
<li>其他领域：<a href="www.github.com">github</a>同样开始影响其他领域，可以一起创建项目翻译国外文档、写小说、写项目说明。学习并使用github或许能学习到不一样的知识。参考<a href="https://www.gitbook.com/" target="_blank" rel="external">gitbook</a></li>
<li>搭建学习成本：根据<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>创建<a href="www.github.com">github</a>帐号，Github Pages项目，不到一小时。</li>
</ul>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p><a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>中介绍使用Jekyll框架，因为勘察时感觉对于个人博客而言Jekyll的主题不够华丽，而后选择了<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo框架</a>。在使用上，需要安装Node.js，以命令行的形式使用，对于没有使用过命令行操作电脑的小伙伴还是有点不友好的。对于windows用户可以使用<a href="https://github.com/cmderdev/cmder" target="_blank" rel="external">cmder</a>代替CMD。win7以上可以使用powershell。对于什么是命令行，使用win + R组合键再输入cmd，看到的界面就是命令行界面，以输入字符的方式操作电脑。</p>
<p><strong>学习成本</strong>：参考<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="external">Hexo命令</a>,命令行常用操作也就只有一个网页，常用不到5个命令。但了解、熟悉并使用一定的自定义要看个人。全部搭建完花费4天时间。以后只要编写markdown文档和常用几个命令了。</p>
<h3 id="静态网站"><a href="#静态网站" class="headerlink" title="静态网站"></a>静态网站</h3><p><strong>个人在该博客中对静态、动态网站的理解</strong>：对于浏览器而言是没有多大的区别，相关的也就是使用中要与服务器发送或接收数据，对于服务器而言，静态网页差不多就是网络端存储了些网页相关的资源文件，如html、css、js、图片等，服务器主要响应文件请求与发送；而对于动态网站，我们可以参考QQ空间，每个人的空间基本结构是一样的，但是每个人每个时间点显示的信息都是不一样的，这是因为后台使用PHP、Python、Java等web服务器，在每个用户请求页面时通过与数据库交互，获取特定数据再生成特定资源文件(html、css等)发送到用户浏览器。</p>
<h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p><a href="http://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="external">Markdown</a>官方：</p>
<blockquote>
<p>Markdown 的目标是易于阅读, 创作和编辑文章. HTML 是一种 发布 格式; Markdown 是一种 创作 格式. 因此, Markdown 处理的都是纯文本。</p>
</blockquote>
<p>目前，已知在<a href="www.github.com">github</a>上的项目介绍文件，就是使用Markdown，并且在项目相关的issues等一些文字发布区域，也支持Markdown的编写与预览。其他网站也有推荐使用Markdown进行回答、评论、书写，比如<a href="http://www.jianshu.com/p/d62ca374c90f" target="_blank" rel="external">简书</a>，而我们搭建的博客，就是通过使用Markdown编写成源文件，通过<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo框架</a>与<a href="https://hexo.io/themes/" target="_blank" rel="external">相关主题</a>生成静态网页，再更新到<a href="www.github.com">github</a>个人博客项目库中。并且Markdown可以通过更多插件，提供更多功能，可以预见的是，Markdown将会越加火热。</p>
<p><strong>学习成本</strong>：半天，与git一样，初步了解后多写多练，不会或者忘记勤查文档。</p>
<h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><h3 id="Hexo本地工程目录"><a href="#Hexo本地工程目录" class="headerlink" title="Hexo本地工程目录"></a>Hexo本地工程目录</h3><p>参考<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="external">Hexo建站</a>,假设我们在HexoInit目录下使用<code>hexo init</code>命令来初始化Hexo工程，参考<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">Hexo配置</a>设置配置文件，在HexoInit目录下，我们可以看到:</p>
<ul>
<li>node_modules目录：该目录是npm下载的一些插件，不需直接管理，如有添加、删除应尽量使用npm命令。</li>
<li>public目录：当使用<code>hexo g</code>命令后，会生成静态站相关文件，先通过<code>hexo s</code>本地查看页面，以便修改，最后直接把该目录所有文件上传（commit）到<a href="www.github.com">github</a>个人博客项目，然后再访问。</li>
<li>scaffolds目录：该目录存放模板，模板文件是markdown文件<code>*.md</code>，初始化时已存在三个模板文件，分别对应三个<code>layout</code>。现假设我们有模板jottings.md,内容如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">layout: post</div><div class="line">title: &#123;&#123; title &#125;&#125;</div><div class="line">date: &#123;&#123; date &#125;&#125;</div><div class="line">update: &#123;&#123; updated &#125;&#125;</div><div class="line">comments: false</div><div class="line">categories:</div><div class="line">  - archives</div><div class="line">  - jottings</div><div class="line">tags:</div><div class="line">---</div></pre></td></tr></table></figure>
<p>当使用<code>hexo new jottings fileName</code>命令时，就会以jottings.md的内容生成一个fileName.md文件在source/_posts/目录下，相关配置参考<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="external">Front-matter</a>。</p>
<ul>
<li>source目录：存放使用markdown编写的源文件，当使用<code>hexo g</code>命令生成public目录文件时，Hexo和主题就会使用source目录中的*.md文件生成最后的静态网页文件，其下子目录分布与layout有关。</li>
<li>themes目录：存放配置主题，相关说明见<a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="external">Hexo主题说明</a>。</li>
<li>_config.yml文件：这是Hexo本地工程的配置文件，相关使用说明参考<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">Hexo配置</a></li>
<li>db.json文件：缓存文件，使用<code>hexo clean</code>会清除，使用<code>hexo g</code>时会生成。</li>
<li>package.json文件：该本地工程npm配置文件，记录了node_modules目录安装的插件，如果存在一份配置好的package.json文件，可以直接在HexoInit目录下使用<code>npm install</code>命令读取配置文件安装相关插件。</li>
</ul>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>node_modules目录内容可以根据package.json生成，public目录根据source目录生成，所以我们应备份source目录与_config.yml、package.json二个文件，另外，如果有定制化的scaffolds目录文件，也要备份，以便于今后重建工程时能快速搭建。</p>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>该博客使用的是<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="external">yelee主题</a>，<a href="https://hexo.io/themes/" target="_blank" rel="external">更多主题选择</a>,选择自己喜欢的主题，参考<a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="external">Hexo主题说明</a>配置，一般一个完善的主题会有使用帮助，具体配置，如<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="external">yelee使用说明</a>。在yelee使用说明中，可以查看主题完成显示相关，个性化相关的一些配置，也集成了一些第三方服务与评论系统。</p>
<h2 id="相关帮助连接"><a href="#相关帮助连接" class="headerlink" title="相关帮助连接"></a>相关帮助连接</h2><ul>
<li><a href="https://github.com/getlantern/forum#%E8%93%9D%E7%81%AFlantern%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD" target="_blank" rel="external">蓝灯番墙</a></li>
<li><a href="https://wsgzao.github.io/post/fq/" target="_blank" rel="external">更多番墙方案</a>:个人使用XX-NET</li>
<li><a href="www.github.com">github</a></li>
<li><a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的git教学</a></li>
<li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo官网</a></li>
<li><a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo主题</a></li>
<li><a href="http://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="external">Markdown官方教程</a></li>
<li><a href="https://github.com/cmderdev/cmder" target="_blank" rel="external">cmder</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="external">阮一峰博客-Github Pages搭建博客入门</a></li>
<li><a href="https://wsgzao.github.io/post/hexo-guide/" target="_blank" rel="external">使用GitHub和Hexo搭建免费静态Blog</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文的目的不是&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;与&lt;a href=&quot;https://hexo.io/zh-cn/docs/index.html&quot;&gt;Hexo框架&lt;/a&gt;框架搭建个人博客的教学，毕竟官网教学更详细更全面，而是记录本人搭建过程中了解、学习并汇总的一些东西，附带链接陈列出来，主要供第一次搭建的朋友参考学习。&lt;br&gt;
    
    </summary>
    
      <category term="archives" scheme="http://LySnake.github.io/categories/archives/"/>
    
      <category term="technology" scheme="http://LySnake.github.io/categories/archives/technology/"/>
    
    
      <category term="Github Pages" scheme="http://LySnake.github.io/tags/github-pages/"/>
    
      <category term="Hexo" scheme="http://LySnake.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
